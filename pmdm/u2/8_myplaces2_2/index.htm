<!DOCTYPE html>
<html lang="ca">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../../../../css?family=Noto+Sans+JP">
    <link rel="stylesheet" href="../../../css/main.css">

    
    <title>8. Ampliació de l&#39;aplicació MyPlaces. Intents amb retorn, Galeria, Emmagatzemament i Maps.</title>
</head>

<body>
    
    <div class="header-container">
        
        
        
        
        
    </div>

    
    <div class="main-container">
<nav>
    <h3>
        <a href="../index.htm">
        Unitat 2. Programació d&#39;Android amb Kotlin</a>
    </h3>
    
        
        
        <div class="unitat">
            <a href="../0_javakotlin/index.htm">0. Repàs de Java i introducció a Kotlin</a>
        </div>
        
        <div class="unitat">
            <a href="../1_androidstudio/index.htm">1. Android Studio i Kotlin. Primers pasos.</a>
        </div>
        
        <div class="unitat">
            <a href="../2_arquitecturaapps/index.htm">2. Desenvolupament d&#39;apps en Android</a>
        </div>
        
        <div class="unitat">
            <a href="../3_elemensui/index.htm">3. Elements de la interfície</a>
        </div>
        
        <div class="unitat">
            <a href="../4_recyclerview/index.htm">4. El component RecyclerView</a>
        </div>
        
        <div class="unitat">
            <a href="../5_eventsrecyclerview/index.htm">5. Gestió d&#39;events als RecyclerView</a>
        </div>
        
        <div class="unitat">
            <a href="../6_menus/index.htm">6. Menús en Android I</a>
        </div>
        
        <div class="unitat">
            <a href="../7_myplaces2/index.htm">7. Ampliació de l&#39;aplicació MyPlaces. Navigation Drawer, Fragments, MVVM, View Binding.</a>
        </div>
        
        <div class="unitat">
            <a href="index.htm">8. Ampliació de l&#39;aplicació MyPlaces. Intents amb retorn, Galeria, Emmagatzemament i Maps.</a>
        </div>
        
    
</nav>
    <article>
        <header> 
            <h1>8. Ampliació de l&#39;aplicació MyPlaces. Intents amb retorn, Galeria, Emmagatzemament i Maps.</h1>
        </header>
        <h2 id="1-introducció">1. Introducció</h2>
<p>En aquest apartat anem a afegir més informació al nostre model de lloc, concretament, una imatge del lloc, i les seues coordenades GPS.</p>
<p>Per a això, haurem de modificar per una banda la classe Llocs per ampliar aquestes dades, així com altres modificacions per recuperar i emmagatzemar aquesta nova informació cap a i des de la finestra d&rsquo;edició, i per altra, crear els mecanismes necessaris per obtenir aquesta informació a través del dispositiu (Galeria, GPS&hellip;)</p>
<p>Així doncs, anem a veure primer aquestes modificacions a la interfície d&rsquo;edició d&rsquo;un lloc, i després quines modificacions farem al model.</p>
<h3 id="11-modificant-la-interfície-dedició-de-llocs">1.1. Modificant la interfície d&rsquo;edició de llocs</h3>
<p>Els canvis que anem a realitzar al Layout d&rsquo;edició de llocs seran els següents:</p>
<p><img src="../img/UIEditLloc.png" alt="Canvis en la finestra d&rsquo;edició de llocs"></p>
<p>En aquest cas, s&rsquo;ha hagut d&rsquo;afegir algunes guíes més per ajustar el diseny al Constraint Layout i afegir els botons corresponents:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;ImageButton</span>
        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/imgSelector&#34;</span>
        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
        <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#00FFFFFF&#34;</span>
        <span style="color:#a6e22e">app:layout_constraintBottom_toTopOf=</span><span style="color:#e6db74">&#34;@+id/guideline13&#34;</span>
        <span style="color:#a6e22e">app:layout_constraintEnd_toEndOf=</span><span style="color:#e6db74">&#34;parent&#34;</span>
        <span style="color:#a6e22e">app:layout_constraintStart_toStartOf=</span><span style="color:#e6db74">&#34;@+id/guideline14&#34;</span>
        <span style="color:#a6e22e">app:layout_constraintTop_toTopOf=</span><span style="color:#e6db74">&#34;parent&#34;</span>
        <span style="color:#a6e22e">app:srcCompat=</span><span style="color:#e6db74">&#34;@android:drawable/ic_menu_camera&#34;</span> <span style="color:#f92672">/&gt;</span>

    <span style="color:#f92672">&lt;Button</span>
        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/btMaps&#34;</span>
        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;@string/BtOpenMaps&#34;</span>
        <span style="color:#a6e22e">app:cornerRadius=</span><span style="color:#e6db74">&#34;50dp&#34;</span>
        <span style="color:#a6e22e">app:layout_constraintBottom_toTopOf=</span><span style="color:#e6db74">&#34;@+id/guideline15&#34;</span>
        <span style="color:#a6e22e">app:layout_constraintEnd_toStartOf=</span><span style="color:#e6db74">&#34;@+id/guideline14&#34;</span>
        <span style="color:#a6e22e">app:layout_constraintStart_toStartOf=</span><span style="color:#e6db74">&#34;@+id/guideline12&#34;</span>
        <span style="color:#a6e22e">app:layout_constraintTop_toTopOf=</span><span style="color:#e6db74">&#34;@+id/guideline11&#34;</span> <span style="color:#f92672">/&gt;</span>

    <span style="color:#f92672">&lt;Button</span>
        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/BtCoordinates&#34;</span>
        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;0dp&#34;</span>
        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
        <span style="color:#a6e22e">android:layout_marginStart=</span><span style="color:#e6db74">&#34;16dp&#34;</span>
        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;&#34;</span>
        <span style="color:#a6e22e">android:textSize=</span><span style="color:#e6db74">&#34;10sp&#34;</span>
        <span style="color:#a6e22e">app:cornerRadius=</span><span style="color:#e6db74">&#34;50dp&#34;</span>
        <span style="color:#a6e22e">app:layout_constraintBottom_toTopOf=</span><span style="color:#e6db74">&#34;@+id/guideline15&#34;</span>
        <span style="color:#a6e22e">app:layout_constraintEnd_toStartOf=</span><span style="color:#e6db74">&#34;@+id/guideline12&#34;</span>
        <span style="color:#a6e22e">app:layout_constraintStart_toStartOf=</span><span style="color:#e6db74">&#34;parent&#34;</span>
        <span style="color:#a6e22e">app:layout_constraintTop_toTopOf=</span><span style="color:#e6db74">&#34;@+id/guideline11&#34;</span> <span style="color:#f92672">/&gt;</span>
</code></pre></div><p>Com veiem, es tracta de dos elements de tipus botó comú i un de botó amb imatge.</p>
<h3 id="12-modificació-del-model">1.2. Modificació del model</h3>
<p>Ara anem a modificar la classe Lloc, per afegir-li un parell d&rsquo;atributs més:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Lloc</span>(
        <span style="color:#66d9ef">var</span> nom: String,
        <span style="color:#66d9ef">var</span> descripcio: String,
        <span style="color:#66d9ef">var</span> telefon: String,
        <span style="color:#66d9ef">var</span> web: String,
        <span style="color:#66d9ef">var</span> img: String,
        <span style="color:#66d9ef">var</span> latitud: Double,
        <span style="color:#66d9ef">var</span> longitud: Double)
</code></pre></div><p>En ella afegirem una imatge, que serà representada com un String amb la seua <em>ruta</em>, i dos <em>Double</em> amb la latitud i la lon gitud, per emmagatzemar les coordenades de geolocalització.</p>
<p>A més, caldrà modificar també el mètode per modificar un element (fixeu-vos que no només va a modificar un element, sinò tots els que tinguen el nom que li passem!):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">modifica</span>(originalName: String, lloc: Lloc){
        llocs.forEach {
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">it</span>.nom<span style="color:#f92672">==</span>originalName) {
                <span style="color:#66d9ef">it</span>.nom=lloc.nom;
                <span style="color:#66d9ef">it</span>.descripcio=lloc.descripcio
                <span style="color:#66d9ef">it</span>.telefon=lloc.telefon
                <span style="color:#66d9ef">it</span>.web=lloc.web
                <span style="color:#66d9ef">it</span>.img=lloc.img
                <span style="color:#66d9ef">it</span>.latitud=lloc.latitud
                <span style="color:#66d9ef">it</span>.longitud=lloc.longitud
            }  
        }
    }
</code></pre></div><p>Amb aquestes modificacions al model, ja podem començar a afegir-los contingut.</p>
<h2 id="2-accedint-a-la-galeria-intents-a-activitats-amb-valor-de-retorn">2. Accedint a la galeria: Intents a activitats amb valor de retorn</h2>
<p>Fins ara hem vist com utilitzar les <em>Intents</em> per obrir altres activitats mitjançant el mètode <code>StartActivity</code>. Ens queda per vore com iniciar una activitat de manera que aquesta genere i ens torne un resultat.</p>
<p>Una manera de fer-ho, és fent ús del mètode <code>StartActivityForResult(Intent, requestCode)</code>. Aquest mètode rep dos paràmetres: el primer és la <em>Intent</em>, i el segon és un codi de petició, que establim en este punt, i que utilitzarem quan rebem la resposta, per tal de saber de quina petició es tracta.</p>
<p>Anem a veure, a mode d&rsquo;exemple com faríem per enviar dos números en una Intent a una activitat, que aquesta els sume, i ens torne el resultat.</p>
<p>En una activitat, tenim el següent codi, que estableix dos números i els envia a una altra a traves d&rsquo;una Intent:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">
<span style="color:#75715e">/* Activity 1 */</span>

<span style="color:#75715e">// Definim la Intent
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> intentASuma = Intent (<span style="color:#66d9ef">this</span>, Activitat_Suma<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>.java)
<span style="color:#75715e">// Definim els n úmeros i els afegim a la Intent
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> sum1=<span style="color:#ae81ff">10</span>
<span style="color:#66d9ef">var</span> sum2=<span style="color:#ae81ff">20</span>
<span style="color:#66d9ef">val</span> CODI_PETICIO=<span style="color:#ae81ff">0</span>
intentASuma.putExtra(<span style="color:#e6db74">&#34;sumand_1&#34;</span>, sum1)
intentASuma.putExtra(<span style="color:#e6db74">&#34;sumand_2&#34;</span>, sum2)
<span style="color:#75715e">// Llancem la Intent per obtenir un resultat
</span><span style="color:#75715e"></span>startActivityForResult(intentASuma, CODI_PETICIO)
</code></pre></div><p>Aquest codi llançarà la Intent per obrir la segona activitat, però no es queda esperant a que aquesta li torne el resultat, com ho faria una invocació a una funció, sinò que rebrà el resultat de forma asíncrona mitjançant un esdeveniments, tal i com veurem en breu.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">
<span style="color:#75715e">/* Activity Suma */</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Activitat_Suma</span> : AppCompatActivity() {
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onCreate</span>(savedInstanceState: Bundle?) {
        <span style="color:#66d9ef">super</span>.onCreate(savedInstanceState)
        <span style="color:#f92672">..</span>.
        <span style="color:#75715e">// Agafem els sumands de la Intent:
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">var</span> sumands = intent.extras
        <span style="color:#66d9ef">if</span> (sumands<span style="color:#f92672">==</span><span style="color:#66d9ef">null</span>){ <span style="color:#75715e">// Si no tenim sumands, eixim
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span>
        }

        <span style="color:#66d9ef">var</span> sum_1 = sumands.getInt(<span style="color:#e6db74">&#34;sumand_1&#34;</span>)
        <span style="color:#66d9ef">var</span> sum_2 = sumands.getInt(<span style="color:#e6db74">&#34;sumand_2&#34;</span>)
        <span style="color:#f92672">..</span>.
        <span style="color:#75715e">// Creem una nova Intent per al resultat
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">var</span> result=Intent()
        <span style="color:#75715e">// I afegim com a extres el camp &#34;suma&#34; amb
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// la suma dels dos números
</span><span style="color:#75715e"></span>        result.putExtra(<span style="color:#e6db74">&#34;suma&#34;</span>, sum_1+sum_2)
        
        <span style="color:#75715e">// Retornem el resultat amb SetResult, passant-li
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// si l&#39;activitat ha estat exitosa (Activity.RESULT_OK), i
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// la Intent amb el resultat
</span><span style="color:#75715e"></span>        setResult(Activity.RESULT_OK,result)

        <span style="color:#75715e">// I finalment tanquem l&#39;activitat
</span><span style="color:#75715e"></span>        finish()
    })
}

</code></pre></div><p>I ara, a la primera activitat, caldrà implementar l&rsquo;esdeveniment <code>onActivityResult</code> que és invocat quan se&rsquo;ns torna el resultat d&rsquo;una activitat. En aquest rebrem <code>requestCode</code> que és el codi de la petició que hem fet inicialment (i per tant, ens serveix per saber la resposta a quina Intent es tracta), <code>resultCode</code>, que ens indica si l&rsquo;activitat ha tingut èxit, el camp <code>data</code> amb les dades de retorn:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onActivityResult</span>(requestCode: Int, 
                              resultCode: Int,
                            <span style="color:#66d9ef">data</span>: Intent?){
    <span style="color:#66d9ef">super</span>.onActivityResult(requestCode, resultCode, <span style="color:#66d9ef">data</span>)
    <span style="color:#66d9ef">if</span> (resultCode <span style="color:#f92672">==</span> Activity.RESULT_OK 
        <span style="color:#f92672">&amp;&amp;</span> requestCode<span style="color:#f92672">==</span>CODI_PETICIO){
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">data</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
                <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">data</span>.hasExtra(<span style="color:#e6db74">&#34;suma&#34;</span>)){
                resultat=<span style="color:#66d9ef">data</span>.extras.getInt(<span style="color:#e6db74">&#34;suma&#34;</span>)
                <span style="color:#f92672">....</span>
            }
        }
    }
    }
</code></pre></div><p>D&rsquo;aquesta manera, amb un únic mètode <code>onActivityResult</code>, podem gestionar, gràcies al <code>requestCode</code>, la resposta provinent de diferents <em>Intents</em>.</p>
<h3 id="21-afegint-una-imatge-de-la-galeria">2.1. Afegint una imatge de la galeria</h3>
<p>Anem a fer una <em>Intent</em> per tal de demanar-li a l&rsquo;aplicació de la Galeria que ens retorne una imatge. Això ho gestionarem quan es faça click al botó <code>imgSelector</code> de la classe <code>EditLloc</code>. Per tant, haurem d&rsquo;utilitzar el mètode <code>setOnClicListener</code> d&rsquo;aquesta.</p>
<p>El primer que farem en aquest mètode és definir la Intent establint l&rsquo;acció <code>ACTION_OPEN_DOCUMENT</code>, que permet seleccionar fitxers, i que aquests es puguen obrir (afegint la categoria <code>Intent.CATEGORY_OPENABLE</code>). A més, com que els fitxers hauran de ser imatges, hem d&rsquo;establir el tipus MIME com a <code>image/*</code>. A més, afegirem alguns flags amb permisos, que veurem després.</p>
<p>Finalment, obrim l&rsquo;activitat amb <code>startActivityForResult</code>, passant-li la <em>Intent</em> i un codi de petició, en aquest cas <em>1</em> (podriem haver utilitzat una constant):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">binding.imgSelector.setOnClickListener{
            <span style="color:#66d9ef">val</span> openDocumentIntent = Intent(Intent.ACTION_OPEN_DOCUMENT)
            openDocumentIntent.addCategory(Intent.CATEGORY_OPENABLE)
            openDocumentIntent.type = <span style="color:#e6db74">&#34;image/*&#34;</span>
            openDocumentIntent.flags = (Intent.FLAG_GRANT_READ_URI_PERMISSION
                    or Intent.FLAG_GRANT_WRITE_URI_PERMISSION
                    or Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION)
            startActivityForResult(openDocumentIntent, <span style="color:#ae81ff">1</span>)
        }
</code></pre></div><p>Aqueta Intent ens retorna la <em>Url</em> amb la ubicació de la imatge en un event <em>ActivityResult</em>, que com hem vist a l&rsquo;apartat anterior haurem de capturar. amb <code>onActivityResult</code>.</p>
<p>En aquest mètode comprovarem si l&rsquo;activitat ha tingut èxit i si el codi de la petició és el que haviem establert en l'<code>startActivityForResult</code> (1). Si és així, comprovem que tenim dades, ens guardem la Uri,i actualitzem la imatge de l'<em>ImageView</em>.</p>
<p>Cal tindre en compte que, a diferència d&rsquo;altres dades com el nom o la descripció del lloc, dels que podem traure el contingut a partir dels corresponents <em>TextViews</em>, en el cas d&rsquo;un <em>ImageView</em> no podem obtindre l'<em>URL</em> de la imatge, pel que ens guardarem el valor d&rsquo;aquesta a una variable que haurem creat dins la pròpia classe.</p>
<p>Així doncs, aquesta part s&rsquo;implementarà:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EditLloc</span> : AppCompatActivity() {
    <span style="color:#f92672">..</span>.
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> tmpUri: String=<span style="color:#e6db74">&#34;&#34;</span>

    <span style="color:#f92672">..</span>.

<span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onActivityResult</span>(requestCode: Int, resultCode: Int, <span style="color:#66d9ef">data</span>: Intent?) {
        <span style="color:#66d9ef">super</span>.onActivityResult(requestCode, resultCode, <span style="color:#66d9ef">data</span>)

        <span style="color:#75715e">// Si l&#39;activitat s&#39;ha resolt amb èxit, comprovem el codi de la
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// petició, i segons la petició sabem com interpretar la resposta.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (resultCode<span style="color:#f92672">==</span> Activity.RESULT_OK <span style="color:#f92672">&amp;&amp;</span> requestCode<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>){

            <span style="color:#75715e">// En data tenim les dades de la resposta
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">data</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
                <span style="color:#75715e">// Guardem el string de la Uri en tmpUri, ja que una vegada la bolquem a
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// l&#39;ImageView, no sabem com recuperar-la
</span><span style="color:#75715e"></span>                tmpUri=<span style="color:#66d9ef">data</span>.dataString.toString()
                
                <span style="color:#66d9ef">val</span> uri: Uri? = <span style="color:#66d9ef">data</span>.<span style="color:#66d9ef">data</span>

                <span style="color:#66d9ef">try</span> {
                    binding.addLlocImg.setImageURI(uri)

                    <span style="color:#75715e">//binding.addLlocImg.get
</span><span style="color:#75715e"></span>
                } <span style="color:#66d9ef">catch</span> (e: IOException) {
                    e.printStackTrace()
                }
                
            }
        }

    }
    <span style="color:#f92672">..</span>.
}
</code></pre></div><p>Amb estos canvis, <strong>quan fem clic en el botó per guardar els canvis, caldrà també emmagatzemar la Url de la imatge, així com poder mostrar-la cada vegada que iniciem l&rsquo;activitat</strong>. De tota manera, com que també caldrà guardar la informació sobre la geolocalització, anem a veure com obtenir primer aquesta i després com guardar les dades.</p>
<blockquote>
<p><strong>Documentació Addicional</strong></p>
<p>En aquest article trobareu un exemple complet sobre com accedir a les funcionalitats de la càmera del dispositiu. El llenguatge que utilitza és Java, però es pot adaptar fàcilment a Kotlin.</p>
<p><a href="https://www.journaldev.com/13270/android-capture-image-camera-gallery">https://www.journaldev.com/13270/android-capture-image-camera-gallery</a></p>
</blockquote>
<h3 id="22-obtenint-les-coordenades-gps">2.2. Obtenint les coordenades GPS</h3>
<p>Per tal t&rsquo;accedir a la localització per GPS podem fer-ho mitjançant la pròpia API de l&rsquo;SDK d&rsquo;Android, fent ús de la classe <code>LocationManager</code>, o bé mitjançant l&rsquo;API de Google Play Services. Anem a utilitzar la pròpia d el&rsquo;SDK d&rsquo;Android.</p>
<p>Amb l&rsquo;API de l&rsquo;SDK podem utilitzar dos proveïdors per saber la ubicació:</p>
<ul>
<li><code>LocationManager.GPS_PROVIDER</code>: Determina la ubicació mitjançant els satèl·lits GPS, i segons les condicions pot tardar un temps en donar la ubicació,</li>
<li><code>LocationManager.NETWORK_PROVIDER</code>: Que ens ofereix la ubicació en funció de la triangulació amb amb antenes de comunicacions i punts d&rsquo;accés Wifi.</li>
<li><code>LocationManager.PASSIVE_PROVIDER</code>: Que retorna les ubicacions generades per altres proveïdors, de manera que de forma passiva es reben actualitzacions d&rsquo;ubicació quan altres aplicacions o serveis les sol·liciten.</li>
</ul>
<p>Abans d&rsquo;accedir a la informació de localització del GPS, cal habilitar els permisos corresponents per tal de poder utilitzar la localització al fitxer <em>AndroidManifest.xml</em>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;manifest</span> <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
    <span style="color:#a6e22e">package=</span><span style="color:#e6db74">&#34;com.ieseljust.pmdm.myplaces20&#34;</span><span style="color:#f92672">&gt;</span>
    ...
    <span style="color:#75715e">&lt;!-- Permisos per a la ubicacio --&gt;</span>
    <span style="color:#f92672">&lt;uses-permission</span> <span style="color:#a6e22e">android:name=</span><span style="color:#e6db74">&#34;android.permission.ACCESS_COARSE_LOCATION&#34;</span> <span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;uses-permission</span> <span style="color:#a6e22e">android:name=</span><span style="color:#e6db74">&#34;android.permission.ACCESS_FINE_LOCATION&#34;</span> <span style="color:#f92672">/&gt;</span>
    ...
<span style="color:#f92672">&lt;/manifest&gt;</span>
</code></pre></div><p>Així, demanarà a l&rsquo;usuari accés a la localització quan es necessite:</p>
<p><img src="../img/location_permissions.png" alt="Activant permisos de localització"></p>
<p>Recordem que la localització l&rsquo;obtindrem quan fem clic al botó <em>BtCoordinates</em> que conté les coordenades del lloc. Haurem d&rsquo;implementar doncs el mètode <code>setOnClickListener</code> sobre aquest botó. El que farem serà invocar altra funció privada <code>getLocation</code> que implementarem posteriorment:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">binding.BtCoordinates.setOnClickListener {
    <span style="color:#75715e">// Invoca al mètode getLocation per obtenir les
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// coordenades GPS
</span><span style="color:#75715e"></span>   getLocation()
   }
</code></pre></div><p>En aquesta funció <code>getLocation</code>, farem ús del servei de localització del sistema  <em>LOCATION_SERVICE</em> i obtindrem la localització mitjançant un proveïdor GPS. Abans d&rsquo;obtenir les coordenades, caldrà comprovar que tenim els permissos suficients (<code>Manifest.permission.ACCESS_FINE_LOCATION</code> = <code>PackageManager.PERMISSION_GRANTED</code>) o demanar-los</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">getLocation</span>() {
        locationManager = getSystemService(Context.LOCATION_SERVICE) <span style="color:#66d9ef">as</span> LocationManager
        <span style="color:#75715e">// Estes comprovacions comproven si tenim o no permisos, però no sembla que donen permis
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> ((ContextCompat.checkSelfPermission(<span style="color:#66d9ef">this</span>, Manifest.permission.ACCESS_FINE_LOCATION) <span style="color:#f92672">!=</span> PackageManager.PERMISSION_GRANTED)) {
            ActivityCompat.requestPermissions(
                <span style="color:#66d9ef">this</span>,
                arrayOf(Manifest.permission.ACCESS_FINE_LOCATION),
                locationPermissionCode
            )
        }
        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, <span style="color:#ae81ff">5000</span>, <span style="color:#ae81ff">5f</span>, <span style="color:#66d9ef">this</span>)
    }
</code></pre></div><p>En el moment en què s&rsquo;obtinga una ubicació, rebrem l&rsquo;event <code>LocationChanged</code>, que podrem capturar sobreescrivint el mètode <code>onLocationChanged</code>. Aquest mètode ens oferirà un paràmetre de tipus <em>Location</em>  amb la longitud i la latitud. <strong>Fixeu-vos que per tal de poder utilitzar aquest mètode, la nostra classe da d&rsquo;implementar la interfície <code>LocationListener</code>!</strong>. Al nostre cas, el que farem serà emmagatzemar aquestes variables en variables de la classe <em>EditLloc</em>, per tal de poder emmagatzemar-les posteriorment de manera més senzilla, tal i com hem fet amb la imatge. Una vegada temim les posicions, modificarem el text intern del mateix botó <em>BtCoordinates</em> per mostrar-les, restringint la longitud a tres decimals:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EditLloc</span> : AppCompatActivity(), LocationListener {

    <span style="color:#f92672">..</span>.
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> latitud: Double = <span style="color:#ae81ff">0.0</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> longitud: Double = <span style="color:#ae81ff">0.0</span>
    <span style="color:#f92672">..</span>.

<span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onLocationChanged</span>(location: Location) {
        latitud=location.latitude
        longitud=location.longitude
        binding.BtCoordinates.text=<span style="color:#e6db74">&#34;(&#34;</span>+String.format(<span style="color:#e6db74">&#34;%.3f&#34;</span>, latitud)+<span style="color:#e6db74">&#34;, &#34;</span>+String.format(<span style="color:#e6db74">&#34;%.3f&#34;</span>, longitud)+<span style="color:#e6db74">&#34;)&#34;</span>
    }
}
</code></pre></div><p>Ara sí, amb tot açò, ja podem emmagatzemar completament el lloc quan fem clic al botó de gravar, i emmagatzemar, a banda del contingut dels textViews, la posició i la imatge. Recordeu que la variable lògica <code>isEditing</code> ens diu si estem editant un lloc o si estem afegint-lo.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">binding.btSave.setOnClickListener{
    <span style="color:#66d9ef">var</span> nom=binding.editTextNom.text.toString()
    <span style="color:#66d9ef">var</span> desc=binding.editTextDesc.text.toString()
    <span style="color:#66d9ef">var</span> tel=binding.editTextTel.text.toString()
    <span style="color:#66d9ef">var</span> web=binding.editTextWeb.text.toString()
    <span style="color:#75715e">// La ruta a la imatge la tenim guardada en tmpUri, ja que
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// no podem accedir directament a aquesta a través de l&#39;ImageView.
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">if</span> (nom<span style="color:#f92672">!=</span><span style="color:#e6db74">&#34;&#34;</span>) {
            <span style="color:#66d9ef">var</span> nouLloc=Lloc(nom, desc, tel, web, tmpUri, latitud, longitud)
            <span style="color:#75715e">// Si està editant, borrem primer l&#39;anterior
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (isEditing) Llocs.modifica(originalName, nouLloc)
            <span style="color:#66d9ef">else</span> Llocs.add(nouLloc)
            <span style="color:#75715e">// I nalment, tanquem l&#39;activitat, en lloc de fer una Intent
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// a l&#39;activitat principal
</span><span style="color:#75715e"></span>            HomeFragment.allowRefresh=<span style="color:#66d9ef">true</span>
            finish()
    }
 
    }

</code></pre></div><p>Fixem-nos en el detall de les dues últimes intruccions després de guardar:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">HomeFragment.allowRefresh=<span style="color:#66d9ef">true</span>
finish()
</code></pre></div><p>El mètode <em>Finish</em> serveix per tal de finalitzar l'<em>Activity</em> en la que estem, i és molt més raonable utilitzar aquest per tornar a l&rsquo;activitat inicial que llançar una Intent per obrir de nou aquesta.</p>
<p>El problema que ens trobem amb aquest mètode és que quan tanquem l&rsquo;activitat, l&rsquo;activitat anterior no mostra els canvis, ja que no estem recarregant cap vista. La línia anterior <code>HomeFragment.allowRefresh=true</code> és part de la solució que veurem tot seguit.</p>
<p><em><strong>Actualització del fragment Home quan hi ha modificacions</strong></em></p>
<p>A la vista <em>FragmentHome</em> controlem quan s&rsquo;eliminen ítems del <em>RecyclerView</em>, però quan afegim un lloc nou o en modifiquem un d&rsquo;existent, els canvis que hem realitzat a l&rsquo;objecte compartit <em>Llocs</em> no s&rsquo;han reflexat al <em>ViewModel</em> d&rsquo;aquesta vista, i per tant, la vista no s&rsquo;actualitza.</p>
<p>Per controlar això, anem a fer ús de l&rsquo;event <em>Resume</em> de la classe HomeFragment, que es dispara després de cada pausa i a l&rsquo;inici de l&rsquo;activitat. Per tal de controlar quan volem que es refresque la vista i quan no, farem ús d&rsquo;un <em>objecte acompanyant</em> (el que en Java seria una variable estàtica), de tipus booleà, que anomenarem <em>allowRefresh</em>, que inicialment valdrà <em>true</em> i que després de cada refresc <em>conscient</em>, posarem a <em>false</em>. Així doncs, cada vegada que volguem que la pàgina es refresque, simplement amb posar a <em>true</em> aquesta variable del <em>HomeFragment</em>, ho farem possible.</p>
<p>Dins aquest mètode ja, per fer el refresc, el que fem és <em>deslligar</em> i tornar a <em>enllaçar</em> el propi fragment del fragment pare, tot en una transacció, de manera que obliguem el seu redibuixat (gràcies StackOverflow!)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">requireParentFragment().childFragmentManager.beginTransaction().detach(<span style="color:#66d9ef">this</span>).attach(<span style="color:#66d9ef">this</span>).commit();
</code></pre></div><p>Amb això, aquesta part de la classe ens quedaria:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HomeFragment</span> : Fragment() {

    <span style="color:#f92672">..</span>.

    <span style="color:#66d9ef">companion</span> <span style="color:#66d9ef">object</span>
    { <span style="color:#66d9ef">var</span> allowRefresh:Boolean=<span style="color:#66d9ef">true</span> }

<span style="color:#f92672">..</span>.

<span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onResume</span>() {  <span style="color:#75715e">// After a pause OR at startup
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">super</span>.onResume()

        <span style="color:#66d9ef">if</span> (allowRefresh) {
            allowRefresh = <span style="color:#66d9ef">false</span>
            Log.d(<span style="color:#e6db74">&#34;REFRESH&#34;</span>, <span style="color:#e6db74">&#34;REFRESH&#34;</span>);
            requireParentFragment().childFragmentManager.beginTransaction().detach(<span style="color:#66d9ef">this</span>)
                .attach(<span style="color:#66d9ef">this</span>).commit();
        }

    }
}
</code></pre></div><p><em><strong>El mètode onCreate d&rsquo;EditLloc i questions sobre permissos</strong></em></p>
<p>Quan es crea la vista d&rsquo;edició del lloc (mètode <code>onCreate</code> de la classe <em>EditLloc</em>), si anem a modificar un lloc existent, rebem una <em>Intent</em> amb la informació que ens envía el <em>ViewHolder</em> corresponent, que és qui detecta el click en cada element <strong>(tingueu en compte que caldrà incorporar a aquesta Intent totes les noves variables que hem afegit a la classe Lloc!)</strong>. Amb les dades d&rsquo;aquesta <em>Intent</em>, emplenem els diferents elements de la interfície, tant els textViews, com la imatge i les coordenades GPS:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onCreate</span>(savedInstanceState: Bundle?) {
        <span style="color:#66d9ef">super</span>.onCreate(savedInstanceState)

        <span style="color:#75715e">// Utilitzem el View Binding per enllaçar amb la UI
</span><span style="color:#75715e"></span>        binding = ActivityEditLlocBinding.inflate(layoutInflater)
        setContentView(binding.root)
        <span style="color:#f92672">..</span>.

        <span style="color:#66d9ef">val</span> desc = intent.extras<span style="color:#f92672">?.</span>getString(<span style="color:#e6db74">&#34;desc&#34;</span>)<span style="color:#f92672">?:</span><span style="color:#e6db74">&#34;&#34;</span>
        <span style="color:#66d9ef">if</span> (desc<span style="color:#f92672">!=</span><span style="color:#e6db74">&#34;&#34;</span>) binding.editTextDesc.setText(desc)

        <span style="color:#66d9ef">val</span> tel = intent.extras<span style="color:#f92672">?.</span>getString(<span style="color:#e6db74">&#34;tel&#34;</span>)<span style="color:#f92672">?:</span><span style="color:#e6db74">&#34;&#34;</span>
        <span style="color:#66d9ef">if</span> (tel<span style="color:#f92672">!=</span><span style="color:#e6db74">&#34;&#34;</span>) binding.editTextTel.setText(tel)

        <span style="color:#66d9ef">val</span> web = intent.extras<span style="color:#f92672">?.</span>getString(<span style="color:#e6db74">&#34;web&#34;</span>)<span style="color:#f92672">?:</span><span style="color:#e6db74">&#34;&#34;</span>
        Log.d(<span style="color:#e6db74">&#34;EditLloc:web&#34;</span>, web)
        <span style="color:#66d9ef">if</span> (web<span style="color:#f92672">!=</span><span style="color:#e6db74">&#34;&#34;</span>) binding.editTextWeb.setText(web)

        <span style="color:#75715e">// Agafen la uri de la intent, la guardem temporalment (ja que després no
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// la tindrem en un TextView) i a partir d&#39;ella generem el bitmap per al imageView
</span><span style="color:#75715e"></span>        tmpUri = intent.extras<span style="color:#f92672">?.</span>getString(<span style="color:#e6db74">&#34;img&#34;</span>)<span style="color:#f92672">?:</span><span style="color:#e6db74">&#34;&#34;</span>
        <span style="color:#66d9ef">if</span> (tmpUri<span style="color:#f92672">!=</span><span style="color:#e6db74">&#34;&#34;</span>) {
            <span style="color:#75715e">// Si tenim una imatge definida, l&#39;obrim i obtenim el seu bitmap per
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// afegir-lo a l&#39;ImageView addLlocImg.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// Si no tenim els permissos suficients concedits quan hem get la Intent
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">val</span> inputStream = contentResolver.openInputStream(Uri.parse(tmpUri))
            <span style="color:#66d9ef">val</span> bitmap = BitmapFactory.decodeStream(inputStream)
            binding.addLlocImg.setImageBitmap(bitmap)
        }

        <span style="color:#75715e">// I fem el mateix amb la latitud i la longitud
</span><span style="color:#75715e"></span>        longitud = intent.extras<span style="color:#f92672">?.</span>getDouble(<span style="color:#e6db74">&#34;longitud&#34;</span>)<span style="color:#f92672">?:</span><span style="color:#ae81ff">0.0</span>
        latitud = intent.extras<span style="color:#f92672">?.</span>getDouble(<span style="color:#e6db74">&#34;latitud&#34;</span>)<span style="color:#f92672">?:</span><span style="color:#ae81ff">0.0</span>
        <span style="color:#75715e">// I generem el contingut del botó de localització
</span><span style="color:#75715e"></span>        binding.BtCoordinates.text=<span style="color:#e6db74">&#34;(&#34;</span>+String.format(<span style="color:#e6db74">&#34;%.3f&#34;</span>, latitud)+<span style="color:#e6db74">&#34;, &#34;</span>+String.format(<span style="color:#e6db74">&#34;%.3f&#34;</span>, longitud)+<span style="color:#e6db74">&#34;)&#34;</span>
        <span style="color:#f92672">..</span>.
}
</code></pre></div><p>Fixeu-vos que per al contingut de la imatge, fem ús de la classe <em>contentResolver</em> que ens ofereix un Stream d&rsquo;entrada a partir de la URI que li passem, de manera que llegim el fitxer, i amb la classe BitmanFactory el decodifiquem i obtenim un bitmap que utilitzarem per <em>pintar</em> l&rsquo;ImageView corresponent (<em>addLlocImg</em>).</p>
<p>Ara bé. Tingueu en compte que estem accedint a un recurs que en principi no és nostre. Quan hem accedit a ell i hem obtingut la seua URI a través de la galeria d&rsquo;imatges, ha estat aquesta qui ha accedit a la imatge, i en eixe moment ens ha concedit permí per llegir-la. És possible doncs, que si no tenim permís per accedir al fitxer ens bote un missatge d&rsquo;error i no ens deixe realitzar la lectura. Per tal d&rsquo;evitar això, hem de fer possible <em>heretar</em> els permissos que ens dóna temporalment la galeria sobre el recurs i fer-los permanents.</p>
<p>En primer lloc, modificarem el fitxer de Manifest amb:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;uses-permission</span> <span style="color:#a6e22e">android:name=</span><span style="color:#e6db74">&#34;android.permission.READ_EXTERNAL_STORAGE&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;uses-permission</span> <span style="color:#a6e22e">android:name=</span><span style="color:#e6db74">&#34;android.permission.ACTION_OPEN_DOCUMENT&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;uses-permission</span> <span style="color:#a6e22e">android:name=</span><span style="color:#e6db74">&#34;android.permission.WRITE_EXTERNAL_STORAGE&#34;</span> <span style="color:#f92672">/&gt;</span>
</code></pre></div><p>I quan obtenim la imatge des de la Intent per obrir la galeria, hem d&rsquo;afegir els <em>flags</em> correpsonents:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">openDocumentIntent.flags = (Intent.FLAG_GRANT_READ_URI_PERMISSION
                    or Intent.FLAG_GRANT_WRITE_URI_PERMISSION
                    or Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION)
</code></pre></div><blockquote>
<p><strong>Carregant imatges al dispositiu</strong></p>
<p>Si voleu afegir imatges al dispositiu, per utilitzar-les a l&rsquo;aplicació, cal obrir el <em>Device File Explorer</em> i arrossegar-les a: <em>Storage &gt; VolumID &gt; DCIM</em> per poder-les seleccionar:</p>
<p><img src="../img/Device_File_Explorer.png" alt="Explorador de fitxers"></p>
</blockquote>
<blockquote>
<p><strong>Documentació oficial</strong></p>
<p>Teniu més informació sobre el servei d&rsquo;ubicació en:</p>
<ul>
<li><a href="https://developers.google.com/maps/documentation/android-sdk/location?hl=es">https://developers.google.com/maps/documentation/android-sdk/location?hl=es</a></li>
</ul>
</blockquote>
<h3 id="23-intent-a-google-maps">2.3. Intent a Google Maps</h3>
<p>Ja només ena queda obrir l&rsquo;aplicació de Maps quan fem clic al botó <code>BtMaps</code>. El que farem serà obrir un mapa amb la ubicació indicada per les coordenades del lloc que tenim guardades. Maps necessita que li proporcionem una cadena de text amb la uri que ha de carregar, en la forma: <em>&ldquo;geo:latitud, longitud</em>, i si ho desitgem un paràmetre amb el zoom (<em>?z=20</em>).</p>
<p>Una vegada tinguem preparada la URI de la ubicació, utilitzarem una Intent <code>ACTION_VIEW</code>. El codi resultant serà:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">binding.btMaps.setOnClickListener {
    <span style="color:#66d9ef">val</span> uri:String=<span style="color:#e6db74">&#34;geo:&#34;</span>+latitud+<span style="color:#e6db74">&#34;,&#34;</span>+longitud+<span style="color:#e6db74">&#34;?z=20&#34;</span>
    <span style="color:#66d9ef">val</span> intent = Intent(Intent.ACTION_VIEW, Uri.parse(uri))
    startActivity(intent)
}
</code></pre></div><blockquote>
<p><strong>Intents de Google Maps</strong></p>
<p><a href="https://developers.google.com/maps/documentation/urls/android-intents">https://developers.google.com/maps/documentation/urls/android-intents</a></p>
</blockquote>
<blockquote>
<p><strong>Documentació sobre recollir el resultat d&rsquo;una activitat</strong></p>
<p>En aquesta pàgina de la documentació us comenta com realitzar l&rsquo;acés als resultats a través de l&rsquo;API de resultats d&rsquo;activitat d&rsquo;AndroidX:</p>
<p><a href="https://developer.android.com/training/basics/intents/result">https://developer.android.com/training/basics/intents/result</a></p>
</blockquote>
<h2 id="3-persistència-de-dades">3. Persistència de dades</h2>
<p>Amb Android disposem de diverses opcions a l&rsquo;hora de fer persistents les dades de les nostres aplicacions. Entre ells podem destacar:</p>
<ul>
<li><em>Classe <code>SharedPreferences</code></em>, que permet emmagatzemar una quantitat limitada de dades, com puga ser la configuració de les aplicacions, l&rsquo;estat d&rsquo;un joc, etc.</li>
<li><em>Fitxers de text</em>, que poden ser útils per emmagatzemar una major quantitat de dades bé al dispositiu com a la targeta SD.</li>
<li><em>Fitxers XML</em>, per emmagatzemar dades estructurades, i accedint a través de SAX o DOM, o bé en format <em>JSON</em>,</li>
<li><em>Proveïdors de continguts</em>, com puguen ser els contactes,</li>
<li><em>Bases de dades</em>, per emmagatzemar les dades de forma organitzada,</li>
<li><em>En el núvol</em>, aprofitant serveis d&rsquo;emmagatzemament en Internet.</li>
</ul>
<p>Tot i que pot se de bastant utilitat explorar tots aquests mecanismes, anem a centrar-nos en la persistència mitjançant bases de dades.</p>
<h3 id="31-sqlite">3.1. SQLite</h3>
<p>Android ofereix una base de dades interna SQLite, que permet la seua gestió mitjançant ordres SQL.</p>
<p>No obstant això, la pròpia <a href="https://developer.android.com/training/data-storage/sqlite?hl=es">documentació d&rsquo;Android sobre SQLite</a> ens recomana la utilització de l&rsquo;ORM <em>Room</em> com una capa d&rsquo;abstracció per a ccedir a les bases de dades SQLite de les nostres aplicacions.</p>
<p>Al nostre cas, anem a utilitzar <em>Sugar</em>, un altre ORM per a Android, bastant més senzill, però que ens permetrà interactuar amb la base de dades, pràcticament sense realitzar canvis substancials al nostre codi base,i sense necessitat de fitxers de mapat o d&rsquo;haver de realitzar enginyeria inversa.</p>
<p>Tal i com es comenta a la <a href="https://satyan.github.io/sugar/">seua web</a> <em>Sugar ORM</em> està pensat per simplificar la interacció directa amb la BD SQLite des d&rsquo;Android, de manera que:</p>
<ul>
<li>Crea la base de dades per nosaltres,</li>
<li>Elimina la necessitat d&rsquo;escriure consultes SQL per interactuar amb SQLite,</li>
<li>Gestiona les relacions entre els objectes,</li>
<li>Ofereix una API bastant senzilla per realitzar opearcions amb la base de dades.</li>
</ul>
<p>Anem a veure com utilitzar <em>Sugar ORM</em> en el nostre projecte per tal de veure&rsquo;n el funcionament.</p>
<ol>
<li><strong>Dependències</strong></li>
</ol>
<p>En primer lloc hem d&rsquo;afegir les dependències al fitxer <em>build.gradle</em> de l&rsquo;aplicació. Podem buscar la última versió a Maven Central, i veurem que es tracta de la 1.5. Així doncs, afegirem a aquest fitxer la dependència dins el bloc corresponent:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">
dependencies<span style="color:#f92672">{</span>
    <span style="color:#f92672">...</span>
    implementation <span style="color:#e6db74">&#39;com.github.satyan:sugar:1.5&#39;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Una vegada afegida la dependència, Android Studio ens demanarà sincronitzar el projecte.</p>
<ol start="2">
<li><strong>Modificació del Manifest</strong></li>
</ol>
<p>En segon lloc, afegim al fitxer <em>AndroidManifest.xml</em>, dins l&rsquo;etiqueta <!-- raw HTML omitted --> la propietat <code>android:name=&quot;com.orm.SugarApp&quot;</code>, per indicar el tipus d&rsquo;aplicació, i abans de tancar l&rsquo;etiqueta, les metadades sobre la basede dades (nom del fitxer d&rsquo;SQLite, versió de l&rsquo;esquema de la base de dades, si volem que es registren o no les consultes generades, i el nom del paquet on es trobaran les nostres entitats):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;application</span>
        <span style="color:#960050;background-color:#1e0010">..</span>
        <span style="color:#a6e22e">android:label=</span><span style="color:#e6db74">&#34;@string/app_name&#34;</span>
        <span style="color:#960050;background-color:#1e0010">...</span>
        <span style="color:#a6e22e">android:name=</span><span style="color:#e6db74">&#34;com.orm.SugarApp&#34;</span><span style="color:#f92672">&gt;</span>

...

    <span style="color:#f92672">&lt;meta-data</span> <span style="color:#a6e22e">android:name=</span><span style="color:#e6db74">&#34;DATABASE&#34;</span> <span style="color:#a6e22e">android:value=</span><span style="color:#e6db74">&#34;myplaces2.db&#34;</span> <span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;meta-data</span> <span style="color:#a6e22e">android:name=</span><span style="color:#e6db74">&#34;VERSION&#34;</span> <span style="color:#a6e22e">android:value=</span><span style="color:#e6db74">&#34;2&#34;</span> <span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;meta-data</span> <span style="color:#a6e22e">android:name=</span><span style="color:#e6db74">&#34;QUERY_LOG&#34;</span> <span style="color:#a6e22e">android:value=</span><span style="color:#e6db74">&#34;true&#34;</span> <span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;meta-data</span> <span style="color:#a6e22e">android:name=</span><span style="color:#e6db74">&#34;DOMAIN_PACKAGE_NAME&#34;</span> <span style="color:#a6e22e">android:value=</span><span style="color:#e6db74">&#34;com.ieseljust.pmdm&#34;</span> <span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;/application&gt;</span>
</code></pre></div><ol start="3">
<li><strong>Definint les entitats</strong></li>
</ol>
<p>El següent pas serà definir quines classes de la nostra aplicació necessiten persistència, i les estendrem de la classe <code>SugarRecord</code>, de manera que ja serà el propi <em>Sugar ORM</em> qui s&rsquo;encarregue de generar les taules per nosaltres.</p>
<p>Una cosa que cal tindre en compte és que necessitarem que es dispose d&rsquo;un constructor buït a la classe que volem que tinga persistència, per tant, no ens aprofita la definició tal qual la teniem de la classe <em>Lloc</em> com a <em>data class</em>, sinò que necessitarem generar-la per complet.</p>
<p>Per tant, la definició anterior de la classe <em>Lloc</em>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Lloc</span>(
        <span style="color:#66d9ef">var</span> nom: String,
        <span style="color:#66d9ef">var</span> descripcio: String,
        <span style="color:#66d9ef">var</span> telefon: String,
        <span style="color:#66d9ef">var</span> web: String,
        <span style="color:#66d9ef">var</span> img: String,
        <span style="color:#66d9ef">var</span> latitud: Double,
        <span style="color:#66d9ef">var</span> longitud: Double)
</code></pre></div><p>Passarà a ser una miqueta més llarga:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Lloc</span> : SugarRecord {
        <span style="color:#66d9ef">var</span> nom:String=<span style="color:#e6db74">&#34;&#34;</span>
        <span style="color:#66d9ef">var</span> descripcio:String=<span style="color:#e6db74">&#34;&#34;</span>
        <span style="color:#66d9ef">var</span> telefon : String=<span style="color:#e6db74">&#34;&#34;</span>
        <span style="color:#66d9ef">var</span> web: String=<span style="color:#e6db74">&#34;&#34;</span>
        <span style="color:#66d9ef">var</span> img: String=<span style="color:#e6db74">&#34;&#34;</span>
        <span style="color:#66d9ef">var</span> latitud: Double=<span style="color:#ae81ff">0.0</span>
        <span style="color:#66d9ef">var</span> longitud: Double=<span style="color:#ae81ff">0.0</span>

    <span style="color:#66d9ef">constructor</span>() {}

    <span style="color:#66d9ef">constructor</span>(nom:String,
                descripcio:String,
                telefon : String,
                web: String,
                img: String,
                latitud: Double,
                longitud: Double){
        <span style="color:#66d9ef">this</span>.nom=nom
        <span style="color:#66d9ef">this</span>.descripcio=descripcio
        <span style="color:#66d9ef">this</span>.telefon=telefon
        <span style="color:#66d9ef">this</span>.web=web
        <span style="color:#66d9ef">this</span>.img=img
        <span style="color:#66d9ef">this</span>.latitud=latitud
        <span style="color:#66d9ef">this</span>.longitud=longitud

    }

}

</code></pre></div><p>Fixeu-vos que la definició de la classe indica que es tracta d&rsquo;un SugarRecord: <code>class Lloc : SugarRecord</code>.</p>
<ol start="4">
<li><strong>Operacions CRUD</strong></li>
</ol>
<p>Les operacions CRUD (Create-Remove-Update-Delete) són bastant senzilles, com veurem.</p>
<p>Recordem que tota la informació la tenim en un objecte anomenat <em>Llocs</em>, que conté un ArrayList d&rsquo;objectes de tipus <em>Lloc</em>. Així doncs, el que farem en el constructor és carregar directament tots els registres de la base de dades dins aquest <em>ArrayList</em>. Això ho aconseguim amb el mètode estàtic <code>findAll</code> de  la classe <em>SugarRecord</em>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">object</span> <span style="color:#a6e22e">Llocs</span> {
    <span style="color:#66d9ef">var</span> llocs:ArrayList&lt;Lloc&gt;

    <span style="color:#66d9ef">init</span> {
        llocs = SugarRecord.listAll&lt;Lloc&gt;(Lloc<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>.java).toCollection(ArrayList())
    }
    <span style="color:#f92672">..</span>.
}
</code></pre></div><p>El nostre objecte <em>Llocs</em> disposa d&rsquo;altres mètodes per tal de realitzar les operacions d&rsquo;afegir, eliminar i modificar llocs. Anem a veure com resulta senzill fer aquestes operacions persistents en la base de dades.</p>
<p><strong>Afegint elements: save</strong></p>
<p>El nostre objecte <em>Llocs</em> disposa del mètode <code>add</code> per tal d&rsquo;afegir nous llocs a l&rsquo;ArrayList que els conté. Així doncs, si en aquest mètode el que feiem era afegir el nou lloc en l&rsquo;ArrayList <em>llocs</em>, ara a més, l&rsquo;haurem de guardar a la base de dades mitjançant el mètode <code>save</code> de la classe <code>SugarRecord</code>, o bé del propi objecte, de la següent manera:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">
<span style="color:#f92672">..</span>.
<span style="color:#66d9ef">var</span> llocs:ArrayList&lt;Lloc&gt;
<span style="color:#f92672">..</span>.

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">add</span>(lloc: Lloc){

    <span style="color:#f92672">..</span>. <span style="color:#75715e">// Comprovacions prèvies, etc.
</span><span style="color:#75715e"></span>
    llocs.add(lloc)

    <span style="color:#75715e">// Podem utilitzar el mètode save de SugarRecord
</span><span style="color:#75715e"></span>    SugarRecord.save(lloc)

    <span style="color:#75715e">// O directament guardar el lloc amb el mètode save
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// heretat de SugarRecord:
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// lloc.save()
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Amb això haurem guardat el registre <em>lloc</em> a la taula corresponent.</p>
<p><strong>Eliminant elements:Remove</strong></p>
<p>El nostre mètode <em>remove</em> de l&rsquo;objecte <em>Llocs</em> senzillament eliminava el lloc indicat de l'<em>ArrayList llocs</em>. Per tal d&rsquo;eliminar el registre de la base de dades, utilitzarem el mètode <code>remove</code> de la classe <em>SugarRecord</em>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">remove</span>(lloc: Lloc){
        llocs.remove(lloc)
        <span style="color:#75715e">// Forma 1
</span><span style="color:#75715e"></span>        SugarRecord.delete(lloc)
        <span style="color:#75715e">// Forma 2
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// lloc.delete()
</span><span style="color:#75715e"></span>
    }
</code></pre></div><p><strong>Modificacions</strong></p>
<p>Per tal de fer una modificació, no disposem d&rsquo;una ordre tipus <em>update</em>, sinò que haurem de buscar l&rsquo;element que volem modificar, fer les modificacions i guardar-lo amb <code>save</code>.</p>
<p>La forma més senzilla és fent ús de l&rsquo;identificador:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">Classe objecte = Classe.findById(Classe.<span style="color:#66d9ef">class</span>, identificador)

objecte.atribut_1=ValorActualitzat_1
<span style="color:#f92672">..</span>.
objecte.atribut_n=ValorActualitzat_n
objecte.save()
</code></pre></div><p>Aquesta seria la manera natural de realizar les modificacions. De tota manera, com que no guardem l&rsquo;identificador en l&rsquo;objecte lloc, haurem de buscar l&rsquo;element a modificar a partir dels seus atributs coneguts. Donat que el nom no es pot repetir, buscarem el lloc per nom i modificarem l&rsquo;element corresponent.</p>
<p>Al següent mètode <em>modifica</em> li proporcionem el mètode original i el nou objecte lloc amb les modificacions. Farem una recerca per la taula <em>Lloc</em>, mitjançant el mètode <em>Sugar.listAll</em> per llistar tots els elements de la taula, i comparar el nom amb el nom original de l&rsquo;objecte a modificar. Si coincideixen, modificarem l&rsquo;objecte i el guardarem a la BD.</p>
<p>Fixeu-vos en l&rsquo;ús de l&rsquo;etiqueta <em>buscaId@</em> per marcar per on eixir del bucle, i com en aquest cas, en lloc de <code>break</code> per eixir del bucle utilitzem <code>return</code>, ja que ens trobem dins d&rsquo;una funció lambda. A la <a href="https://kotlinlang.org/docs/reference/returns.html">documentació de Kotlin</a> teniu documentada aquesta funcionalitat del <em>return</em>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">modifica</span>(originalName: String, lloc: Lloc) {
       <span style="color:#75715e">// Recorrem tots els llocs
</span><span style="color:#75715e"></span>
        SugarRecord.listAll&lt;Lloc&gt;(Lloc<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>.java).toCollection(ArrayList()).forEach buscaId<span style="color:#960050;background-color:#1e0010">@</span>{
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">it</span>.nom<span style="color:#f92672">==</span>originalName){
                <span style="color:#66d9ef">it</span>.nom=lloc.nom
                <span style="color:#66d9ef">it</span>.descripcio=lloc.descripcio
                <span style="color:#66d9ef">it</span>.telefon=lloc.telefon
                <span style="color:#66d9ef">it</span>.web=lloc.web
                <span style="color:#66d9ef">it</span>.img=lloc.img
                <span style="color:#66d9ef">it</span>.latitud=lloc.latitud
                <span style="color:#66d9ef">it</span>.longitud=lloc.longitud
                <span style="color:#66d9ef">it</span>.save()
                <span style="color:#66d9ef">return</span><span style="color:#a6e22e">@buscaId</span>
            }
        }
        <span style="color:#75715e">// Refresquem llocs per refrescar la vista
</span><span style="color:#75715e"></span>        llocs=SugarRecord.listAll&lt;Lloc&gt;(Lloc<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>.java).toCollection(ArrayList())
    }
</code></pre></div><p><strong>Explorant la BD</strong></p>
<p>La base de dades SQLite de la nostra aplicació es troba al directori de dades d&rsquo;aquesta, a la qual podem accedir mitjançant l&rsquo;explorador de fitxers del dispositiu (<em>Device File Explorer</em>), buscant la ruta <code>/data/data/com.ieseljust.pmdm.myplaces20/databases/myplaces2.db</code>.</p>
<p>Una vagada localitzada, podem fer clic sobre ella amb el botó dret del ratolí i descarregar-la al nostre equip, fent clic a <em>Save As</em>:</p>
<p><img src="../img/device_explorer_db.png" alt="Descarregant la BD SQLite"></p>
<p>Per tal d&rsquo;obrir aquet fitxer amb extensió .db, podem utilitzar l&rsquo;aplicació <em>sqlitebrowser</em>, disponible en Ubuntu. Per a això, mirem si es troba instal·lada:</p>
<pre><code>$ apt-cache policy sqlitebrowser
sqlitebrowser:
  Instal·lat: (cap)
  Candidat:   3.11.2-1build2
  Taula de versió:
     3.11.2-1build2 500
        500 http://archive.ubuntu.com/ubuntu focal/universe amd64 Packages
</code></pre><p>I si no ens indica cap versió instal·lada, actualitzem la llista de paquets i la instal·lem al nostre equip:</p>
<pre><code>$ sudo apt update
...
$ sudo apt install sqlitebrowser
...
</code></pre><p>Amb aquesta aplicació, que trobarem al submenú de <em>Desenvolupament</em>, podem obrir le nostre fitxer .db, i explorar tant la seua estructura (<em>Database Structure</em>), com analitzar o modificar les dades que conté (<em>Browse Data</em>).</p>
<p><img src="../img_2_2/sqlitebrowser.png" alt="SQLite Browser"></p>
<blockquote>
<p><strong>Documentació sobre SQLite i Room</strong></p>
<ul>
<li>
<p><a href="https://developer.android.com/training/data-storage/sqlite?hl=es">https://developer.android.com/training/data-storage/sqlite?hl=es</a></p>
</li>
<li>
<p><a href="https://www.adictosaltrabajo.com/2019/03/04/persistencia-de-datos-en-android-con-room/">https://www.adictosaltrabajo.com/2019/03/04/persistencia-de-datos-en-android-con-room/</a></p>
</li>
<li>
<p><a href="https://cursokotlin.com/capitulo-17-persistencia-de-datos-con-room/">https://cursokotlin.com/capitulo-17-persistencia-de-datos-con-room/</a></p>
</li>
<li>
<p><a href="https://javautodidacta.es/base-de-datos-room-en-android/">https://javautodidacta.es/base-de-datos-room-en-android/</a></p>
</li>
</ul>
</blockquote>

        </article>
<aside class="table-of-contents">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-introducció">1. Introducció</a>
      <ul>
        <li><a href="#11-modificant-la-interfície-dedició-de-llocs">1.1. Modificant la interfície d&rsquo;edició de llocs</a></li>
        <li><a href="#12-modificació-del-model">1.2. Modificació del model</a></li>
      </ul>
    </li>
    <li><a href="#2-accedint-a-la-galeria-intents-a-activitats-amb-valor-de-retorn">2. Accedint a la galeria: Intents a activitats amb valor de retorn</a>
      <ul>
        <li><a href="#21-afegint-una-imatge-de-la-galeria">2.1. Afegint una imatge de la galeria</a></li>
        <li><a href="#22-obtenint-les-coordenades-gps">2.2. Obtenint les coordenades GPS</a></li>
        <li><a href="#23-intent-a-google-maps">2.3. Intent a Google Maps</a></li>
      </ul>
    </li>
    <li><a href="#3-persistència-de-dades">3. Persistència de dades</a>
      <ul>
        <li><a href="#31-sqlite">3.1. SQLite</a></li>
      </ul>
    </li>
  </ul>
</nav>

</aside>

<script>

    (function () {
        let entries = document.querySelectorAll(".table-of-contents li");

        for (entry of entries) {
            entry.addEventListener("click", function (e) {
                
                e.stopPropagation();
                for (sel of document.querySelectorAll(".selected"))
                    sel.classList.remove("selected");
                e.currentTarget.classList.add("selected");
                
                for (item of e.currentTarget.children)
                    if (item == "[object HTMLUListElement]")
                        if (item.style.display == "none")
                            item.style.display = "block";
                        else item.style.display = "none"

            });
        }

    
    let entriesh2 = document.querySelectorAll(".table-of-contents li > ul");

        for (entry of entriesh2) {
            entry.style.display = "none";
        }


    })();

</script>        

</div> 

<div class="footer-container">
    
</div>
</body>

</html>