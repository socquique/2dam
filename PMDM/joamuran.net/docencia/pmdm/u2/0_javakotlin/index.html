<!DOCTYPE html>
<html lang="ca">



<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+JP">
    <link rel="stylesheet" href="../../../css/main.css">

    
    <title>0. Repàs de Java i introducció a Kotlin</title>
</head>

<body>
    
    <div class="header-container">
        
        
        
        <nav>
            <ul>
                
                <li class="mainNavigation">
                    <a href="https://socquique.github.io/2dam/PSP" title="PSP">
                        PSP
                    </a>
                </li>
                
                <li class="mainNavigation">
                    <a href="https://socquique.github.io/2dam/PMDM" title="PMDM">
                        PMDM
                    </a>
                </li>
                
            </ul>
        </nav>
        
    </div>

    
    <div class="main-container">
<nav>
    <h3>
        <a href="../index.html">
        Unitat 2. Programació d&#39;Android amb Kotlin</a>
    </h3>
    
        
        
        <div class="unitat">
            <a href="index.html">0. Repàs de Java i introducció a Kotlin</a>
        </div>
        
        <div class="unitat">
            <a href="../1_androidstudio/index.html">1. Android Studio i Kotlin. Primers pasos.</a>
        </div>
        
        <div class="unitat">
            <a href="../2_arquitecturaapps/index.html">2. Desenvolupament d&#39;apps en Android</a>
        </div>
        
        <div class="unitat">
            <a href="../3_elemensui/index.html">3. Elements de la interfície</a>
        </div>
        
        <div class="unitat">
            <a href="../4_recyclerview/index.html">4. El component RecyclerView</a>
        </div>
        
        <div class="unitat">
            <a href="../5_eventsrecyclerview/index.html">5. Gestió d&#39;events als RecyclerView</a>
        </div>
        
        <div class="unitat">
            <a href="../6_menus/index.html">6. Menús en Android I</a>
        </div>
        
        <div class="unitat">
            <a href="../7_myplaces2/index.html">7. Ampliació de l&#39;aplicació MyPlaces. Navigation Drawer, Fragments, MVVM, View Binding.</a>
        </div>
        
        <div class="unitat">
            <a href="../8_myplaces2_2/index.html">8. Ampliació de l&#39;aplicació MyPlaces. Intents amb retorn, Galeria, Emmagatzemament i Maps.</a>
        </div>
        
    
</nav>
    <article>
        <header> 
            <h1>0. Repàs de Java i introducció a Kotlin</h1>
        </header>
        <h2 id="1-introducció-a-kotlin">1. Introducció a Kotlin</h2>
<p>Kotlin és un llenguatge de programació multiplataforma, en el sentit més ample del terme, creat per JetBrains (els creadors dels IDEs IntelliJ Idea i GoLand).</p>
<p>El seu compilador suporta le generació de codi per a diverses plataformes, entre les que es troba la màquina virtual de Java (JVM) o fins i tot, javascript. El fet de compilar directament sobre JVM, fa que siga totalment compatible amb Java. De fet, va ser adoptat recentment per Google com a llenguatge oficial per a la plataforma Android<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>En general, Kotlin presenta els següents avantatges respecte a Java:</p>
<ul>
<li>Es tracta d&rsquo;un llenguatge més concís, pel que s&rsquo;estalvia codi (evita tant com puga codi innecessari i repetitiu)</li>
<li>És un llenguatge segur, ja que evita errors a l&rsquo;hora de programar (com el <code>NullPointerException</code>),</li>
<li>És totalment interoperable amb Java, pel que podem utilitzar llibreries java, Android, etc. fins i tot utilitzar ambdos llenguatges en un mateix projecte.</li>
</ul>
<p>En aquest document anaem a fer un repàs als conceptes de Java vistos en primer, i una introducció a partir d&rsquo;estos al llenguatge Kotlin.</p>
<h3 id="11-installació-de-kotlin">1.1. Instal·lació de Kotlin</h3>
<p>Per tal d&rsquo;instal·lar el llenguatge Kotlin al nostre sistema, la forma més senzilla és fent ús l&rsquo;eina <em>Ubuntu Make</em> (ordre <code>umake</code>), de la següent forma:</p>
<pre><code>$ umake kotlin kotlin-lang
</code></pre><p>Açò ens demanarà la contrassenya d&rsquo;administrador i el path on volem instal·lar-lo. Per omissió, s&rsquo;instal·la al nostre directori personal <code>/home/usuari/.local/share/umake/kotlin/kotlin-lang</code>.</p>
<p>Una vegada instal·lat <strong>cal que eixim de la sessió d&rsquo;usuari per poder-lo utilitzar</strong>.</p>
<p>Per utilitzar kotlin, podrem fer-ho de dues formes; la primera amb la shell interactiva, llançant des de la terminal:</p>
<pre><code>$ kotlin
Welcome to Kotlin version 1.4.0 (JRE 11.0.8+10-post-Ubuntu-0ubuntu120.04)
Type :help for help, :quit for quit
&gt;&gt;&gt; 
</code></pre><p>Fixeu-vos que us indica la versió de Kotlin i també la del JRE, ja que és l&rsquo;entorn en què s&rsquo;executa. En aquesta shell podrem realitzar declaracions i llançar ordres de forma interactiva.</p>
<p>I per altra banda, fent ús del compilador <code>kotlinc</code>, per compilar fitxers, i executar-los amb <code>kotlin</code>. Ho veurem un poc més avant.</p>
<h3 id="12-extensions-per-a-vscode">1.2. Extensions per a VSCode</h3>
<p>Per altra banda, anem a instal·lar les extensions del llenguatge Kotlin per a Visual Studio. Per a això anem a la part d&rsquo;extensions de la barra esquerra, i busquem l&rsquo;extensió <em>Kotlin on VSCode</em>, que és un pack d&rsquo;extensions amb el suport per al llenguatge:</p>
<p><img src="../img/kotlinvscode.png" alt="Kotlin on VSCode"></p>
<p>Recordeu, si no ho teniu instal·lat prèviament que també ens serà d&rsquo;utilitat el pack d&rsquo;extensions <em>Java Extension Pack</em>, per treballar també amb Java des de VSCode. A més, una vegada instal·lades les extensions de Java, cal que ajustem la variable <code>java.home</code>. Per a això necessitarem saber on tenim instal·lada la JVM. Ho podem comprovar amb la variable d&rsquo;entorn <code>$JAVA_HOME</code>:</p>
<pre><code>$ echo $JAVA_HOME
/usr/lib/jvm/java-11-openjdk-amd64/
</code></pre><p>Anem a <em>File</em> &gt; <em>Preferences</em> &gt; <em>Settings</em> (o premem <code>Ctrl+,</code>), per accedir a la pestanya de preferències, i busquem <code>java.home</code> al quadre de cerca.</p>
<p><img src="../img/java_home.png" alt="Establint java.home"></p>
<p>Fem clic en <em>Edit in settings.json</em>, i establim la variable amb el valor que hem obtingut del <code>$JAVA_HOME</code> del sistema. Al nostre cas:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">   <span style="color:#e6db74">&#34;java.home&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;/usr/lib/jvm/java-11-openjdk-amd64/&#34;</span>
</code></pre></div><p>Una vegada editat, guardem el fitxer i ja ho tindrem tot configurat.</p>
<h2 id="2-estructura-i-execució-dun-programa-hello-world">2. Estructura i execució d&rsquo;un programa: Hello World</h2>
<p>Recordem l&rsquo;estructura general d&rsquo;un programa en Java:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">hello</span> <span style="color:#f92672">{</span>
   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello, World&#34;</span><span style="color:#f92672">);</span>
   <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Recordeu que el nom de la classe ha de ser el mateix que el del fitxer, sense l&rsquo;extensió java (Fitxer hello.java).</p>
<p>Aquest codi, en Kotlin l&rsquo;expressaríem així (nomenarem al fitxer <code>helloworld.kt</code>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>() {
    println(<span style="color:#e6db74">&#34;Hello World&#34;</span>)
}
</code></pre></div><p>Com veiem, les principals diferències són:</p>
<ul>
<li>La funció principal (main) es declara com una funció de primer nivell, sense necessitat que estiga dins una classe. Per tant, Kotlin no requereix que tot siguen classes, a diferència de Java, i ens permet treballar com en C o C++, amb funcions.</li>
<li>Aquesta funció <code>main</code> pot rebre arguments, però no és necesasri indicar-ho.</li>
<li>Tampoc cal indicar la visibilitat de la funció (<code>public</code>), ni si és estàtica (<code>static</code>).</li>
<li>La funció <code>println</code> la tenim disponible directament, sense passar per <code>System.out</code>.</li>
<li>Els <code>;</code> de final de línia són opcionals, i solen evitar-se per convenció</li>
</ul>
<h3 id="21-compilació-i-execució">2.1. Compilació i execució</h3>
<p>Amb java, des de la línia d&rsquo;ordres, compilem amb:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ javac hello.java
</code></pre></div><p>Aquesta ordre ens crea el fitxer en bytecode hello.class, que executem amb:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ java hello
</code></pre></div><p>De la mateixa manera que amb java, disposem d&rsquo;una ordre per compilar i altra per executar.</p>
<p>Per compilar el programa, utilitzem l&rsquo;ordre <code>kotlinc</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kotlinc helloworld.kt
</code></pre></div><p>Amb açò es genera un fitxer bytecode <code>HelloworldKt.class</code>. Fixeu-vos que afig la primera lletra en majúscula, i completa el nom de la classe amb Kt.</p>
<p>Per executar aquest bytecode:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kotlin HelloworldKt
</code></pre></div><p>Per comprovar que es tracta de bytecode totalment compatible amb Java, podem llançar-lo amb:</p>
<pre><code>$ java HelloworldKt
</code></pre><h3 id="22-ús-darguments">2.2. Ús d&rsquo;arguments</h3>
<p>Recordem que els arguments amb els què s&rsquo;invoca el programa esw recullen en un vector d&rsquo;strings:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/*
</span><span style="color:#75715e">Fitxer hello.java
</span><span style="color:#75715e">*/</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">hello</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// Mètode principal
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
       <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>args<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">!=</span>0<span style="color:#f92672">)</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello &#34;</span><span style="color:#f92672">+</span>args<span style="color:#f92672">[</span>0<span style="color:#f92672">]);</span>
       <span style="color:#66d9ef">else</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello World&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
 <span style="color:#f92672">}</span>
</code></pre></div><p>En Kotlin, aquest exemple seria:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/*
</span><span style="color:#75715e">Fitxer hello.kt
</span><span style="color:#75715e">*/</span>

<span style="color:#75715e">// funció principal, de primer nivell.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
    <span style="color:#66d9ef">if</span> (args.size&gt;<span style="color:#ae81ff">1</span>)
        println(<span style="color:#e6db74">&#34;Hello &#34;</span>+args[<span style="color:#ae81ff">0</span>])
    <span style="color:#66d9ef">else</span>
        println(<span style="color:#e6db74">&#34;Hello World&#34;</span>)
}
</code></pre></div><p>Com podem veure, la forma de rebre arguments és lleugerament diferent. Als paràmetres per a les funcions en Kotlin expressem primer el nom i després el tipus. En aquest cas, per indicar que es tracta d&rsquo;un vector d&rsquo;Strings ho fem amb <code>Array&lt;String&gt;</code>.</p>
<p>Per altra banda, en lloc d&rsquo;utilitzar la propietat <code>length</code> utilitzem <code>size</code>, i accedim de la mateixa manera al vector. Per altra banda, el primer <code>println</code> podria haver-se expressat també de la següent manera:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">println(<span style="color:#e6db74">&#34;Hello </span><span style="color:#e6db74">${args[0]}</span><span style="color:#e6db74">&#34;</span>)
</code></pre></div><p>Que recorda una sintaxi més semblant a <em>Bash</em>, i fa ús del que es coneixen com <em>expressions de plantilla</em>, que veurem més avant.</p>
<p>Per taltra banda, a l&rsquo;exemple, podeu veure un parell de comentaris. Aquests s&rsquo;expressen de la mateixa manera, tant en Java com en Kotlin:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// Comentari d&#39;una línia
</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/* 
</span><span style="color:#75715e">Comentaris de més d&#39;una línia 
</span><span style="color:#75715e">*/</span>
</code></pre></div><h3 id="23-gradle-java-i-kotlin">2.3. Gradle, Java i Kotlin</h3>
<p>El sistema d&rsquo;automatització de construcció de projectes <em>Gradle</em> suporta, a més de Java, projectes en Kotlin, així com projectes on es combinen amdós llenguatges.</p>
<p>Per fer un exemple il·lustratiu, anem a fer un projecte Gradle, de tipus aplicció Kotlin, però que també utilitze codi java. Utilitzarem la versió 6.6.1 de Gradle, inclosa a JustiX, i disponible a través dels repositoris del centre.</p>
<p>Per crear el projecte de manera senzilla, farem ús de l&rsquo;ordre <code>Gradle init</code>, en un directori per al projecte anomenat <code>helloGradle</code>, que haurem de crear:</p>
<pre><code>$ mkdir helloGradle
$ cd helloGradle
helloGradle$ gradle init

Welcome to Gradle 6.6.1!

Here are the highlights of this release:
 - Experimental build configuration caching
 - Built-in conventions for handling credentials
 - Java compilation supports --release flag

For more details see https://docs.gradle.org/6.6.1/release-notes.html

Starting a Gradle Daemon (subsequent builds will be faster)

Select type of project to generate:
  1: basic
  2: application
  3: library
  4: Gradle plugin
Enter selection (default: basic) [1..4] 2
</code></pre><p>Com veiem, ens indica la versió de Gradle, i en primer lloc ens demana el tipus de projecte que volem. Indicarem que volem generar una aplicacio <code>2: applicaction</code>.</p>
<p>Tot seguit ens demanarà el llenguatge d&rsquo;implementació. Triarem <code>4: Kotlin</code>.</p>
<pre><code>Select implementation language:
  1: C++
  2: Groovy
  3: Java
  4: Kotlin
  5: Swift
Enter selection (default: Java) [1..5] 4
</code></pre><p>I per a l&rsquo;script de configuració del projecte, tot i que podem utilitzar una notació Kotlin, farem ús de <em>Groovy</em>, amb el què ja hem treballat habitualment.</p>
<pre><code>Select build script DSL:
  1: Groovy
  2: Kotlin
Enter selection (default: Kotlin) [1..2] 1
</code></pre><p>Ara ens queda per indicar el nom del projecte, on triarem el que ens suggereix per defecte (helloGradle), i com a paquet font, indicarem <code>com.ieschabas.dam</code>:</p>
<pre><code>Project name (default: helloGradle): 
Source package (default: helloGradle): com.ieschabas.dam 

BUILD SUCCESSFUL in 1m 20s
2 actionable tasks: 2 executed
</code></pre><p>Recordeu que <code>gradle init</code> també admet paràmetres per configurar el projecte, de manera que ens podem estalviar l&rsquo;assistent anterior amb:</p>
<pre><code>$ gradle init   --type kotlin-application \ 
                --dsl groovy \
                --project-name helloGradle \
                --package com.ieschabas.dam
</code></pre><p>Amb qualsevol de les dues formes, haurem generat la següent estructura de directoris:</p>
<pre><code>helloGradle/
|-- build.gradle
|-- gradle
|   `-- wrapper
|       |-- gradle-wrapper.jar
|       `-- gradle-wrapper.properties
|-- gradlew
|-- gradlew.bat
|-- settings.gradle
`-- src
    |-- main
    |   |-- kotlin
    |   |   `-- com
    |   |       `-- ieschabas
    |   |           `-- dam
    |   |               `-- App.kt
    |   `-- resources
    `-- test
        |-- kotlin
        |   `-- com
        |       `-- ieschabas
        |           `-- dam
        |               `-- AppTest.kt
        `-- resources

</code></pre><p>Com a fitxers i carpetes interessants tenim el fitxer <code>build.gradle</code>, amb la configuració del projecte, i la carpeta <code>src</code>. Fixeu-vos que ara, dins la carpeta <code>src/main</code>, en lloc del directori <code>java</code> tenim el directori <code>kotlin</code>, amb l&rsquo;estructura de directoris determinada pel nom del paquet que li hem dit (<code>com/ieschabas/dam</code>).</p>
<p>Ens queda per veure el contingut del fitxer de configuració <code>build.gradle</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy"><span style="color:#75715e">/*
</span><span style="color:#75715e"> * This file was generated by the Gradle &#39;init&#39; task.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * This generated file contains a sample Kotlin application project to get you started.
</span><span style="color:#75715e"> */</span>

plugins <span style="color:#f92672">{</span>
    <span style="color:#75715e">// Apply the Kotlin JVM plugin to add support for Kotlin.
</span><span style="color:#75715e"></span>    id <span style="color:#e6db74">&#39;org.jetbrains.kotlin.jvm&#39;</span> version <span style="color:#e6db74">&#39;1.3.72&#39;</span>

    <span style="color:#75715e">// Apply the application plugin to add support for building a CLI application.
</span><span style="color:#75715e"></span>    id <span style="color:#e6db74">&#39;application&#39;</span>
<span style="color:#f92672">}</span>

repositories <span style="color:#f92672">{</span>
    <span style="color:#75715e">// Use jcenter for resolving dependencies.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// You can declare any Maven/Ivy/file repository here.
</span><span style="color:#75715e"></span>    jcenter<span style="color:#f92672">()</span>
<span style="color:#f92672">}</span>

dependencies <span style="color:#f92672">{</span>
    <span style="color:#75715e">// Align versions of all Kotlin components
</span><span style="color:#75715e"></span>    implementation <span style="color:#a6e22e">platform</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;org.jetbrains.kotlin:kotlin-bom&#39;</span><span style="color:#f92672">)</span>

    <span style="color:#75715e">// Use the Kotlin JDK 8 standard library.
</span><span style="color:#75715e"></span>    implementation <span style="color:#e6db74">&#39;org.jetbrains.kotlin:kotlin-stdlib-jdk8&#39;</span>

    <span style="color:#75715e">// Use the Kotlin test library.
</span><span style="color:#75715e"></span>    testImplementation <span style="color:#e6db74">&#39;org.jetbrains.kotlin:kotlin-test&#39;</span>

    <span style="color:#75715e">// Use the Kotlin JUnit integration.
</span><span style="color:#75715e"></span>    testImplementation <span style="color:#e6db74">&#39;org.jetbrains.kotlin:kotlin-test-junit&#39;</span>
<span style="color:#f92672">}</span>

application <span style="color:#f92672">{</span>
    <span style="color:#75715e">// Define the main class for the application.
</span><span style="color:#75715e"></span>    mainClassName <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;com.ieschabas.dam.AppKt&#39;</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>Revisem les seccions de què consta aquest fitxer:</p>
<ul>
<li><em><strong>plugins</strong></em>, on s&rsquo;inclouen els plugins de suport per a Kotlin a la JVM i per generar una aplicació de tipus CLI,</li>
<li><strong>repositories</strong>, on s&rsquo;afigen els repositoris <code>jcenter()</code> per defecte. Recordeu que aci podem afegir també els de <code>mavenCentral()</code>, igual que als projectes amb Java,</li>
<li><strong>depencencies</strong>, on s&rsquo;inclouen algunes dependències necessàries per a Kotlin i els seus tests,</li>
<li><strong>application</strong>, on s&rsquo;indica el nom, completament qualificat (amb el prefix del paquet), de <strong>la classe que llançarà l&rsquo;aplicació: <code>AppKt</code></strong>.</li>
</ul>
<p>Veiem ara el contingut del fitxer font <code>App.kt</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/*
</span><span style="color:#75715e"> * This Kotlin source file was generated by the Gradle &#39;init&#39; task.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">package</span> com.ieschabas.dam

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">App</span> {
    <span style="color:#66d9ef">val</span> greeting: String
        <span style="color:#66d9ef">get</span>() {
            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Hello world.&#34;</span>
        }
}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
    println(App().greeting)
}
</code></pre></div><p>Com veiem, presenta una sintaxi molt semblant a Java, però amb algunes peculiaritats a destacar:</p>
<ul>
<li>S&rsquo;ha definit la classe <code>App</code>, amb un atribut <code>greeting</code>, de tipus <em>String</em>, i que és definit com un <em>atribut immutable</em>. Un <em>atribut immutable</em> seria equiparable a una constant en Java, i es defineix amb <code>val</code>, mentre que els atributs mutables es definiran amb <code>var</code>. A més, hi ha un mètode <code>get()</code>, definit a continuació d&rsquo;aquest atribut, i que és el mètode accessor, per a lectura d&rsquo;aquest atribut. Com que es tracta d&rsquo;un atribut només de lectura, només té el mètode <code>get</code> i no <code>set</code>.</li>
<li>Es defineix la funció <code>main</code>, com a funció de primer nivell, pel que no està definida dins de cap classe. Aquesta funció el que fa és escriure el valor de l&rsquo;atribut <code>greeting</code> d&rsquo;un objecte de la classe <code>App</code>. Veiem alguns detalls d&rsquo;esta línia que ens poden resultar curiosos:
<ul>
<li>No hem utilitzat l&rsquo;operador <code>new</code> per declarar un objecte de tipus App, sinò que hem utilitzat el nom de la classe com si fos una funció. En Kotlin, l&rsquo;operador <code>new</code> no existeix.</li>
<li>Accedim al valor de <code>greeting</code> com si estiguérem accedint directament a l&rsquo;atribut. Tot i que no ho indiquem explícitament, el que està fent Kotlin realment és invocar al mètode <code>get</code> associat a aquest atribut.</li>
</ul>
</li>
<li>Per altra banda, recordem que la classe principal que hem indicat al fitxer <code>build.gradle</code> és <code>com.ieschabas.dam.AppKt</code>. Aquest fitxer <code>com/ieschabas/dam/AppKt.class</code> serà el resultat de la compilació d&rsquo;aquest fitxer <code>App.kt</code>. Però&hellip; si la funció main no està dins de cap classe, per què s&rsquo;indica com a classe principal? Aprofundirem més avant en açò, però de moment, avancem que Kotlin, en fer la compilació per a la JVM, generarà automàticament la classe per nosaltres, per tal que el fitxer <em>bytecode</em>  siga compatible totalment amb la JVM.</li>
</ul>
<p>Ara només ens quedaria veure el resultat de la compilació i execució. Ens situem en l&rsquo;arrel del projecte, i llancem:</p>
<pre><code>$ gradle build
</code></pre><p>La primera vegada que el llancem, veurem que tarda una miqueta a descarregar totes les llibreríes necessàries.</p>
<p>Si donem una ullada a l&rsquo;arbre del projecte (<code>tree</code>) veurem que genera moltes més coses que quan treballàvem amb Java, ja que necessita tot l&rsquo;entorn per treballar amb Kotlin des de Gradle. Anem a centrar-nos en part de la carpeta <code>build</code>:</p>
<pre><code>.
|-- build
|   |-- classes
|   |   `-- kotlin
|   |       |-- main
|   |       |   |-- com
|   |       |   |   `-- ieschabas
|   |       |   |       `-- dam
|   |       |   |           |-- App.class
|   |       |   |           `-- AppKt.class
...
</code></pre><p>Aci veiem que s&rsquo;han generat dues classes: la classe <code>App</code>, que és exactament la classe que hem generat creat al fitxer <code>App.kt</code>, i la classe <code>AppKt.class</code>, que és la que conté el mètode <code>main</code> i si es fixeu, la que es llança des del <code>build.gradle</code> (<code>com.ieschabas.dam.AppKt</code>). Com hem comentat, és una classe que genera Kotlin automàticament, amb el nom del fitxer sense extensió <em>App</em> més la cadena <em>Kt</em>.</p>
<p>Ara llancem l&rsquo;aplicació i veurem que ens mostra el misstge esperat:</p>
<pre><code>$ gradle run

&gt; Task :run
Hello world.
</code></pre><h4 id="afegint-codi-java">Afegint codi Java</h4>
<p>Anem a veure ara com afegiríem codi Java a la nostra aplicació. Per a això, anem a eliminar la classe <em>App</em> del fitxer <em>App.kt</em>, i la definirem en un fitxer Java.</p>
<p>En primer lloc, crearíem el directori <code>java</code> dins la carpeta <code>src/main</code>, amb l&rsquo;estructura de directoris del paquet:</p>
<pre><code>$ cd src/main
$ mkdir -p src/main/java/com/ieschabas/dam
</code></pre><p>I creem el fitxer <code>src/main/java/com/ieschabas/dam/App.java</code> amb:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> com.ieschabas.dam<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">App</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">public</span> String greeting <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hola Kotlin, des de Java&#34;</span><span style="color:#f92672">;</span>

  <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getGreeting</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">greeting</span><span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>I modifiquem el fitxer <code>App.kt</code> amb:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">package</span> com.ieschabas.dam

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
    println(App().getGreeting());
}
</code></pre></div><p>Com que es tracta del mateix <code>package</code>, no hem d&rsquo;importar la classe <code>App</code>.</p>
<p>L&rsquo;estructura de fonts quedaria:</p>
<pre><code>src/
|-- main
|   |-- java
|   |   `-- com
|   |       `-- ieschabas
|   |           `-- dam
|   |               `-- App.java
|   |-- kotlin
|   |   `-- com
|   |       `-- ieschabas
|   |           `-- dam
|   |               `-- App.kt

</code></pre><p>Com veiem, dupliquem l&rsquo;estructura de directoris per a Java i per a Kotlin, duplicitat que també es vorà en les classes que generem en construir el paquet:</p>
<pre><code>.
|-- build
|   |-- classes
|   |   |-- java
|   |   |   `-- main
|   |   |       `-- com
|   |   |           `-- ieschabas
|   |   |               `-- dam
|   |   |                   `-- App.class
|   |   `-- kotlin
|   |       |-- main
|   |       |   |-- com
|   |       |   |   `-- ieschabas
|   |       |   |       `-- dam
|   |       |   |           `-- AppKt.class
...
</code></pre><p>I l&rsquo;execució seria l&rsquo;esperada:</p>
<pre><code>$ gradle run

&gt; Task :run
Hola Kotlin, des de Java
</code></pre><p>A partir del següent apartat, anem a començar a repassar els diferents elements del llenguatge de Java i Kotlin.</p>
<h2 id="3-variables-i-tipus-de-dades">3. Variables i tipus de dades</h2>
<h3 id="31-variables-i-tipus-bàsics-en-java">3.1. Variables i tipus bàsics en Java</h3>
<p>Els tipus de dades <em>primitius</em> o bàsics en Java són els següents:</p>
<ul>
<li><strong>Lògic</strong>: <code>Boolean</code></li>
<li><strong>Caràcter</strong>: <code>char</code></li>
<li><strong>Enter</strong>: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code></li>
<li><strong>Reals</strong>: <code>float</code>, <code>doube</code></li>
</ul>
<p>Com sabem, aquests tipus tenen una classe de cobertura (<em>wrapper</em>), que serveix per tractar les dades primitives com objectes (<code>Integer</code>, <code>Float</code>&hellip;)</p>
<p>Per tal de declarar una variable en Java, féiem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">TipusBasic NomVariable<span style="color:#f92672">;</span>
</code></pre></div><p>En aquest cas, la variable estaría declarada, però no tindría cap contingut. Si accedim a aquesta variable sense assignar-li un valor obtindriem un error`.</p>
<p>Si volem assignar-li valor directament, podem fer:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">TipusBasic NomVariable<span style="color:#f92672">=</span>valorVariable<span style="color:#f92672">;</span>
</code></pre></div><p>Les variables es poden modificar al codi Java. Si volem que una variable siga immutable, és a dir, <strong>per tal de definir una constant</strong> farem ís de la paraula <code>final</code> al davant:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">float</span> PI<span style="color:#f92672">=</span>3<span style="color:#f92672">.</span><span style="color:#a6e22e">14f</span><span style="color:#f92672">;</span>
</code></pre></div><h3 id="32-variables-i-tipus-bàsics-en-kotlin">3.2. Variables i tipus bàsics en Kotlin</h3>
<p>En Kotlin els tipus de dades són classes, de manera que podem accedir a les seues <em>propietats i funciuns membre</em> -Recordeu que amb Java per fer açò utilitzem <em>wrappers</em>- . Alguns d&rsquo;aquests tipus, com els números, caràcters o valors lògics poden representar-se de forma especial internament, com a valors primitius en temps d&rsquo;execució, però tot això de manera transparen a l&rsquo;usuari.</p>
<p>Per definir valors en Kotlin fem ús de les paraules reservades <code>var</code>o <code>val</code>:</p>
<ul>
<li>Utilitzarem <code>var</code> per tal de definir <strong>variables mutables</strong></li>
<li>Utilitzarem <code>val</code> per tal de definir <strong>variables immutables</strong>, o el que en Java sería <strong>valors constants</strong>.</li>
</ul>
<p>En general, es recomana utilitzar valors constants sempre que sapiguem que no van a haver de ser modificats, per disposar de major seguretat i rendiment quan treballem en diversos fils d&rsquo;execució.</p>
<p>Les següents assignacions serien correctes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> pi = <span style="color:#ae81ff">3.14</span>   <span style="color:#75715e">// Constant
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">val</span> modul       <span style="color:#75715e">// Constant
</span><span style="color:#75715e"></span>modul = <span style="color:#e6db74">&#34;PMDM&#34;</span>  <span style="color:#75715e">// Encara que siga altra línia, és una única assignació
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">1</span>       <span style="color:#75715e">// Valor variable
</span><span style="color:#75715e"></span>x=x+<span style="color:#ae81ff">1</span>
</code></pre></div><p>Si ens fixem, veurem que <strong>no hem definit el tipus de les variables</strong>. Kotlin és capaç d&rsquo;inferir el tipus de les variables a partir dels valors amb les què les inicialitzem, pel que no cal indicar-los explícitament. Només serà necessari indicar el tipus d&rsquo;una variable si no li donem valor en la declaració. Per tal d&rsquo;indicar el tipus farem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">var</span> nomVariable: Tipus
</code></pre></div><p>O bé podem indicar el tipus i donar també valor:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> nomVariable: Tipus = valor
</code></pre></div><p>Com hem dit, en Kotlin tots els tipus de dades són classes. Totes estes classes descendeixen de la superclasse genèrica <code>Any</code>, que podría equiparar-se a la classe <code>Object</code> de Java o C#.</p>
<h4 id="tipus-numèrics">Tipus numèrics</h4>
<p>En Kotlin tenim els següents tipus numèrics:</p>
<table>
<thead>
<tr>
<th>Tipus</th>
<th>Exemple</th>
<th>Longitud</th>
<th>Conversió al tipus</th>
</tr>
</thead>
<tbody>
<tr>
<td>Byte</td>
<td><code>val byte: Byte = 8</code></td>
<td>8 bits</td>
<td><code>toByte(): Byte</code></td>
</tr>
<tr>
<td>Short</td>
<td><code>val short: Short = 16</code></td>
<td>16 bits</td>
<td><code>toShort(): Short</code></td>
</tr>
<tr>
<td>Int</td>
<td><code>val int: Int = 32</code>  \newline <code>val hexadecimal: Int = 0x16</code> \newline <code>val binary: Int = 0b101</code></td>
<td>32 bits</td>
<td><code>toInt(): Int</code></td>
</tr>
<tr>
<td>! Long</td>
<td><code>val long: Long = 64L</code></td>
<td>64 bits</td>
<td><code>toLong(): Long</code></td>
</tr>
<tr>
<td>Foat</td>
<td><code>val float: Float = 32.0F</code></td>
<td>32 bits</td>
<td><code>toFloat(): Float</code></td>
</tr>
<tr>
<td>Double</td>
<td><code>val double: Double = 64.0</code></td>
<td>64 bits</td>
<td><code>toDouble(): Double</code></td>
</tr>
</tbody>
</table>
<p>La inferència dels tipus quan no els especifiquem, es fa en base als valors que li donem, de manera que podem especificar de forma indirecta el tipus, per exemple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> myVar=<span style="color:#ae81ff">1</span> <span style="color:#75715e">//Inferiria el tipus de myVar com a Int
</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> myVar=<span style="color:#ae81ff">1L</span> <span style="color:#75715e">//Inferiria el tipus de myVar com a Long
</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> myVar=<span style="color:#ae81ff">1.0</span> <span style="color:#75715e">//Inferiria el tipus de myVar com a Double
</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> myVar=<span style="color:#ae81ff">1.0F</span> <span style="color:#75715e">//Inferiria el tipus de myVar com a Float
</span></code></pre></div><p>Per altra banda, podem afegir guions baixos (<code>_</code>) quan escrivim números per tal que es puguen llegir millor, per exemple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> milio = <span style="color:#ae81ff">1</span>_000_000
</code></pre></div><h4 id="caràcters">Caràcters</h4>
<p>El tipus caràcter a Kotlin es representa amb <code>char</code>, i a diferència de Java, no es representa com un número.</p>
<p>Per definir un tipus caràcter fem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">var</span> char:caracter = <span style="color:#e6db74">&#39;a&#39;</span>
</code></pre></div><p>I per er la conversió a caràcter, utilitzem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">toChar(): Char
</code></pre></div><p>Per indicar caràcters epecials, farem ús de seqüències d&rsquo;escapament, mitjançant la barra invertida: <code>'\t'</code>, <code>'\b'</code>, <code>'\n'</code>, <code>'\r'</code>, <code>'\''</code>, <code>'\&quot;'</code>, <code>'\\'</code>, <code>'\$'</code>.</p>
<h3 id="33-cadenes-de-caràcters">3.3. Cadenes de caràcters</h3>
<p>A Java, les cadenes de caràcters es representen amb la classe <code>java.lang.String</code>.</p>
<p>Per declarar una cadena de caràcters, podem indicar-no directament o creant un instància de la classe <em>String</em>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String cadena<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;contingut&#34;</span><span style="color:#f92672">;</span>
String cadena<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;contingut&#34;</span><span style="color:#f92672">);</span>
</code></pre></div><p>En Kotlin la representació de cadenes de caràcters és molt semblant a Java. També s&rsquo;utilitzen les cometes dobles, i podem escapar caràcters amb la barra invertida <code>\</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> cadena=<span style="color:#e6db74">&#34;contingut&#34;</span>
<span style="color:#66d9ef">val</span> cadena:String=<span style="color:#e6db74">&#34;contingut&#34;</span>
</code></pre></div><p>Alguns dels mètodes interessants per a tractar amb cadenes de caràcters són, en Java i Kotlin:</p>
<table>
<thead>
<tr>
<th>Mètode de String en Java</th>
<th>Funció/Propietat membre en Kotlin</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cadena.concat(cadena2)</code></td>
<td><code>cadena1.plus(cadena2)</code></td>
</tr>
<tr>
<td><code>cadena.length()</code></td>
<td><code>cadena.length</code></td>
</tr>
<tr>
<td><code>cadena.charAt(pos)</code></td>
<td><code>cadena[pos]</code></td>
</tr>
<tr>
<td><code>cadena.substring(pos_ini[, pos_fy])</code></td>
<td><code>cadena.substring(pos_ini[, pos_fy])</code></td>
</tr>
<tr>
<td><code>cadena.equals(cadena2)</code></td>
<td><code>cadena.equals(cadena2)</code></td>
</tr>
<tr>
<td><code>cadena.startsWith(cadena2)</code></td>
<td><code>cadena.startsWith(cadena2)</code></td>
</tr>
</tbody>
</table>
<p>A més, per a la concatenació (<em>concat/plus</em>) i per a la comparació (<em>equals</em>), disposem dels operadors sobrecarregats <code>+</code> i <code>==</code> respectivament, tant en Java com en Kotlin. També podrem concatenar valors d&rsquo;altres tipus, sempre que algun element siga una cadena (per exemple: <code>val cadena=&quot;hola&quot;+1</code>).</p>
<h4 id="cadenes-sense-format-o-raw-string">Cadenes sense format o Raw String</h4>
<p>Les cadenes sense format es delimiten amb triples cometes, i ens permeten escriure un <em>String</em> en diverses línies. Aquestes podran contenir tant noves línies com qualsevol altre caràcter:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> fragment=<span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">El miedo es el camino hacia el Lado Oscuro;
</span><span style="color:#e6db74">el miedo lleva a la ira,
</span><span style="color:#e6db74">la ira lleva al odio,
</span><span style="color:#e6db74">el odio lleva al sufrimiento.
</span><span style="color:#e6db74">        
</span><span style="color:#e6db74">        Maestro Yoda
</span><span style="color:#e6db74">                    ____
</span><span style="color:#e6db74">                 _.&#39; :  `._
</span><span style="color:#e6db74">             .-.&#39;`.  ;   .&#39;`.-.
</span><span style="color:#e6db74">    __      / : ___\ ;  /___ ; \      __
</span><span style="color:#e6db74">  ,&#39;_ &#34;&#34;--.:__;&#34;.-.&#34;;: :&#34;.-.&#34;:__;.--&#34;&#34; _`,
</span><span style="color:#e6db74">  :&#39; `.t&#34;&#34;--.. &#39;&lt;@.`;_  &#39;,@&gt;` ..--&#34;&#34;j.&#39; `;
</span><span style="color:#e6db74">       `:-.._J &#39;-.-&#39;L__ `-- &#39; L_..-;&#39;
</span><span style="color:#e6db74">         &#34;-.__ ;  .-&#34;  &#34;-.  : __.-&#34;
</span><span style="color:#e6db74">             L &#39; /.------.\ &#39; J
</span><span style="color:#e6db74">              &#34;-.   &#34;--&#34;   .-&#34;
</span><span style="color:#e6db74">             __.l&#34;-:_JL_;-&#34;;.__
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</code></pre></div><p>Amb aquestes cadenes podem utilitzar el mètode <code>trimMargin()</code> que elimina els espais en blanc abans del caràcter <code>|</code>. Açò ens pot ser d&rsquo;utilitat quan volem mantindre la indentació a l&rsquo;hora de definir una cadena sense format. Per exemple si fem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
  println(<span style="color:#e6db74">&#34;&#34;&#34;El miedo es el camino hacia el Lado Oscuro;
</span><span style="color:#e6db74">            el miedo lleva a la ira,
</span><span style="color:#e6db74">            la ira lleva al odio,
</span><span style="color:#e6db74">            el odio lleva al sufrimiento.
</span><span style="color:#e6db74">                        
</span><span style="color:#e6db74">                    Maestro Yoda
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>)
}
</code></pre></div><p>Obtindríem l&rsquo;eixida:</p>
<pre><code>El miedo es el camino hacia el Lado Oscuro;
            el miedo lleva a la ira,
            la ira lleva al odio,
            el odio lleva al sufrimiento.
                        
                    Maestro Yoda
</code></pre><p>Per tal de manternir la indentació i escriure el fragment correctament, fariem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
  println(<span style="color:#e6db74">&#34;&#34;&#34;El miedo es el camino hacia el Lado Oscuro;
</span><span style="color:#e6db74">            |el miedo lleva a la ira,
</span><span style="color:#e6db74">            |la ira lleva al odio,
</span><span style="color:#e6db74">            |el odio lleva al sufrimiento.
</span><span style="color:#e6db74">                        
</span><span style="color:#e6db74">            |        Maestro Yoda
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>.trimMargin())
}
</code></pre></div><p>El caràcter <code>|</code> amb el que podem indicar fins on eliminar espais inicials, pot ser reemplaçat per altre passant-lo com a argument al mètode. Per exemple, per a que siga <code>#</code>, fariem: <code>.trimMargin(&quot;#&quot;)</code>.</p>
<h4 id="string-templates">String templates</h4>
<p>Els <em>String Templates</em> o literals de cadena poden contindre expressions de plantilla (<em>template expressions</em>): fragments de codi que serà avaluat i el seu resultat concatenat a la cadena. Amb això podem incloure valors, variables o fins i tot expressions dins una cadena.</p>
<p>Les expressions de plantilla comencen amb el signe dòlar <code>$</code> i consisteixen en un nom de variable o una expressió entre claus <code>{}</code>.</p>
<p>A l&rsquo;apartat sobre l&rsquo;ús d&rsquo;arguments ja hem vist una expressió d&rsquo;aquest tipus:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">println(<span style="color:#e6db74">&#34;Hello </span><span style="color:#e6db74">${args[0]}</span><span style="color:#e6db74">&#34;</span>)
</code></pre></div><p>Però podem utilitzar altres construccions com:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> nom=<span style="color:#e6db74">&#34;maestro Yoda&#34;</span>
println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">$nom</span><span style="color:#e6db74"> te </span><span style="color:#e6db74">${nom.length}</span><span style="color:#e6db74"> caràcters&#34;</span>)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> temperatura = <span style="color:#ae81ff">27</span>
println(<span style="color:#e6db74">&#34;Amb </span><span style="color:#e6db74">${temperatura}</span><span style="color:#e6db74">º fa </span><span style="color:#e6db74">${if (temperatura &gt; 24) &#34;calor&#34; else &#34;fred&#34;}</span><span style="color:#e6db74">&#34;</span>)
</code></pre></div><p>Per mostrar la variable <code>temperatura</code> podriem haver utilitzat <code>$temperatura</code> sense claus, però com hem afegir el símbol <code>º</code> al darrere, hem hagut d&rsquo;utilitzar les claus per delimitar el nom de la variable.</p>
<p>Per altra banda, aquestes plantilles es poden utilitzar dins de qualsevol tipus de cadena, tant sense processar com escapades, pel que si volem escriure <em>literalment</em> una expressió fariem (representem <code>$</code> amb <code>${'$'}</code>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> temperatura=<span style="color:#ae81ff">27</span>
println(<span style="color:#e6db74">&#34;&#34;&#34;El valor de </span><span style="color:#e6db74">${&#39;$&#39;}</span><span style="color:#e6db74">{temperatura} és </span><span style="color:#e6db74">${temperatura}</span><span style="color:#e6db74">º&#34;&#34;&#34;</span>)
</code></pre></div><h3 id="34-valors-nuls-o-nullable-types">3.4. Valors nuls o <em>Nullable Types</em></h3>
<p>Hem comentat que Kotlin és un llenguatge segur, i entre altres coses, ens evita errors a l&rsquo;hora de programar com el <em>NullPointerException</em> ja que no permet que els valors de les variables siguen nuls per defecte.</p>
<p>Si volem especificar que una variable puga contindre un valor <code>nul</code>, cal definir-la explícitament com a <em>nullable</em>. Per a això, quan la definim, afegim un interrogant <code>?</code> al seu tipus:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; <span style="color:#66d9ef">val</span> nom: String?=<span style="color:#66d9ef">null</span>
</code></pre></div><p>Si no haverem definit la variable com a <em>nullable</em> haverem obtingut l&rsquo;error:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; <span style="color:#66d9ef">val</span> nom:String=<span style="color:#66d9ef">null</span>
error: <span style="color:#66d9ef">null</span> can not be a value of a non-<span style="color:#66d9ef">null</span> type String
</code></pre></div><h4 id="loperador-safe-call-operator-">L&rsquo;operador <em>Safe Call Operator</em> <code>?.</code></h4>
<p>Per tindre un plus de seguretat a les variables <em>nullables</em> i poder d&rsquo;accedir a les propietats o mètodes d&rsquo;un objecte d&rsquo;aquest tipus, Kotlin ens ofereix l&rsquo;operador <em>Safe Call Operator</em> <code>?.</code>. Amb aquest operador, només podrem accedir a atributs o mètodes d&rsquo;un objecte si té un valor no nul. En cas que aquest siga nul, s&rsquo;ignorarà, evitant així una excepció de tipus <code>NullPointerException</code>. Veiem alguns exemples:</p>
<ul>
<li>Definició d&rsquo;un string <em>nullable</em> amb valor <strong>diferent</strong> a <code>nul</code>, i accés a la seua propietat <code>length</code>, que ens diu la longitud d&rsquo;aquest:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; <span style="color:#66d9ef">val</span> nom:String?=<span style="color:#e6db74">&#34;Jose&#34;</span>
&gt;&gt;&gt; nom<span style="color:#f92672">?.</span>length
res1: kotlin.Int? = <span style="color:#ae81ff">4</span>
</code></pre></div><ul>
<li>Definició d&rsquo;un string <em>nullable</em> amb valor <strong>igual</strong> a <code>null</code>, i accés a la seua propietat <code>length</code>, que ens retornarà <code>null</code>, però sense tornar cap error.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; <span style="color:#66d9ef">val</span> nom:String?=<span style="color:#66d9ef">null</span>
&gt;&gt;&gt; nom<span style="color:#f92672">?.</span>length
re24: kotlin.Int? = <span style="color:#66d9ef">null</span>
</code></pre></div><ul>
<li>En canvi, si definim un string sense indicar que siga nullable, si li assignem el valor <code>null</code> obtindrem un error:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; <span style="color:#66d9ef">val</span> nom:String=<span style="color:#66d9ef">null</span>
error: <span style="color:#66d9ef">null</span> can not be a value of a non-<span style="color:#66d9ef">null</span> type String
</code></pre></div><p>Per altra banda, podem encadenar <em>crides segures</em>, fent ús de l&rsquo;operador <code>?.</code>. Per exemple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">// La funció ObtenirNomPaisSegur retorna un String corresponent
</span><span style="color:#75715e">// al país en què viu la persona (objecte de tipus Prsona)
</span><span style="color:#75715e">// que li passem com a argument.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">ObtenirNomPaisSegur</span>(persona: Persona?): String? {
    <span style="color:#75715e">// Obtenim el nom del país on viu la pesona &#34;navegant&#34;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// a través de les diferents classes
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> persona<span style="color:#f92672">?.</span>direccio<span style="color:#f92672">?.</span>ciutat<span style="color:#f92672">?.</span>pais<span style="color:#f92672">?.</span>nom
}
</code></pre></div><p>Amb l&rsquo;ús de l&rsquo;operador <code>?.</code> ens estem assegurant que si algun dels objectes intermitjos és <em>nul</em>, el valor de retorn de la funció siga <em>nul</em> i no llance cap error.</p>
<h4 id="loperador-elvis-">L&rsquo;operador <em>Elvis</em> <code>?:</code></h4>
<p>Kotlin també ens proporciona l&rsquo;operador <code>?:</code>, conegut com l&rsquo;operador <em>Elvis</em>, per tal d&rsquo;especificar un valor alternatiu quan la variable és nul·la. Veiem un exemple d&rsquo;ús des de la consola de kotlin:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; <span style="color:#66d9ef">val</span> nom:String?=<span style="color:#e6db74">&#34;Jose&#34;</span>
&gt;&gt;&gt; nom<span style="color:#f92672">?.</span>length <span style="color:#f92672">?:</span> -<span style="color:#ae81ff">1</span>
res39: kotlin.Int = <span style="color:#ae81ff">4</span>

&gt;&gt;&gt; <span style="color:#66d9ef">val</span> nom:String?=<span style="color:#66d9ef">null</span>
&gt;&gt;&gt; nom<span style="color:#f92672">?.</span>length <span style="color:#f92672">?:</span> -<span style="color:#ae81ff">1</span>
res41: kotlin.Int = -<span style="color:#ae81ff">1</span>
</code></pre></div><p>En aquest exemple, si la cadena <em>nom</em> té valor, quan accedim a la seua longitud, ens mostrarà aquesta sense problemes. En canvi, si <em>nom</em> no té valor (aquest és <code>null</code>), obtindrem el valor de <em>-1</em>, en lloc d&rsquo;un error.</p>
<h4 id="operador-daserció-no-nul-">Operador d&rsquo;aserció no-nul <code>!!</code></h4>
<p>Aquest operador <code>!!</code> convertirà qualsevol valor de tipus <em>nullable</em> a un tipus <strong>no nul</strong>, i tornarà una excepció <em>NullPointerException</em> en cas que el valor siga nul.</p>
<ul>
<li>Definim un string <em>nullable</em>, amb valor nul:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; <span style="color:#66d9ef">val</span> nom1:String?=<span style="color:#66d9ef">null</span>
</code></pre></div><ul>
<li>Si accedim a la seua propietat length obtindrem un error:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; nom1.length
error: only safe (<span style="color:#f92672">?.</span>) or non-<span style="color:#66d9ef">null</span> asserted (<span style="color:#f92672">!!</span>.) calls are allowed on a nullable <span style="color:#66d9ef">receiver</span> of type String?
nom1.length
    ^
</code></pre></div><p>Aquest error ens indica que estem intentant accedir a les propietats d&rsquo;un objecte que és nul. Per evitar-lo, ens diu que o bé utilitzem l&rsquo;operador de crida segura (<code>?.</code>) o el convertim a un tipus no nul amb l&rsquo;operador d&rsquo;asserció no nul (<code>!!</code>).</p>
<ul>
<li>Utilitzant aquest operador d&rsquo;asserció no nul, veurem com ara Kotlin ens torna una excepció:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; nom1<span style="color:#f92672">!!</span>.length
kotlin.KotlinNullPointerException
</code></pre></div><p>La utilitat d&rsquo;aquest operador és per forçar que es produisca una excepció <code>NullPointerException</code> quan accedim a un valor nul.</p>
<p>Podeu trobar més informació sobre els tipus segurs a la documentació de Kotlin: <a href="https://kotlinlang.org/docs/reference/null-safety.html">https://kotlinlang.org/docs/reference/null-safety.html</a></p>
<h3 id="35-detalls-sobre-lemmagatzemament-de-variables">3.5. Detalls sobre l&rsquo;emmagatzemament de variables</h3>
<p>L&rsquo;emmagatzemament de variable en <strong>Java</strong> es realitza de la següent forma:</p>
<ul>
<li>Les variables de <em><strong>tipus bàsic</strong></em> (int, float,&hellip;) s&rsquo;emmagatzemen tal qual en l&rsquo;adreça de memòria a la que apunta la variable.</li>
<li>Per a les variables de <em><strong>tipus no bàsic</strong></em> (objectes, vectors i matrius), l&rsquo;adreça de memòria a la que apunta el nom de la variable és una referència a l&rsquo;adreça de memòria on realment es guarda l&rsquo;objecte.</li>
</ul>
<p>En <strong>Kotlin</strong> el mecanisme és pràcticament igual, amb la diferència que els tipus bàsics s&rsquo;implementen també com a objectes.</p>
<p>Amb açò, anem a tindre algunes consideracions sobre el pas de paràmetres i la comparació d&rsquo;objectes:</p>
<ul>
<li>
<p>Quan s&rsquo;invoca un mètode en Java, el pas de paràmetres és sempre <strong>per valor.</strong> Ara bé:</p>
<ul>
<li>Quan passem una variable de tipus bàsic, es fa una còpia del valor d&rsquo;aquesta, i si es modifica, no afecta a la variable real.</li>
<li>Quan passem una variable de tipus no bàsic, es fa una còpia, però de la referència a l&rsquo;objecte, pel que els canvis sí que afecten a l&rsquo;objecte original.</li>
</ul>
</li>
</ul>
<p>A l&rsquo;hora de <strong>comparar objectes</strong> en Java, si utilitzàrem l&rsquo;operador <code>==</code>, compararíem la referència en memòria, el que voldria dir que comprovariem si és el mateix objecte, no si té el mateix valor. Per tal de fer la comparació d&rsquo;objectes, <strong>caldría implementar un mètode específic</strong> en la pròpia classe que comprovara que es tracta d&rsquo;objectes de la mateixa classe, i comparara un per un tots els atributs d&rsquo;aquest.</p>
<p>En Kotlin, tot i que els tipus bàsics s&rsquo;implementen també com a objectes, i per tant s&rsquo;emmagatzemen les seues referències, es tracten d&rsquo;una forma més intel·ligent, i podem utilitzar els operadors de comparació de la mateixa manera que en Java. Al següent apartat ho veurem amb més detall.</p>
<h2 id="4-operadors">4. Operadors</h2>
<p>Als següent apartats, veurem les taules amb els diferents operadors que podem utilitzar tant en Java com en Kotlin i el seu significat.</p>
<ul>
<li><strong>Operador d&rsquo;assignació</strong></li>
</ul>
<p>S&rsquo;utilitza per donar valor a una variable.</p>
<table>
<thead>
<tr>
<th>Operador</th>
<th>Significat</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>Assignació</td>
<td>n=4</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Operadors aritmètics</strong></li>
</ul>
<p>Serveixen per realitzar operacions aritmètiques amb les variables. El resultat serà un valor numèric.</p>
<table>
<thead>
<tr>
<th>Operador</th>
<th>Significat</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>Canvi de signe (unari)</td>
<td>-4</td>
</tr>
<tr>
<td>+</td>
<td>Suma</td>
<td>5 + 3</td>
</tr>
<tr>
<td>++</td>
<td>Increment</td>
<td>5++</td>
</tr>
<tr>
<td>+=</td>
<td>Suma Combinada</td>
<td>a+=b (a=a+b)</td>
</tr>
<tr>
<td>-</td>
<td>Resta</td>
<td>5 - 3</td>
</tr>
<tr>
<td>&ndash;</td>
<td>Decrement</td>
<td>5&ndash;</td>
</tr>
<tr>
<td>-=</td>
<td>Resta Combinada</td>
<td>a-=b (a=a-b)</td>
</tr>
<tr>
<td>*</td>
<td>Producte</td>
<td>5 * 3</td>
</tr>
<tr>
<td>*=</td>
<td>Producte Combinat</td>
<td>a*=b (a=a*b)</td>
</tr>
<tr>
<td>/</td>
<td>Divisió</td>
<td>5/3   5.0/3.0</td>
</tr>
<tr>
<td>/=</td>
<td>Divisió Combinada</td>
<td>a/=b (a=a/n)</td>
</tr>
<tr>
<td>%</td>
<td>Resta de la divisió entera</td>
<td>5 % 3</td>
</tr>
<tr>
<td>%=</td>
<td>Resta de la divisió combinada</td>
<td>a%=b (a=a%b)</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Operadors relacionals</strong></li>
</ul>
<p>Serveixen per realitzar comparacions entre variables, i retornen un valor lògic.</p>
<table>
<thead>
<tr>
<th>Operador</th>
<th>Significat</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>igual que</td>
<td>a==b</td>
</tr>
<tr>
<td>!=</td>
<td>diferent que</td>
<td>a!=b</td>
</tr>
<tr>
<td>&lt;</td>
<td>menor que</td>
<td>a&lt;b</td>
</tr>
<tr>
<td>&gt;</td>
<td>major que</td>
<td>a&gt;b</td>
</tr>
<tr>
<td>&lt;=</td>
<td>menor o igual</td>
<td>a&lt;=b</td>
</tr>
<tr>
<td>&gt;=</td>
<td>major o igual</td>
<td>a&gt;=b</td>
</tr>
</tbody>
</table>
<p>A més, amb <em><strong>Kotlin</strong></em>, podem utilitzar:</p>
<table>
<thead>
<tr>
<th>Operador</th>
<th>Significat</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr>
<td>===</td>
<td>És el mateix objecte</td>
<td>a===b</td>
</tr>
<tr>
<td>!==</td>
<td>No és el mateix objecte</td>
<td>a!==b</td>
</tr>
</tbody>
</table>
<p>En Kotlin el diferencia la igualtat <em>estructural</em> i la igualtat <em>referencial</em>:</p>
<ul>
<li>La igualtat <strong>estructural</strong> serveix per tal de comprovar si dos valors o variables són iguals (com un <code>equals()</code> en Java), i utilitza els operadors <code>==</code> per comprovar si tenen el mateix valor i <code>!=</code> per comprovar si són valors diferents.</li>
<li>La igualtat <strong>referencial</strong>, per la seua banda, comprova si dues referències apunten o no al mateix objecte. Amb <code>===</code> comprovem si s&rsquo;apunta al mateix objecte, i amb <code>!==</code> si dos referències apunten a objectes diferents.</li>
</ul>
<p>Per altra banda, tot i que a Kotlin tot són objectes (per tant, referències) amb els tipus bàsics (int, float&hellip;) es fa una excepció, i es tracten de manera més intel·ligent, de manera que la igualtat referencial <code>===</code> compara valors en lloc de comparar les referències.</p>
<ul>
<li><strong>Operadors lògics</strong></li>
</ul>
<p>Serveixen per realitzar operacions entre variables de tipus lògic. El seu resultat és també de tipus lògic.</p>
<table>
<thead>
<tr>
<th>Operador</th>
<th>Significat</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>Negació</td>
<td>!(a==b)</td>
</tr>
<tr>
<td>||</td>
<td>OR</td>
<td>(a==b)||(a==c)</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>AND</td>
<td>(a==b)&amp;&amp;(a==c)</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Operador condicional ternari</strong></li>
</ul>
<p>En Java existeix l&rsquo;operador condicional ternari:</p>
<table>
<thead>
<tr>
<th>Operador</th>
<th>Significat</th>
<th>Exemple</th>
</tr>
</thead>
<tbody>
<tr>
<td>? :</td>
<td>Operador Condicional Ternari</td>
<td>a= (b==0 ? a : a/b )</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">valor <span style="color:#f92672">=</span> <span style="color:#f92672">(</span> condició <span style="color:#f92672">?</span> expressió_1 <span style="color:#f92672">:</span> expressió_1<span style="color:#f92672">);</span>
</code></pre></div><p>Que sería equivalent a:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>condició<span style="color:#f92672">)</span>
    valor <span style="color:#f92672">=</span> expressió_1<span style="color:#f92672">;</span>
<span style="color:#66d9ef">else</span>
    valor <span style="color:#f92672">=</span> expressió_2<span style="color:#f92672">;</span>
</code></pre></div><p>Cal dir, que en aquest punt, Java, a l&rsquo;igual que altres llenguatges com Javscript o C#, tracta les sentències condicionals com una declaració, el que vol dir que no es resolen a un valor. Per això, cal utilitzar aquest operador ternari si volem assignar un valor de forma condicional a una variable.</p>
<p>En Kotin, una sentència condicional no és una declaració, sinò una expressió, de manera que pot assignar-se directament a una variable, de manera que no és necessari aquest operador, i podem fer coses com:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">var</span> valor = <span style="color:#66d9ef">if</span> (condició) expressió_1 <span style="color:#66d9ef">else</span> expressió_2
</code></pre></div><p>Veiem-ho amb un exemple més clar:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// En Java:
</span><span style="color:#75715e"></span>major <span style="color:#f92672">=</span> <span style="color:#f92672">(</span> x<span style="color:#f92672">&gt;</span>y <span style="color:#f92672">?</span> x <span style="color:#f92672">:</span> y<span style="color:#f92672">);</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">// En Kotlin:
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> major = <span style="color:#66d9ef">if</span> (x&gt;y) x <span style="color:#66d9ef">else</span> y
</code></pre></div><p>Com veiem, resulta una miqueta més clar el codi en Kotlin que en Java.</p>
<ul>
<li><strong>Separadors</strong></li>
</ul>
<p>Els separadors són caràcters amb significat especial.</p>
<table>
<thead>
<tr>
<th>Operador</th>
<th>Significat</th>
</tr>
</thead>
<tbody>
<tr>
<td>()</td>
<td>Permet especificar la prioritat dins les expressions i fer conversions de tipus (Java). També s&rsquo;usa per especificar la llista d&rsquo;arguments de funcions i/o mètodes</td>
</tr>
<tr>
<td>{}</td>
<td>Defineix blocs de codi</td>
</tr>
<tr>
<td>[]</td>
<td>Per declarar i referenciar elements de vectors o matrius</td>
</tr>
<tr>
<td>;</td>
<td>Separador de sentències (opcional en Kotlin)</td>
</tr>
<tr>
<td>,</td>
<td>Separa identificadors en la declaració de variables i llistes de paràmetres, o encadenar sentències dins un for</td>
</tr>
<tr>
<td>.</td>
<td>Separa el nom d&rsquo;un atribut/mètode de la seua instància de referència. També separa l&rsquo;identificador d&rsquo;un paquet dels subpaques i classes</td>
</tr>
</tbody>
</table>
<h2 id="5-estructures-de-control">5. Estructures de control</h2>
<p>Veiem les diferents estructures de control que podem utilitzar tant a Java com a Kotlin:</p>
<h3 id="51-estructures-condicionals">5.1. Estructures condicionals</h3>
<h4 id="if-else">if-else</h4>
<p>Aquesta estructura de control és igaul en Java que en Kotlin:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">if</span> (expressióLògica) {
    bloc_de_sentències_si_expressió_avalua_a_true;
} <span style="color:#66d9ef">else</span> {
    bloc_de_sentències_si_expressió_avalua_a_false;
}
</code></pre></div><p>Recordeu, que a més, l&rsquo;estructura <code>if-then-else</code> pot usar-se a Kotlin com a una expressió.</p>
<h4 id="switch-i-when">Switch i When</h4>
<p>Els <code>switch</code> s&rsquo;utilitzen en Java, i <strong>no existeixen a Kotlin</strong>. La seua sintaxi és:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">switch</span> <span style="color:#f92672">(</span>variable<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">case</span> valor_1<span style="color:#f92672">:</span>
        sentències_si_variable<span style="color:#f92672">==</span>valor_1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">case</span> valor_2<span style="color:#f92672">:</span>
        sentències_si_variable<span style="color:#f92672">==</span>valor_2<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">case</span> valor_n<span style="color:#f92672">:</span>
        sentències_si_variable<span style="color:#f92672">==</span>valor_n<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
        sentències_si_cap_valor_es_compleix<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>L&rsquo;estructura que més s&rsquo;assemblaria al <code>switch</code> de Java en Kotlin és el <code>when</code>. Els <code>when</code> en Kotlin podriem dir que es tracten de <em><code>switch</code> supervitaminats</em>. Es tracta d&rsquo;una construcció que pot utilitzar-se tant com a sentència com a expressió.</p>
<p>La sintaxi bàsica del <code>when</code> podría expressar-se de les formes següents:</p>
<ul>
<li><strong>Com a sentència</strong>: Més o menys com fariem un <code>switch</code> amb altres llenguatges, però amb sintaxi diferent:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">when</span> (expressióValor){
    valor1 <span style="color:#f92672">-&gt;</span> sentencies_si_Valor1
    valor2 <span style="color:#f92672">-&gt;</span> sentencies_si_Valor2
    <span style="color:#f92672">..</span>.
    valorN <span style="color:#f92672">-&gt;</span> sentencies_si_ValorN
    <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> sentencies_default
}
</code></pre></div><p>En aquesta construcció l'<code>else</code> seria com el <code>default</code> al <code>switch</code> de Java, i el seu ús no és obligatori.</p>
<ul>
<li><strong>Com a expressió</strong>: Kotlin suporta el paradigma de la <strong>programació funcional</strong> de forma bastant bàsica. Als llenguatges de programació funcional, les estructures de control són expressions, de manera que el resultat de la seua avaluació pot ser retornat a qui l&rsquo;invoca. Si aquest valor s&rsquo;assigna a una variable, el compilador comprovarà que el tipus retornat és compatible amb l&rsquo;esperat i ens informarà si no és el cas. Així doncs, podem utilitzar:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">var</span> x=<span style="color:#66d9ef">when</span> (expressióValor){
    valor1 <span style="color:#f92672">-&gt;</span> valor_per_a_x_si_valor1
    valor2 <span style="color:#f92672">-&gt;</span> valor_per_a_x_si_valor2
    <span style="color:#f92672">..</span>.
    valorN <span style="color:#f92672">-&gt;</span> valor_per_a_x_si_valor1
    <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> valor_per_a_x_per_defecte
}
</code></pre></div><p>En aquest cas, s&rsquo;avaluarà <code>expressióValor</code>, i en funció del resultat (<code>valor1</code>, <code>valor2</code>&hellip;) s&rsquo;assignarà un o altre valor a <code>x</code>. En aquest cas, l&rsquo;ús de <code>else</code> sí que és necessari, ja que necessàriament caldrà assignar un valor a <code>x</code>.</p>
<p>Veiem algun exemples d&rsquo;ús per veure-ho més clar:</p>
<p><strong>Exemple</strong>: Ús de <code>when</code> com a sentència. Suposant que estem dins un <code>main</code> amb arguments:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">when</span> (args[<span style="color:#ae81ff">0</span>]){
    <span style="color:#e6db74">&#34;Hola Don Pepito&#34;</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;Hola Don José&#34;</span>)
    <span style="color:#e6db74">&#34;Pasó usted por mi casa&#34;</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;Por su casa yo pasé&#34;</span>)
    <span style="color:#e6db74">&#34;Y vio usted a mi abuela&#34;</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;A su abuela yo la vi&#34;</span>)
    <span style="color:#e6db74">&#34;Adiós don Pepito&#34;</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;Adiós don José&#34;</span>)
}
</code></pre></div><p><strong>Exemple</strong>: Ús de <code>when</code> com a expressió:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">var</span> resposta=<span style="color:#66d9ef">when</span> (args[<span style="color:#ae81ff">0</span>]){
    <span style="color:#e6db74">&#34;Hola Don Pepito&#34;</span> <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#34;Hola Don José&#34;</span>
    <span style="color:#e6db74">&#34;Pasó usted por mi casa&#34;</span> <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#34;Por su casa yo pasé&#34;</span>
    <span style="color:#e6db74">&#34;Y vio usted a mi abuela&#34;</span> <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#34;A su abuela yo la vi&#34;</span>
    <span style="color:#e6db74">&#34;Adiós don Pepito&#34;</span> <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#34;Adiós don José&#34;</span>
    <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#34;No entenc la pregunta&#34;</span>
}
println(resposta)
</code></pre></div><p>Per altra banda, és possible que volgam afegir més d&rsquo;una sentència segons les condicions. Aleshores, podriem utilitzar les claus <code>{}</code> per delimitar blocs de sentències:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">resposta=<span style="color:#66d9ef">when</span> (args[<span style="color:#ae81ff">0</span>]){
    <span style="color:#e6db74">&#34;Hola Don Pepito&#34;</span> <span style="color:#f92672">-&gt;</span> {
        println(<span style="color:#e6db74">&#34;coincidència al bloc 1&#34;</span>)
        <span style="color:#e6db74">&#34;Hola Don José&#34;</span>}
    <span style="color:#e6db74">&#34;Pasó usted por mi casa&#34;</span> <span style="color:#f92672">-&gt;</span> {
        println(<span style="color:#e6db74">&#34;coincidència al bloc 2&#34;</span>)
        <span style="color:#e6db74">&#34;Por su casa yo pasé&#34;</span>}
    <span style="color:#e6db74">&#34;Y vio usted a mi abuela&#34;</span> <span style="color:#f92672">-&gt;</span> {
        println(<span style="color:#e6db74">&#34;coincidència al bloc 3&#34;</span>)
        <span style="color:#e6db74">&#34;A su abuela yo la vi&#34;</span>}
    <span style="color:#e6db74">&#34;Adiós don Pepito&#34;</span> <span style="color:#f92672">-&gt;</span> {
        println(<span style="color:#e6db74">&#34;coincidència al bloc 4&#34;</span>)
        <span style="color:#e6db74">&#34;Adiós don José&#34;</span>}
    <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> {
        println(<span style="color:#e6db74">&#34;coincidència al bloc del else -default-&#34;</span>)
        <span style="color:#e6db74">&#34;No entenc la pregunta&#34;</span>}
}
println(resposta)
</code></pre></div><p>Però <code>when</code> encara ens guarda algunes funcionalitats més bastant potents:</p>
<p><strong>When sense arguments</strong></p>
<p>When pot utilitzar-se sense arguments, de manera que ens servisca com a alternativa al <code>if-then-else</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">when</span>{
    temperatura &lt; <span style="color:#ae81ff">15</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;Fa fred&#34;</span>)
    temperatura <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">15.</span>.<span style="color:#ae81ff">24</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;S&#39;està bé&#34;</span>)
    temperatura &gt; <span style="color:#ae81ff">25</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;Fa calor&#34;</span>)
}
</code></pre></div><p><strong>Operadors <code>is</code> i <code>in</code></strong></p>
<ul>
<li>Amb l&rsquo;operador <code>is</code> podem determinar la classe d&rsquo;una variable. Quan l&rsquo;utilitzem a la part esquerra de la <code>-&gt;</code>, a la part dreta ja tindrem el càsting fet. Cal dir que per tal de fer aquest <em>smart cast</em> correctament i sense errors, la variable ha de ser de tipus <em>Any</em>.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">var</span> variable:Any=Valor

<span style="color:#66d9ef">when</span>(variable){
    <span style="color:#66d9ef">is</span> Int <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${variable}</span><span style="color:#e6db74"> és un enter&#34;</span>)
    <span style="color:#66d9ef">is</span> Char <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${variable}</span><span style="color:#e6db74"> és un caràcter&#34;</span>)
    <span style="color:#66d9ef">is</span> String <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${variable}</span><span style="color:#e6db74"> és una cadena&#34;</span>)
    <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${variable}</span><span style="color:#e6db74"> és d&#39;altre tipus&#34;</span>)

}
</code></pre></div><ul>
<li>Amb l&rsquo;operador <code>in</code> podem comprovar si el valor està dins un rang. Per exemple:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">when</span> (mes){
    <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>.<span style="color:#ae81ff">3</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;Estem en hivern&#34;</span>)
    <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">4.</span>.<span style="color:#ae81ff">6</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;Estem en primavera&#34;</span>)
    <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">7.</span>.<span style="color:#ae81ff">9</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;Estem en estiu&#34;</span>)
    <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">10.</span>.<span style="color:#ae81ff">12</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;Estem en tardor&#34;</span>)
}
</code></pre></div><p>Veiem en aquest exemple com és de senzill definir rangs amb Kotlin fent ús de l&rsquo;operador <code>..</code>.</p>
<ul>
<li>A més, també podem especificar valors concrets dins un mateix cas:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">var</span> dia = <span style="color:#ae81ff">4</span>
<span style="color:#66d9ef">when</span>(dia) {
    <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;Hui es treballa&#34;</span>)
    <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;Hui és cap de setmana&#34;</span>)
    <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> println(<span style="color:#e6db74">&#34;El dia no és correcte&#34;</span>)
}
</code></pre></div><p>Podeu trobar més informació sobre el <code>when</code> a Kotlin  a l&rsquo;article <a href="https://devexperto.com/expresion-when-kotlin/">https://devexperto.com/expresion-when-kotlin/</a></p>
<h3 id="52-estructures-repetitives">5.2. Estructures repetitives</h3>
<h4 id="bucles-for">Bucles for</h4>
<ul>
<li>Es repeteix un bloc de sentències mentre es compleix la condició de repetició.</li>
<li>La inicialització, la condició i la iteració es realitzen en la mateixa instrucció.</li>
</ul>
<p>En <em><strong>Java</strong></em>, la sintaxi del <code>for</code> és la següent:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>inicialització<span style="color:#f92672">;</span> condició_de_repetició<span style="color:#f92672">;</span> iteració<span style="color:#f92672">)</span>
    Bloc_de_sentències
</code></pre></div><p>En <strong>Kotlin</strong>, la sintaxi és lleugerament diferent, i fa ús de l&rsquo;operador <code>in</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">for</span> (element <span style="color:#66d9ef">in</span> conjuntDeValors)
    Instruccions
</code></pre></div><p>Anb açò podem fer coses com:</p>
<ul>
<li>Recórrer una cadena de caràcters o un vector:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">for</span> (caracter <span style="color:#66d9ef">in</span> <span style="color:#e6db74">&#34;Hola Mon&#34;</span>)  println(caracter)
</code></pre></div><ul>
<li>Recórrer un rang de valors:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>.<span style="color:#ae81ff">10</span>) {
    println(i)
}
</code></pre></div><p>O bé, fent ús de la funció d&rsquo;extensió <code>rangeTo()</code>, que seria equivalent:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>rangeTo(<span style="color:#ae81ff">10</span>)) {
    println(i)
}
</code></pre></div><ul>
<li>Recórrer un rang de valors saltejant valors:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>.<span style="color:#ae81ff">10</span> step <span style="color:#ae81ff">2</span>) {
    println(i)
}
</code></pre></div><ul>
<li>Utilitzar les expressions <code>downTo</code> per iterar números en ordre invers:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">10</span> downTo <span style="color:#ae81ff">0</span> step <span style="color:#ae81ff">3</span>) {
    println(i)
}
</code></pre></div><p>Finalment, fixeu-vos que no hem indicat en cap moment el tipus de la variable que fa d&rsquo;índex dels bucles. Aquest tipus és inferit per Kotlin segons els valors que li donem, i de fet, <strong>no ens permet indicar-lo en la declaració</strong>.</p>
<h4 id="bucles-while-i-do-while">Bucles while i do-while</h4>
<p>Els bucles <code>while</code> i <code>do-while</code> tenen la mateixa sintaxi a Kotlin que a Java.</p>
<p>Recordeu que als bucles <code>while</code>:</p>
<ul>
<li>La inicialització es realitza prèviament a la sentència while.</li>
<li>Si la primera vegada l&rsquo;expressió s&rsquo;avalúa a fals, no s&rsquo;executa el bloc de sentències cap vegada.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">[</span>inicialització<span style="color:#f92672">;]</span>
<span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>expressió<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Bloc_de_sentències<span style="color:#f92672">;</span>
    <span style="color:#f92672">[</span>iteració<span style="color:#f92672">]</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Per la seua banda, als bucles <code>do-while</code></p>
<ul>
<li>El bloc de sentències s&rsquo;exeuta al menys una vegada, ja que l&rsquo;expressió s&rsquo;avalúa al finalitzar aquest.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
    Bloc_de_sentències<span style="color:#f92672">;</span>
    <span style="color:#f92672">[</span>iteració<span style="color:#f92672">]</span>
<span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>expressió<span style="color:#f92672">);</span>
</code></pre></div><h4 id="sentències-break-i-continue">Sentències break i continue</h4>
<ul>
<li>Poden trobar-se dins el bloc de sentències dels bucles.</li>
<li><strong>break</strong> força l&rsquo;eixida del bucle.</li>
<li><strong>continue</strong> fa que es passe a la següent iteració, sense acabar d&rsquo;executar la resta de sentències.</li>
</ul>
<p>Amb Kotlin, a més podem fer ús d'<em><strong>etiquetes</strong></em> per a aquestes sentències. Una etiqueta no és més que un identificador seguit del signe <code>@</code>, al que podem fer referència quan fem un <code>break</code> o un <code>continue</code>, posant l'<code>@</code> dvant. Veiem-ho amb alguns exemples:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">bucleExtern<span style="color:#960050;background-color:#1e0010">@</span> <span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>.<span style="color:#ae81ff">10</span>) {
    <span style="color:#66d9ef">for</span> (j <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>.<span style="color:#ae81ff">10</span>) {
        <span style="color:#66d9ef">if</span> (condició) <span style="color:#66d9ef">break</span><span style="color:#a6e22e">@bucleExtern</span>
    }
}
</code></pre></div><p>El següent codi:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>.<span style="color:#ae81ff">5</span>){
  <span style="color:#66d9ef">for</span> (j <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>.<span style="color:#ae81ff">5</span>){
      println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${i}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">${j}</span><span style="color:#e6db74">&#34;</span>)
      <span style="color:#66d9ef">if</span> (j&gt;<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">break</span>
  }
}
</code></pre></div><p>Tindrà l&rsquo;eixida:</p>
<pre><code>1, 1
1, 2
1, 3
2, 1
2, 2
2, 3
3, 1
3, 2
3, 3
4, 1
4, 2
4, 3
5, 1
5, 2
5, 3
</code></pre><p>Mentre que si fem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">bucleExt<span style="color:#960050;background-color:#1e0010">@</span> <span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>.<span style="color:#ae81ff">5</span>){
  <span style="color:#66d9ef">for</span> (j <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>.<span style="color:#ae81ff">5</span>){
    println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${i}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">${j}</span><span style="color:#e6db74">&#34;</span>)
      <span style="color:#66d9ef">if</span> (j&gt;<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">break</span><span style="color:#a6e22e">@bucleExt</span>
  }
}
</code></pre></div><p>Obtindrem:</p>
<pre><code>1, 1
1, 2
1, 3
</code></pre><h2 id="53-tractament-dexcepcions">5.3. Tractament d&rsquo;excepcions</h2>
<p>Les excecions representen situacions anòmales o problemes al nostre codi. En Java, podem distingir en general dos tipus d&rsquo;excepcions:</p>
<ul>
<li>Els errors: situacions irrecuperables que provoquen l&rsquo;aturada del programa.</li>
<li>Les excepcions en sí, provocades per alguna situació anòmala, i que podem controlar.</li>
</ul>
<p>Al següent diagrama de classes podem vore la jerarquía de les diferents classes d&rsquo;errors que ens podem trobar a Java:</p>
<p><img src="../img/excepcions.png" alt="Excepcions en java"></p>
<p>Veiem com totes les excepcions deriven de la classe <code>Throwable</code>, i d&rsquo;aquesta deriven les classes <code>Error</code> i <code>Exception</code>.</p>
<p>A més, podem distingir dos tipus diferents d&rsquo;excepcions a partir de la classe <code>Exception</code>:</p>
<ul>
<li>
<p>Les excepcions <strong>revisades</strong>, que hereten directament de <code>java.lang.Exception</code> i que són <strong>detectades en temps de compilació</strong>, de manera que el compilador ens obliga a controlar-les amb un bloc <em>try/catch</em> o rellançar-les amb <em>throws</em>. Els mètodes que puguen provocar aquest tipus d&rsquo;excepcions ho han d&rsquo;indicar amb la paraula clau <code>throws</code>, així com els mètodes que invoquen a mètodes que puguen llançar estes excepcions, hauran bé de capturar-les o rellançar-les. Exemples d&rsquo;aquest tipu sd&rsquo;excepcions són <code>IOException</code>, <code>ClassNotFoundException</code>, <code>FileNotFoundException</code>, <code>SQLException</code>, <code>NoSuchMethodException</code>.</p>
</li>
<li>
<p>Les excepcions <strong>no revisades</strong>, que hereten de la classe <code>java.lang.RuntimeException</code>, són errades de codi, i es detecten <strong>en temps d&rsquo;execució</strong>. Aquestes no són controlades pel compilador, pel que no ens obliga a tractar-les. Les excepcions no revisades més comunes inclouen:</p>
<ul>
<li><strong>ArithmeticException</strong>: Desbordament o divisió per zero.</li>
<li><strong>NumberFormatException</strong>: Conversió il·legal de tipus.</li>
<li><strong>IndexOutOfBoundsException</strong>: Accés a un element inexistent d&rsquo;un vector.</li>
<li><strong>NegativeArraySizeException</strong>: Intent de creació d&rsquo;un vector de longitud negativa.</li>
<li><strong>NullPointerException</strong>: Intent d&rsquo;ús d&rsquo;una referència nul·la.</li>
<li><strong>SecurityException</strong>: Violació de la seguretat en temps d&rsquo;execució.</li>
</ul>
</li>
</ul>
<p>Les excepcions no revisades poden previndre&rsquo;s codificant correctament el codi, pel que, com hem dit, no necessiten ser capturades.</p>
<p>La manera de tractar les excepcions amb Java és amb els blocs <em>try/catch</em>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
    bloc_de_sentències_que_pot_llençar_excepcions
<span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>ClasseExcepció_1 objecteExcepció<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    bloc_de_sentències_per_tractar_excepció_1<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span><span style="color:#f92672">(</span>ClasseExcepció_2 objecteExcepció<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    bloc_de_sentències_per_tractar_excepció_1<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
    bloc_de_tasques_comunes<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="tractament-dexcepcions-a-kotlin">Tractament d&rsquo;Excepcions a Kotlin</h4>
<p>La principal diferència en Kotlin respece a Java és que en Kotlin <strong>totes les excepcions són no revisades</strong>. A nivell pràctic, això implica que no s&rsquo;han d&rsquo;incloure <em>throws</em> a les declaracions de funcions on es puguen produir.</p>
<p>Això no vol dir que no es puguen tractar excepcions ni llançar excepcions al nostre codi.</p>
<p>Per exemple, tenim el següent codi:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">import</span> java.io.File

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">mostraFitxer</span> (fitxer:String){
    File(fitxer).forEachLine() { println(fitxer) }
}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>() {
    mostraFitxer(<span style="color:#e6db74">&#34;/tmp/noexisteix.txt&#34;</span>);
}
</code></pre></div><p>Com a peculiaritats, en primer lloc, podem vore com podem utilitzar indistintament les llibreríes de Java dins els nostres projectes. Per altra banda, també podem fixar-nos amb com de senzill resulta llegir el contingut d&rsquo;un fitxer amb Kotlin.</p>
<p>De tota manera, el que ens interessa és que en compilar aquest programa amb Kotlin no ens mostra cap missatge. Si havérem fet l&rsquo;equivalent amb Java ens diría que el nostre codi podría disparar una excepció del tipus IOException, aquesta hauria d&rsquo;haver segut llançada per la funció <code>mostraFitxer()</code>, i capturada per <code>main</code>. però Kotlin no ens diu res, ja que no revisa les excepcions.</p>
<p>En canvi, quan executem el programam, aquest s&rsquo;interromp i  ens mostra el missate:</p>
<pre><code>Exception in thread &quot;main&quot; java.io.FileNotFoundException: /tmp/noexisteix.txt (No such file or directory)
</code></pre><p>Com veiem, el fet que no es revisen les possiles excepcions en temps de compilació no significa que aquestes no puguen ocórrer. Per tractar-les, tenim els mateixos mecanismes que amb Java, amb el <em>try-catch-finally</em>.</p>
<p>L&rsquo;exemple anterior podríem haver-lo expressat de les següents maneres, segons on volguérem tractar l&rsquo;error:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">// Tractem l&#39;error dins el mètode mostraFitxer
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">mostraFitxer</span> (fitxer:String){
    <span style="color:#66d9ef">try</span>{
        File(fitxer).forEachLine() { println(fitxer) }
    } <span style="color:#66d9ef">catch</span> (ex: IOException){
        println(ex.message);
    }
}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>() {
    mostraFitxer(<span style="color:#e6db74">&#34;/tmp/noexisteix.txt&#34;</span>);
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">// Tractem l&#39;error al propi main, en aquest cas, tot i que
</span><span style="color:#75715e">// la funció mostraFitxer no emet explícitament cap excepció,
</span><span style="color:#75715e">// podem capturar-la des de la funció que la invoca.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">mostraFitxer</span> (fitxer:String){
        File(fitxer).forEachLine() { println(fitxer) }
}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">try</span>{
        mostraFitxer(<span style="color:#e6db74">&#34;/tmp/noexisteix.txt&#34;</span>);
    } <span style="color:#66d9ef">catch</span> (ex:Exception){
        println(ex.message);
    }
}
</code></pre></div><p>En els dos casos, l&rsquo;eixida del programa (que no interromprà l&rsquo;execució) serà la següent:</p>
<pre><code>/tmp/noexisteix.txt (No such file or directory)
</code></pre><p>Per altra banda, recordem que amb Kotlin, tot són expressions que poden tindre un resultat, i la construcció <em>try-catch-finally</em> no é suna excepció. Així podem fer coses com:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">mostraFitxer</span> (fitxer:String){
    <span style="color:#75715e">// Assignem el resultat del bloc try-catch a una constant
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">val</span> result = <span style="color:#66d9ef">try</span>{
        File(fitxer).forEachLine() { println(fitxer) }
        <span style="color:#66d9ef">true</span>    <span style="color:#75715e">// Si no ha botat cap excepció el resultat serà true
</span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">catch</span> (ex: IOException){
        println(ex.message);
        <span style="color:#66d9ef">false</span>   <span style="color:#75715e">// Si ha botat alguna excepció d&#39;E/E, el resultat serà fals
</span><span style="color:#75715e"></span>    }

    <span style="color:#66d9ef">if</span> (result) println(<span style="color:#e6db74">&#34;El fitxer s&#39;ha llegit correctament&#34;</span>);
    <span style="color:#66d9ef">else</span> println(<span style="color:#e6db74">&#34;El fitxer no s&#39;ha trobat&#34;</span>);
}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>() {
    mostraFitxer(<span style="color:#e6db74">&#34;/tmp/noexisteix.txt&#34;</span>);
}
</code></pre></div><blockquote>
<p><strong>La classe Nothing i les excepcions</strong></p>
<p>La classe <code>Nothing</code> representa <em>un valor que mai existirà</em>, i s&rsquo;utilitza com a tipus de retorn per a aquells mètodes/funcions que <strong>sempre</strong> retornen una excepció (i per tant no acaba d&rsquo;una forma normal).</p>
</blockquote>
<h4 id="interoperabilitat-amb-java">Interoperabilitat amb Java</h4>
<p>Com hem dit, Java i Kotlin s&rsquo;executen sobre la JVM, i podem treballar amb els dos llenguatges en una mateixa aplicació, tal i com hem vist a l&rsquo;exemple inicial amb Gradle. Però&hellip; si en Kotlin totes les excepcions són no revisades, i les funcions que poden llançar excepcions no tenen un <code>throws</code>, com sabem des de Java que una funció Kotlin pot llançar excepcions?</p>
<p>Ho fem mitjançant anotacions. Concretament disposem de l&rsquo;anotació <code>@Throw</code> en Kotlin que afegim a la definició de les funcions. Amb aquesta anotació, avisem a les invocacions que es realitzen des de Java per a que siguen conscients que la funció pot llençar excepcions i aquestes s&rsquo;han de capturar.</p>
<p>Anem a veure l&rsquo;exemple següent, amb un projecte Gradle anomenat <em><strong>KFileReader</strong></em>.</p>
<p>L&rsquo;estructura d&rsquo;aquest projecte és el següent:</p>
<pre><code>.
|-- build.gradle
|-- gradle
|   `-- wrapper
|       |-- gradle-wrapper.jar
|       `-- gradle-wrapper.properties
|-- gradlew
|-- gradlew.bat
|-- settings.gradle
`-- src
    `-- main
        |-- java
        |   `-- com
        |       `-- ieschabas
        |           `-- dam
        |               `-- FileReader.java
        |-- kotlin
        |   `-- com
        |       `-- ieschabas
        |           `-- dam
        |               `-- mostraFitxer.kt
        `-- resources

</code></pre><p>Com veiem, tenim dos rutes de codi font diferents per al mateix paquet, la de Java i la de Kotlin.</p>
<p>En aquest exemple, com veiem al fitxer <code>build.gradle</code>, la classe principal és la de Java (<code>FileReader</code>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-groovy" data-lang="groovy">plugins <span style="color:#f92672">{</span>
    <span style="color:#75715e">// Plugins de Kotlin
</span><span style="color:#75715e"></span>    id <span style="color:#e6db74">&#39;org.jetbrains.kotlin.jvm&#39;</span> version <span style="color:#e6db74">&#39;1.3.72&#39;</span>

    <span style="color:#75715e">// Tipus de projecte: Aplicació CLI
</span><span style="color:#75715e"></span>    id <span style="color:#e6db74">&#39;application&#39;</span>
<span style="color:#f92672">}</span>

repositories <span style="color:#f92672">{</span>
    jcenter<span style="color:#f92672">()</span>
<span style="color:#f92672">}</span>

dependencies <span style="color:#f92672">{</span>
    <span style="color:#75715e">// Dependències de Kotlin
</span><span style="color:#75715e"></span>    implementation <span style="color:#a6e22e">platform</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#39;org.jetbrains.kotlin:kotlin-bom&#39;</span><span style="color:#f92672">)</span>
    implementation <span style="color:#e6db74">&#39;org.jetbrains.kotlin:kotlin-stdlib-jdk8&#39;</span>
    testImplementation <span style="color:#e6db74">&#39;org.jetbrains.kotlin:kotlin-test&#39;</span>
    testImplementation <span style="color:#e6db74">&#39;org.jetbrains.kotlin:kotlin-test-junit&#39;</span>
<span style="color:#f92672">}</span>

application <span style="color:#f92672">{</span>
    <span style="color:#75715e">// La classe principal serà la que classe
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// que hem creat en Java
</span><span style="color:#75715e"></span>    mainClassName <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;com.ieschabas.dam.FileReader&#39;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>*<strong>Cas 1: Exemple sense tractament d&rsquo;excepcions</strong></p>
<p>Si no anem a tractar les excepcions, el codi font dels fitxers és el següent:</p>
<ul>
<li><strong>Fitxer <code>src/main/kotlin/com/ieschabas/dam/mostraFitxer.kt</code></strong></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">package</span> com.ieschabas.dam

<span style="color:#66d9ef">import</span> java.io.File
<span style="color:#66d9ef">import</span> java.io.IOException;

<span style="color:#75715e">// Cas 1: Funció mostraFitxer sense 
</span><span style="color:#75715e">// tractament d&#39;excepcipns
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">mostraFitxer</span> (fitxer:String){
    File(fitxer).forEachLine() { println(<span style="color:#66d9ef">it</span>) }
}
</code></pre></div><p>Com veiem, consisteix només a la funció que llegeix un fitxer i el mostra línia per línia. Per a això, fem ús del mètode <code>forEachLine</code>, de la classe <code>File</code>, a la que li passem el fitxer a llegir. Per tal de mostrar cada línia, passem una <em>funció lambda</em> que mostra cadascuna de les línies que retorna <code>forEachLine</code>, fent ús d&rsquo;un argument especial anomenat <code>it</code>. Més endavant veurem què són les funcions <em>lambda</em> i l&rsquo;argument <code>it</code>.</p>
<ul>
<li><strong>Fitxer <code>src/main/java/com/ieschabas/dam/FileReader.java</code></strong></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> com.ieschabas.dam<span style="color:#f92672">;</span>


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FileReader</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span>
    <span style="color:#f92672">{</span>
        <span style="color:#75715e">// Cas 1:  Podem utilitzar directament la funció mostraFitxer
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//         ja que aquesta no llança errors.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//         Si el fitxer no existeix, donarà un 
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//         error d&#39;execució.
</span><span style="color:#75715e"></span>

        MostraFitxerKt<span style="color:#f92672">.</span><span style="color:#a6e22e">mostraFitxer</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/tmp/noexisteix.txt&#34;</span><span style="color:#f92672">);</span>

    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Aquesta classe, que és la que llança l&rsquo;aplicació, al seu mètode main invoca el mètode <code>mostraFitxer</code> de la classe <code>MostraFitxerKt</code>, que és la que generarà el compilador automàticament a partir del codi que hi ha al fitxer <code>mostraFitxer.kt</code>.</p>
<p>Si compilem amb <code>gradle build</code>, no obtindrem cap missatge d&rsquo;error. Si llancem el projecte i el fitxer <code>/tmp/noexisteix.txt</code> sí que existeix, mostrarà aquest per pantalla. Però en cas que no existisca, donarà un error d&rsquo;execució i aturarà aquesta:</p>
<pre><code>$ gradle run

&gt; Task :run FAILED
Exception in thread &quot;main&quot; java.io.FileNotFoundException: /tmp/noexisteix.txt (El fitxer o directori no existeix)
        at java.base/java.io.FileInputStream.open0(Native Method)
        at java.base/java.io.FileInputStream.open(FileInputStream.java:219)
        at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:157)
        at kotlin.io.FilesKt__FileReadWriteKt.forEachLine(FileReadWrite.kt:190)
        at kotlin.io.FilesKt__FileReadWriteKt.forEachLine$default(FileReadWrite.kt:188)
        at com.ieschabas.dam.MostraFitxerKt.mostraFitxer(mostraFitxer.kt:9)
        at com.ieschabas.dam.FileReader.main(FileReader.java:7)

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':run'.
&gt; Process 'command '/usr/lib/jvm/java-11-openjdk-amd64/bin/java'' finished with non-zero exit value 1

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at https://help.gradle.org

BUILD FAILED in 789ms
3 actionable tasks: 1 executed, 2 up-to-date
</code></pre><p>Per tal d&rsquo;evitar aquests errors d&rsquo;execució, tenim les <em>excepcions revisades</em> en Java, que detecten possibles errors en temps de compilació, i ens obliguen a controlar-los amb <code>try-catch</code>. Al següent cas, al mateix exemple, anem a vore com ho faríem per tal que Kotlin indicara que la funció <code>mostraFitxer</code> pot generar una excepció, i conseqüentment hajam de tractar-la des de Java.</p>
<ul>
<li><strong>Fitxer <code>src/main/kotlin/com/ieschabas/dam/mostraFitxer.kt</code></strong></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">package</span> com.ieschabas.dam

<span style="color:#66d9ef">import</span> java.io.File
<span style="color:#66d9ef">import</span> java.io.IOException;

<span style="color:#75715e">// Cas 2: Funció mostraFitxer amb tractament 
</span><span style="color:#75715e">// d&#39;excepcions. 
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">@Throws</span>(IOException<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>)
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">mostraFitxer</span> (fitxer:String){
    File(fitxer).forEachLine() { println(<span style="color:#66d9ef">it</span>) }
}
</code></pre></div><p>En aquest codi, mitjançant <code>@Throws(IOException::class)</code> estem indicant que la funció que anem a definir pot llançar una excepció de tipus IOException. Això farà que quan es compile a bytecode de la JVM siga com si havérem indicat un <code>throws IOException</code> en Java. Açò ens obligarà a capturar aquesta excepció des de la classe principal en Java.</p>
<p>En aquest cas, si compilàrem només amb les modificacions que hem fet al fitxer de Kotlin, obrindríem el següent error de compilació:</p>
<pre><code>$ gradle build

&gt; Task :compileJava FAILED
.../KFileReader/src/main/java/com/ieschabas/dam/FileReader.java:7: error: unreported exception IOException; must be caught or declared to be thrown
        MostraFitxerKt.mostraFitxer(&quot;/tmp/noexisteix.txt&quot;);
                                   ^
1 error
...
</code></pre><p>Aquest error de compilació ens indica que l&rsquo;excepció <code>IOException</code> que llança el mètode <code>mostraFitxer</code> ha de ser tractada amb <code>try-catch</code> o rellançada am un <code>throws</code>. Al nostre cas, Al nostre cas, haurem de capturar-la des de la classe principal de l&rsquo;aplicació en Java.</p>
<p>Veiem ara les modificacions a la classe principal:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> com.ieschabas.dam<span style="color:#f92672">;</span>


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FileReader</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String args<span style="color:#f92672">[])</span>
    <span style="color:#f92672">{</span>
        <span style="color:#75715e">// Cas 2: Per al segon cas, ara sí que se&#39;n obliga a 
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//        capturar l&#39;excepció en temps de compilació.
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
            MostraFitxerKt<span style="color:#f92672">.</span><span style="color:#a6e22e">mostraFitxer</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/tmp/noexisteix.txt&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Exception e<span style="color:#f92672">){</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">getMessage</span><span style="color:#f92672">());</span>
        <span style="color:#f92672">}</span>

    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Amb les modificacions realitzades als dos fitxers font, la compilació ja és correcta, i quan executem, veurem com se&rsquo;ns mostra el missatge d&rsquo;error que hem indicat al <code>catch</code>, en aquest cas, el que torne el <code>getMessage()</code> de la pròpia excepció:</p>
<pre><code>$ gradle run

&gt; Task :run
/tmp/noexisteix.txt (El fitxer o directori no existeix)

BUILD SUCCESSFUL in 784ms
</code></pre><h2 id="6-entrada-i-eixida-des-de-consola">6. Entrada i eixida des de consola</h2>
<p>En Java l&rsquo;entrada i eixida (E/E) es gestiona al paquet <code>java.io</code>, que proporciona un conjunt d&rsquo;streams per llegir i escriure dades, tant a fitxers com a altres tipus de fonts. Per gestionar l&rsquo;eixida i l&rsquo;entrada estàndard, tenim tres tipus de classes:</p>
<ul>
<li>System.in: Entrada estàndard, que proporciona entre d&rsquo;altres el mètode <code>readLine()</code>, per llegir línies d&rsquo;un búffer.</li>
<li>System.out: Eixida estándard, que proporciona els mètodes <code>System.out.print()</code> i <code>System.out.println()</code>.</li>
<li>System.err: Eixida d&rsquo;errors.</li>
</ul>
<p>A més, dins el paquet d&rsquo;utilitats de Java (<code>java.util</code>) tenim la classe <code>java.util.Scanner</code>.</p>
<h3 id="61-exemples-dús-de-readline-i-scanner">6.1. Exemples d&rsquo;ús de readLine i Scanner</h3>
<h4 id="readline">Readline</h4>
<p>Per llegir línies, necessitem un flux d&rsquo;entrada de dades. La manera de llegir una línia des de teclat mitjançant <code>readLine</code> seria la següent:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import</span> java.io.*<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExempleReadLine</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span> String<span style="color:#f92672">[]</span> args <span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        BufferedReader entrada <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedReader <span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> InputStreamReader<span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>

        <span style="color:#66d9ef">try</span><span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Escriu una línia&#34;</span><span style="color:#f92672">);</span>
            String cadena <span style="color:#f92672">=</span> entrada<span style="color:#f92672">.</span><span style="color:#a6e22e">readLine</span><span style="color:#f92672">();</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Has escrit: &#34;</span><span style="color:#f92672">+</span>cadena<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span><span style="color:#f92672">(</span> IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Error de lectura&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>

    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Com veiem, per tal de llegir una línia mijançant <code>readLine</code>, necessitem fer-ho mitjançant un objecte de tipus <code>BufferedReader</code>, generat a partir d&rsquo;un <code>InputStreamReader</code> de l&rsquo;entrada estàndard (<code>System.in</code>). Tot açò ho fem amb la línia:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">BufferedReader entrada <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedReader <span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> InputStreamReader<span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</code></pre></div><p>Per poder llegir la línia posteriorment amb <code>entrada.readLine();</code>.</p>
<p>Cal tindre en compte, que quan llegim de l&rsquo;entrada estàndard (teclat), obtenim dades de tipus <em>String</em>. Per tal d&rsquo;utilitzar altre tipus de dades, utilitzarem els wrappers o classes de cobertura:</p>
<table>
<thead>
<tr>
<th>Wrapper.Mètoode</th>
<th>Tipus bàsic al què es converteix</th>
</tr>
</thead>
<tbody>
<tr>
<td>Byte.parseByte(cadena)</td>
<td>byte</td>
</tr>
<tr>
<td>Short.parseShort(cadena)</td>
<td>short</td>
</tr>
<tr>
<td>Integer.parseInt(cadena)</td>
<td>int</td>
</tr>
<tr>
<td>Long.parseLong(cadena)</td>
<td>long</td>
</tr>
<tr>
<td>Boolean.parseBoolean(cadena)</td>
<td>boolean</td>
</tr>
<tr>
<td>Float.parseFloat(cadena)</td>
<td>float</td>
</tr>
<tr>
<td>Double.parseDouble(cadena)</td>
<td>double</td>
</tr>
<tr>
<td>Character.parseChar(cadena)</td>
<td>char</td>
</tr>
</tbody>
</table>
<h4 id="scanner">Scanner</h4>
<p>El mètode anterior mostra el procés necessari per llegir dades des de l&rsquo;entrada estàndard, però resulta un codi bastant llarg i farragós. Per tal de simplificar el procés de lectura, disposem de la classe <code>Scanner</code>, que a més, ens permet llegir directament valors dels diferents tipus de dades, sense haver d&rsquo;utilitzar <em>wrappers</em></p>
<p>Veiem-ho amb un exemple senzill:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import</span> java.util.Scanner<span style="color:#f92672">;</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExempleScanner</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String arg<span style="color:#f92672">[]){</span>
        Scanner MyScanner <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner<span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">);</span>
        String cadena <span style="color:#f92672">=</span> MyScanner<span style="color:#f92672">.</span><span style="color:#a6e22e">nextLine</span><span style="color:#f92672">();</span>
        String paraula <span style="color:#f92672">=</span> MyScanner<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">int</span> num_enter <span style="color:#f92672">=</span> MyScanner<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">float</span> num_real<span style="color:#f92672">=</span>MyScanner<span style="color:#f92672">.</span><span style="color:#a6e22e">nextFloat</span><span style="color:#f92672">();</span>
   <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Amb aixó, creem un objecte <code>Scanner</code> a partir de l&rsquo;entrada estàndard (<code>System.in</code>) i amb ell, podem llegir tant cadenes(<code>nextLine</code>), paraules (<code>next</code>), o valors enters (<code>nextInt</code>) i en coma flotant (<code>nextFloat</code>).</p>
<h3 id="62-entrada-i-eixida-des-de-consola-en-kotlin">6.2. Entrada i eixida des de consola en Kotlin</h3>
<h4 id="eixida-estàndard">Eixida estàndard</h4>
<p>Per a mostrar informació per l&rsquo;eixida estàndard, Kotlin utilitza les funcions <code>print()</code> i <code>println()</code> de Java. La principal diferència entre les dos, és que <code>println</code> mou el cursos al començament de la pròxima línia, i amb <code>print</code>, el cursos es queda al final de la línia.</p>
<p>Internament, tant <code>print()</code> com <code>println()</code> són crides als mètodes <code>System.out.print()</code> i <code>System.out.println()</code> de Java.</p>
<p>Cal recordar que amb Kotlin, podem fer ús de les <em>template strings</em> (<code>${}</code>) per mostar variables i expressions amb elles:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">println(<span style="color:#e6db74">&#34;cadena&#34;</span>)
println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">$valor</span><span style="color:#e6db74">&#34;</span>)
println(<span style="color:#e6db74">&#34;valor = </span><span style="color:#e6db74">$valor</span><span style="color:#e6db74">&#34;</span>)
println(<span style="color:#e6db74">&#34;valor+3=</span><span style="color:#e6db74">${valor + 3}</span><span style="color:#e6db74">&#34;</span>)
</code></pre></div><h4 id="entrada-estàndard">Entrada estàndard</h4>
<p>Per tal de llegir informació de l&rsquo;entrada estàndard fem ús de la funció <code>readLine()</code>, de la següent manera:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> cadena = readLine()<span style="color:#f92672">!!</span>
</code></pre></div><p>La funció <code>readline()</code> llig l&rsquo;entrada estàndard, i ens retorna un valor de tipus String <em>nullable</em>, és a dir, que pot ser <em>nul</em>. Per tant, per tal d&rsquo;assegurar-nos de tractar correctament aquesta valor de tornada, hem d&rsquo;utilitzar l&rsquo;operador d'<em>asserció no nul</em> <code>!!</code>. D&rsquo;aquesta manera, si el valor que ens retorna <code>readLine()</code> és nul, Kotlin llançaria una excepció de tipus <em>Kotlin null pointer Exception</em>, que pot ser capturada i tractada de forma adeqüada.</p>
<p>Si volem llegir un tipus específic de dades fent ús de <code>readLine()</code>, hauriem de convertir aquests valor de forma explícita, ja que per defecte, ens retorna un <em>String</em>.</p>
<p>Una altra opció interessant, és fer ús de l&rsquo;objecte <code>Scanner</code> de Java. Veiem com l&rsquo;utilitzariem en un exemple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">import</span> java.util.Scanner

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {

    <span style="color:#75715e">// Creem una instància d&#39;Scanner, que agafe com a 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// entrada l&#39;entrada estàndard.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">val</span> reader = Scanner(System.<span style="color:#a6e22e">`in</span><span style="color:#960050;background-color:#1e0010">`</span>)
    print(<span style="color:#e6db74">&#34;Inserix un número: &#34;</span>)

    <span style="color:#75715e">// A l&#39;igual que Java, podem utilitzar nextInt()
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// per llegir un enter del teclat
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> integer:Int = reader.nextInt()

    println(<span style="color:#e6db74">&#34;Has introduït el número: </span><span style="color:#e6db74">$integer</span><span style="color:#e6db74">&#34;</span>)
}
</code></pre></div><h2 id="7-funcions-en-kotlin">7. Funcions en Kotlin</h2>
<p>Kotlin contempla que puguen existir funcions no lligades a objectes, com en altres llenguatges de programació com C o C++.</p>
<p>Aquestes funcions que definim dins un paquet kotlin, però fora d&rsquo;una classe, objecte o interfície es coneixen com <strong>funcions de primer ordre</strong>, o <em><strong>Top-Level functions</strong></em>, i poden ser invocades directament sense necessitat de crear un objecte.</p>
<p>En Java, fem ús de classes d&rsquo;utilitat amb mètodes estàtics per proporcionar funcions no lligades necessàriament a objectes. En Kotlin, les funcions top-level ens donen esta funcionalitat.</p>
<h3 id="71-definició-i-invocació">7.1. Definició i invocació</h3>
<p>Per tal de declarar una funció en Kotlin fem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">nomFuncio</span>(paràmetre1:Tipus1, paràmetre2:Tipus2<span style="color:#f92672">..</span>.):TipusRetorn{
    <span style="color:#75715e">// Cos de la funció
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Veiem algunes característiques sobre la declaració de funcions:</p>
<ul>
<li>Es declaren mitjançant la paraula clau <code>fun</code>,</li>
<li>Els noms comencen amb minúscula, i s&rsquo;expressen en <em>camelCase</em>,</li>
<li>Els paràmetres de la funció s&rsquo;especifiquen rere el nom, entre parèntesi, i de la forma <code>paràmetre:Tipus</code>. Aquests tipus s&rsquo;han d&rsquo;especificar necessàriament.</li>
<li>El tipus de retorn de la funció pot indicar-se després del parèntesi amb la llista d&rsquo;arguments, seguit de <code>:</code>.</li>
<li>Quan la funció no torna cap valor significatiu, el seu <em>Tipus de retorn</em> per defecte és <code>Unit</code>, que seria l&rsquo;equivalent a <code>void</code> en Java o C.</li>
</ul>
<h4 id="valor-per-defecte">Valor per defecte</h4>
<p>Kotlin també admet fer ús de valors per defecte en els paràmetres de les funcions, indicant aquest valor després de declarar el tipus:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">nomFuncio</span>(paràmetre1:Tipus1=Valor1, paràmetre2:Tipus2=Valor2)
</code></pre></div><p>Aquests valors per defecte s&rsquo;utilitzaran quan no es proporcione l&rsquo;argument a la funció.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">saluda</span>(nom: String = <span style="color:#e6db74">&#34;món&#34;</span>, salutacio:String = <span style="color:#e6db74">&#34;Hola&#34;</span>): String {
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">$salutacio</span><span style="color:#e6db74">, </span><span style="color:#e6db74">$nom</span><span style="color:#e6db74">!&#34;</span>
}
</code></pre></div><p><strong>Interoperabilitat amb Java</strong></p>
<p>Java no admet paràmetres per defecte als mètodes, pel que quan s&rsquo;invoque a una funció Kotlin des de Java, s&rsquo;haurien de passar tots es valors dels paràmetres. Kotlin ens ofereix l&rsquo;anotació <code>@JvmOverloads</code> per tal de generar per nosaltres funcions/mètodes sobrecarregats que es puguen invocar des de Java.</p>
<p>L&rsquo;exemple anterior de la funció <code>saluda</code>, en Java passaria a ser:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String <span style="color:#a6e22e">saluda</span><span style="color:#f92672">();</span>
String <span style="color:#a6e22e">saluda</span><span style="color:#f92672">(</span>nom<span style="color:#f92672">);</span>
String <span style="color:#a6e22e">saluda</span><span style="color:#f92672">(</span>nom<span style="color:#f92672">,</span> salutacio<span style="color:#f92672">);</span>
</code></pre></div><h4 id="invocació-de-funcions-i-pas-de-paràmetres">Invocació de funcions i pas de paràmetres</h4>
<p>Per invocar una funció, només hem d&rsquo;utilitzar el seu nom i passar-li entre parèntesi els arguments. El pas de paràmetres es pot fer de dos formes:</p>
<ul>
<li>Pas de paràmetres <strong>posicional</strong>, és a dir, la posició que ocupa l&rsquo;argument en la definició (signatura) de la funció es correspon a la posició en la crida, com es fa en C o Java, i</li>
<li>Pas de paràmetres <strong>per nom</strong>, és a dir, en la invocació a la funció s&rsquo;indica el nom del paràmetre al què es fa referència.</li>
</ul>
<p>Veiem alguns exemples per entendre millor el pas de paràmetres, com funcionen els valor per defecte i algunes restriccions al respecte:</p>
<ul>
<li>Pas de paràmetres <strong>posicional</strong> i <strong>sense</strong> utilitzar <strong>valors per defecte</strong>:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">saluda(<span style="color:#e6db74">&#34;Pep&#34;</span>, <span style="color:#e6db74">&#34;Hello&#34;</span>) <span style="color:#75715e">// =&gt; Hello, Pep!
</span></code></pre></div><ul>
<li>Pas de paràmetres <strong>posicional</strong> i utilitzant <strong>valor per defecte</strong> per a la salutació:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">saluda(<span style="color:#e6db74">&#34;Pep&#34;</span>) <span style="color:#75715e">// =&gt; Hola, Pep!
</span></code></pre></div><ul>
<li>Si volem utilitzar el <strong>nom per defecte</strong> i especificar la salutació, com que aquesta posicionalment es troba en segona posició, caldrà indicar els argumetns <strong>per nom</strong>:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">saluda(salutacio = <span style="color:#e6db74">&#34;Hello&#34;</span>) <span style="color:#75715e">// =&gt; Hello, món!
</span></code></pre></div><ul>
<li>També podem especificar els dos arguments per nom, encara que si estan en el mateix ordre que a la signatura de la funció, no caldria:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">saluda(nom=<span style="color:#e6db74">&#34;Pep&#34;</span>, salutacio = <span style="color:#e6db74">&#34;Hello&#34;</span>) <span style="color:#75715e">// =&gt; Hello, Pep!
</span></code></pre></div><ul>
<li>Amb el posicionament per nom, podem variar l&rsquo;ordre dels arguments:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">saluda(salutacio = <span style="color:#e6db74">&#34;Hello&#34;</span>, nom=<span style="color:#e6db74">&#34;Pep&#34;</span>) <span style="color:#75715e">// =&gt; Hello, Pep!
</span></code></pre></div><ul>
<li>També podem mesclar <strong>arguments de forma posicional</strong>, i altres <strong>amb nom</strong>, sempre i quan els posicionals vagen davant:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">saluda(<span style="color:#e6db74">&#34;Pep&#34;</span>, salutacio = <span style="color:#e6db74">&#34;Hello&#34;</span>) <span style="color:#75715e">// =&gt; Hello, Pep!
</span></code></pre></div><ul>
<li>Ara bé&hellip; <strong>en el moment en què utilitzem algun paràmetre amb nom, tots els que indiquem al darrere, han de ser també amb nom</strong>:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">saluda(salutacio=<span style="color:#e6db74">&#34;Ieee!&#34;</span>, <span style="color:#e6db74">&#34;Pep&#34;</span>)
error: mixing named and positioned arguments <span style="color:#66d9ef">is</span> not allowed
</code></pre></div><ul>
<li>Si quan definim una funció afegim un paràmetre per defecte abans dels paràmetres sense valors per defecte, aquest paràmetre per defecte només es podrà utilitzar si utilitzem la funció amb arguments amb nom. És a dir:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">
<span style="color:#75715e">// si definim `saluda` amb el primer argument per defecte,
</span><span style="color:#75715e">// però no el segon:
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">saluda</span>(nom: String = <span style="color:#e6db74">&#34;món&#34;</span>, salutacio:String): String {
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">$salutacio</span><span style="color:#e6db74">, </span><span style="color:#e6db74">$nom</span><span style="color:#e6db74">!&#34;</span>
}

<span style="color:#75715e">// Per invocar la funció només amb l&#39;argument &#34;salutacio&#34;
</span><span style="color:#75715e">// i utilitzar el valor de nom de defecte, caldrà dir
</span><span style="color:#75715e">// que és &#34;salutacio&#34; l&#39;argument que enviem:
</span><span style="color:#75715e"></span>
saluda(salutacio=<span style="color:#e6db74">&#34;Hello&#34;</span>) <span style="color:#75715e">// --&gt;  Hello, món!
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Si passem només un argument sense nom,
</span><span style="color:#75715e">// s&#39;interpreta com el primer argument, 
</span><span style="color:#75715e">// i com que el segon no té valor per defecte
</span><span style="color:#75715e">// donarà error:
</span><span style="color:#75715e"></span>
saluda(<span style="color:#e6db74">&#34;Hello&#34;</span>) <span style="color:#75715e">// -&gt; error: no value passed for parameter &#39;salutacio&#39;
</span></code></pre></div><h4 id="llista-darguments-variable">Llista d&rsquo;arguments variable</h4>
<p>Quan una funció ha de rebre una quantitat variable d&rsquo;arguments, podem utilitzar la paraula clau <code>vararg</code> davant el nom de la variable, de manera que la funció accepte una llista de paràmetres separats per comes, que el compilador embolicarà en un array:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">escriuLlista</span>(<span style="color:#66d9ef">vararg</span> llista:String){
    <span style="color:#66d9ef">for</span> (item <span style="color:#66d9ef">in</span> llista) println (item);
}

escriuLlista(<span style="color:#e6db74">&#34;param1&#34;</span>, <span style="color:#e6db74">&#34;param2&#34;</span>)
escriuLlista(<span style="color:#e6db74">&#34;param1&#34;</span>, <span style="color:#e6db74">&#34;param2&#34;</span>, <span style="color:#e6db74">&#34;param3&#34;</span>, <span style="color:#e6db74">&#34;param4&#34;</span>)
</code></pre></div><p>En cas que una funció tinga combinats paràmetres d&rsquo;altre tipus amb una llista, el que es fa habitualment és posar primer els arguments d&rsquo;altre tipus, i deixar la llista per al final:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">escriuLlista</span>(desc: Boolean, <span style="color:#66d9ef">vararg</span> llista:String){
    <span style="color:#66d9ef">when</span> (desc){
    <span style="color:#66d9ef">false</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">for</span> (item <span style="color:#66d9ef">in</span> llista) println (item);
    <span style="color:#66d9ef">true</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> llista.size-<span style="color:#ae81ff">1</span> downTo <span style="color:#ae81ff">0</span>) println(llista[i]);
    }
}
escriuLlista(<span style="color:#66d9ef">false</span>, <span style="color:#e6db74">&#34;un&#34;</span>, <span style="color:#e6db74">&#34;dos&#34;</span>, <span style="color:#e6db74">&#34;tres&#34;</span>) <span style="color:#75715e">// --&gt; un dos  tres
</span><span style="color:#75715e"></span>escriuLlista(<span style="color:#66d9ef">true</span>, <span style="color:#e6db74">&#34;un&#34;</span>, <span style="color:#e6db74">&#34;dos&#34;</span>, <span style="color:#e6db74">&#34;tres&#34;</span>) <span style="color:#75715e">// --&gt; tres  dos  un
</span><span style="color:#75715e"></span>
</code></pre></div><p>En cas que volgam posar la llista en primer lloc, haurem d&rsquo;utilitzar paràmetres amb nom per als altres valors:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">escriuLlista</span>(<span style="color:#66d9ef">vararg</span> llista:String, desc: Boolean){
    <span style="color:#66d9ef">when</span> (desc){
    <span style="color:#66d9ef">false</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">for</span> (item <span style="color:#66d9ef">in</span> llista) println (item);
    <span style="color:#66d9ef">true</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> llista.size-<span style="color:#ae81ff">1</span> downTo <span style="color:#ae81ff">0</span>) println(llista[i]);
    }
}
escriuLlista(<span style="color:#e6db74">&#34;un&#34;</span>, <span style="color:#e6db74">&#34;dos&#34;</span>, <span style="color:#e6db74">&#34;tres&#34;</span>, desc=<span style="color:#66d9ef">false</span>) <span style="color:#75715e">// --&gt; un dos  tres
</span><span style="color:#75715e"></span>escriuLlista(<span style="color:#e6db74">&#34;un&#34;</span>, <span style="color:#e6db74">&#34;dos&#34;</span>, <span style="color:#e6db74">&#34;tres&#34;</span>, desc=<span style="color:#66d9ef">true</span>) <span style="color:#75715e">// --&gt; tres  dos  un
</span></code></pre></div><p>Quan no sabem a priori quins valors anem a passr en aquesta llista d&rsquo;arguments -per exemple perquè els ha d&rsquo;introduir l&rsquo;usuari-, solem emmagatzemar aquests valors en estructures com un vector. Per tal de passar aquest vector a una funció que espera una llista variable d&rsquo;arguments, el que farem és <em>estendre</em> aquest vector com a llista variable d&rsquo;arguments, pel al què utilitzarem l'<em>operador d&rsquo;estensió (spread operator)</em>: <code>*</code> davant el nom del vector:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> strArray=arrayOf&lt;String&gt;(<span style="color:#e6db74">&#34;un&#34;</span>, <span style="color:#e6db74">&#34;dos&#34;</span>, <span style="color:#e6db74">&#34;tres&#34;</span>)

<span style="color:#75715e">// Exemple incorrecte, no podem passar el vector directament
</span><span style="color:#75715e"></span>&gt;&gt;&gt; escriuLlista(strArray, desc=<span style="color:#66d9ef">true</span>)
error: type mismatch: inferred type <span style="color:#66d9ef">is</span> Array&lt;String&gt; but String was expected

<span style="color:#75715e">// Sinò que cal estendre aquest en forma de llista d&#39;arguments variable:
</span><span style="color:#75715e"></span>&gt;&gt;&gt; escriuLlista(*strArray, desc=<span style="color:#66d9ef">true</span>)
tres
dos
un
</code></pre></div><h4 id="retorn-de-valors-múltiples">Retorn de valors múltiples</h4>
<p>Quan necessitem que una funció retorne més d&rsquo;un valor, podem englobar aquests en un objecte. Kotlin, ens ofereix, addicionalment els tipus de dades <code>Pair</code> i <code>Triple</code>, que retornen respectivament dos i tres valors, els quals no és necessari ni que siguen del mateix tipus:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">
<span style="color:#75715e">// Aquesta funció realitza la divisió entre dos números i 
</span><span style="color:#75715e">// retorna un parell (Booleà, Enter). El primer valor indica
</span><span style="color:#75715e">// si l&#39;operació és o no correcta, i en cas que siga correcta
</span><span style="color:#75715e">// el segon valor indicarà el resultat (null en cas contrari)
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">divisio</span>(dividendo: Int, divisor:Int): Pair &lt;Boolean?, Int?&gt;{
    <span style="color:#66d9ef">when</span>(divisor){
        <span style="color:#ae81ff">0</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">return</span> Pair(<span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">null</span>)
        <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">return</span> Pair(<span style="color:#66d9ef">true</span>, dividendo/divisor)
    }
}

&gt;&gt;&gt; divisio(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>)
res96: kotlin.Pair&lt;kotlin.Boolean?, kotlin.Int?&gt; = (<span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">null</span>)
&gt;&gt;&gt; divisio(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span>)
res97: kotlin.Pair&lt;kotlin.Boolean?, kotlin.Int?&gt; = (<span style="color:#66d9ef">true</span>, <span style="color:#ae81ff">3</span>)

</code></pre></div><p>En el cas del tipus <em>Pair</em>, podem utilitzar la funció <em>infix</em> <code>to</code> que compacta i fa més legible el codi:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">divisio</span>(dividendo: Int, divisor:Int): Pair &lt;Boolean?, Int?&gt;{
    <span style="color:#66d9ef">when</span>(divisor){
        <span style="color:#ae81ff">0</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span> to <span style="color:#66d9ef">null</span>
        <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span> to dividendo/divisor
    }
}
</code></pre></div><p>En l&rsquo;exemple anterior, potser no li trobem massa senit a la funció <code>to</code>, però si pensem en quan treballem amb dades de tipus <em>clau:valor</em> li podem trobar el sentit. Per exemple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">getHomeVar</span>(): Pair &lt;String?, String?&gt;{
    <span style="color:#66d9ef">when</span>(System.getProperty(<span style="color:#e6db74">&#34;os.name&#34;</span>)){
        <span style="color:#e6db74">&#34;Linux&#34;</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Linux&#34;</span> to <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\$</span><span style="color:#e6db74">HOME&#34;</span>
        <span style="color:#e6db74">&#34;Windows&#34;</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">return</span>  <span style="color:#e6db74">&#34;Windows&#34;</span> to <span style="color:#e6db74">&#34;%USERPROFILE%&#34;</span>
        <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span> to <span style="color:#66d9ef">null</span>
    }
}
</code></pre></div><h4 id="simplificant-funcions">Simplificant funcions</h4>
<p>Quan una funció va a consistir només en una expressió, podem expressar-la de forma més compacta, sense le claus i rere el símbol <code>=</code>.  Veiem per exemple com ho utilitzariem en una funció que converteix euros en l&rsquo;equivalent en dólars:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">euro2dollar</span>(euro:Double):Double{
    <span style="color:#66d9ef">return</span> euro * <span style="color:#ae81ff">1.18</span>;
}
</code></pre></div><p>Aquesta funció es podria haver simplificar en una línia amb:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">euro2dollar</span>(euro:Double):Double = euro*<span style="color:#ae81ff">1.18</span>
</code></pre></div><p>A continuació podem vore altre exemple per vore com saber si un número és parell:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">// Aquesta funció retorna el resultat de l&#39;expressió x%2==0
</span><span style="color:#75715e">// i serà true si x és divisible per 2 i false en cas contrari
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">esParell</span>(x: Int): Boolean = x % <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>

<span style="color:#75715e">// Quan el tipus del resultat es pot inferir de l&#39;expressió,
</span><span style="color:#75715e">// podem no incloure&#39;l en la declaració:
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">esParell</span>(x: Int) = x % <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
</code></pre></div><h4 id="funcions-de-primer-ordre-i-java">Funcions de primer ordre i Java</h4>
<p>Com hem comentat, les funcions que definim fora de qualsevol classe, objecte o interfície, i que poden ser invocades directament, sense haver de crear cap objecte reben el nom de funcions de primer ordre o <em>top-level functions</em>.</p>
<p>Com que Java no suporta aquest tipus de funcions, el compilador de Kotlin genera una classe amb mètode estàtics, que es poden utilitzar des de Java. Aquesta és una pràctica habitual en les llibreríes d&rsquo;utilitats.</p>
<p>Tenim el següent codi Kotlin:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">
<span style="color:#75715e">// Indiquem el nom del fitxer
</span><span style="color:#75715e">// que es generarà (Utils.class)
</span><span style="color:#75715e"></span><span style="color:#a6e22e">@file</span>:JvmName(<span style="color:#e6db74">&#34;Utils&#34;</span>)

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">test1</span>():Unit{
    println(<span style="color:#e6db74">&#34;Funció de test&#34;</span>)
}
</code></pre></div><p>Per tal d&rsquo;utilitzar aquesta funció test1 des de Java, farem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">prova</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Utils<span style="color:#f92672">.</span><span style="color:#a6e22e">test1</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Compilem al mateix directori i executem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kotlinc Utils.kt 
$ javac prova.java 
$ java prova 
Funció de test
</code></pre></div><p>Com podem veure, hem utilitzat funcionalitats definides en Kotlin des de Java, tal i com hem vist anteriorment que també és possible amb projectes Kotlin.</p>
<h3 id="72-expressions-lambda">7.2. Expressions Lambda</h3>
<p>Les <em>expressions lambda</em> (o funcion literals) tampoc estan lligades a classes, objecte o interfícies.</p>
<p>Aquestes funcions es poden passar com a arguments a altres funcions de tipus superior (<em>higher-order functions</em>, no confondre amb les <em>Top-Level functions</em> o funcions de primer ordre). Una expressió lambda representa el bloc d&rsquo;una funció, i simplifica el codi.</p>
<p>En Java se suporten expressions lambda des de Java 8, però en Kotlin són lleugerament diferents.</p>
<p>Característiques de les expressions lambda:</p>
<ul>
<li>S&rsquo;expresa entre {}</li>
<li>No té la paraula clau <code>fun</code></li>
<li>No té modificadors d&rsquo;accés (<code>private</code>, <code>public</code> o <code>protected</code>) ja que no pertany a cap classe</li>
<li>És una funció anònima, que no té nom</li>
<li>No espeficica el tipus de retorn, ja que és inferit pel compilador</li>
<li>Els paràmetres no van entre parèntesi</li>
</ul>
<p>A més, podem assignar una expressió lambda a una variable i executar-la.</p>
<h4 id="creació-dexpressions-lambda">Creació d&rsquo;expressions lambda</h4>
<p>En aquest apartat, anem a vore algunes formes de crear expressions lambda.</p>
<ol>
<li>
<p><strong>Expressió lambda sense paràmetres i assignada a una variable.</strong></p>
<ul>
<li>Declaració:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> msg = { println(<span style="color:#e6db74">&#34;Hola! Sóc una funció lambda&#34;</span>) }
</code></pre></div><ul>
<li>Invocació:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">msg()
</code></pre></div></li>
</ol>
<p>Que és molt semblant a com ho fariem amb nodejs/javascript:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">msg</span><span style="color:#f92672">=</span><span style="color:#66d9ef">function</span>(){<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Funció en js&#34;</span>);}
<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">msg</span>()
</code></pre></div><ol start="2">
<li><strong>Exemple d&rsquo;expressió lambda amb paràmetres:</strong></li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> msg = { cadena: String <span style="color:#f92672">-&gt;</span> println(cadena) }
msg(<span style="color:#e6db74">&#34;Hola Kotlin!&#34;</span>)
msg(<span style="color:#e6db74">&#34;Bon dia!&#34;</span>)
</code></pre></div><p>Hem creat una expressió lambda que rep un paràmetre <code>cadena</code> indicant també el seu tipus (<code>cadena: String</code>). El símbol fletxa (<code>-&gt;</code>) serveix per sepaprar els paràmetres del cos de la funció, que va a la seua dreta. El tipus del paràmetre, també es podria ometre sempre que el compilador el puga inferir:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> msg = { cadena <span style="color:#f92672">-&gt;</span> println(cadena) }	
</code></pre></div><p>En cas de tindre diversos paràmeres, haurem de separar-los amb una coma, i no posar-los entre parèntesi.</p>
<pre><code>val escriuSuma = { s1: Int, s2: Int -&gt;
        println(&quot;Sumem $s1 i $s2&quot;)
        val result = s1 + s2
        println(&quot;La suma és: $result&quot;)
    }
</code></pre><h4 id="pas-dexpressions-lambda-a-funcions">Pas d&rsquo;expressions lambda a funcions</h4>
<p>Podem passar expressions lambda a altre funcions. Estes reben el nom de funcions d&rsquo;ordre superior (higher-order functions), ja que són funcions de funcions, i poden rebre com a arguments tant expressions lambda com funcions anònimes.</p>
<p>Veiem un exemple. Les funcions <code>first()</code> i <code>last()</code> de les col·leccions de Kotlin retornen, respectivament, el primer i l&rsquo;últim element d&rsquo;una llista. Ambdues funcions accepten una expressió lambda com a paràmetre, i aquesta expressió rep un argument de tipus String. El cos d&rsquo;aquesta funció serveix com a predicat per a buscar dins la col·lecció un subconjunt d&rsquo;elements. Açò significa que l&rsquo;expressió lambda és qui decideix quins elements de la col·lecció es tindran en compte quan es busque el primer i l&rsquo;últim:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">// Definim la llista
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> llista: List&lt;String&gt; = listOf(<span style="color:#e6db74">&#34;un&#34;</span>, <span style="color:#e6db74">&#34;dos&#34;</span>, <span style="color:#e6db74">&#34;tres&#34;</span>, <span style="color:#e6db74">&#34;quatre&#34;</span>, <span style="color:#e6db74">&#34;cinc&#34;</span>, <span style="color:#e6db74">&#34;sis&#34;</span>)
<span style="color:#75715e">// Busquem el primer i l&#39;últim element:
</span><span style="color:#75715e"></span>&gt;&gt;&gt; llista.first()
res22: kotlin.String = un
&gt;&gt;&gt; llista.last()
res21: kotlin.String = sis

<span style="color:#75715e">// Afegim una funció lambda, que restringisca esta búsqueda
</span><span style="color:#75715e">// a les cadenes de 4 caràcters:
</span><span style="color:#75715e"></span>&gt;&gt;&gt; llista.first({ s: String <span style="color:#f92672">-&gt;</span> s.length <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>})
res28: kotlin.String = tres

&gt;&gt;&gt; llista.last({ s: String <span style="color:#f92672">-&gt;</span> s.length <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>})
res27: kotlin.String = cinc

</code></pre></div><p>A més, si l&rsquo;ultim argument de la funció és una expressió lamda, Kotlin ens permet eliminar els parèntesis:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">llista.first{ s: String <span style="color:#f92672">-&gt;</span> s.length <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>}
llista.last{ s: String <span style="color:#f92672">-&gt;</span> s.length <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>}
</code></pre></div><p>I fins i tot, podem eliminar el tipus de paràmetre, ja que aquest serà sempre el mateix tipus que els elements de la col·lecció.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">llista.first{ s <span style="color:#f92672">-&gt;</span> s.length <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>}
llista.last{ s <span style="color:#f92672">-&gt;</span> s.length <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>}
</code></pre></div><blockquote>
<p><strong>Exercici resolt</strong></p>
<p>Donada la següent llista:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> llista2: List&lt;String&gt; = listOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>)
</code></pre></div><p>Com obtindríem l&rsquo;últim número imparell i el primer número parell d&rsquo;aquesta?</p>
<p><em><strong>Solució</strong></em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; llista2.first{ s <span style="color:#f92672">-&gt;</span> s%<span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>}
res42: kotlin.Int = <span style="color:#ae81ff">2</span>
&gt;&gt;&gt; llista2.last{ s <span style="color:#f92672">-&gt;</span> s%<span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>}
res43: kotlin.Int = <span style="color:#ae81ff">5</span>
</code></pre></div></blockquote>
<h4 id="el-nom-dargument-it">El nom d&rsquo;argument <code>it</code></h4>
<p>Quan una funció lambda rep un únic argument i el seu tipus pot ser inferit, es genera automàticament un argument per defecte anomenat <code>it</code>, que podem utilitzar-lo per simplificar encara més les expressions. Per exemple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">llista.last{ <span style="color:#66d9ef">it</span>.length <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>}
llista2.last{ <span style="color:#66d9ef">it</span>%<span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> }
</code></pre></div><h4 id="return-en-expressions-lambda">Return en expressions Lambda</h4>
<p>Quan utilitzem un <code>return</code> en una expressió lambda dins una funció, aquest fa referència a la funció on es troba definida l&rsquo;expressió, no a la pròpia funció lambda. Veiem-ho amb un exemple. Amb la següent funció volem mostrar els números d&rsquo;una llista que no són divisibles per 2:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">testReturn</span>() {
    <span style="color:#75715e">// Definim una llista d&#39;enters
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">val</span> intList = listOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>)
    <span style="color:#75715e">// Recorrem aquesta llista amb la funció forEach.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Aquesta funció recorre tots els elements de la llista
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// i executa la funció lambda sobre cada element:
</span><span style="color:#75715e"></span>    intList.forEach {
        <span style="color:#75715e">// Si l&#39;element és divisible per 2, fem un return
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">it</span> % <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span>
        println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">$it</span><span style="color:#e6db74"> no és divisible&#34;</span>);
    }
    println(<span style="color:#e6db74">&#34;Finalitzant testReturn&#34;</span>)
}
 
&gt;&gt;&gt; testReturn()
</code></pre></div><p>El resultat, després d&rsquo;executar la funció només mostra:</p>
<pre><code>1 no és divisible
</code></pre><p>Això es deu a que quan arriba al número 2, que sí que és divisible per 2, executa el <code>return</code>, i aquest, en lloc d&rsquo;eixir de la funció <em>lambda</em>, ix de la funció <code>testReturn()</code>.</p>
<p>Si volem indicar que isca de l&rsquo;expressió lambda, cal fer-ho explícitament fent ús d&rsquo;etiquetes amb:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">testReturn2</span>() {
    <span style="color:#66d9ef">val</span> intList = listOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>)
    intList.forEach {
        <span style="color:#75715e">// Fem un return explícitament de forEach
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">it</span> % <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span><span style="color:#a6e22e">@forEach</span>
        println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">$it</span><span style="color:#e6db74"> no és divisible&#34;</span>);
    }
    println(<span style="color:#e6db74">&#34;Finalitzant testReturn2&#34;</span>)
}
</code></pre></div><p>Ara sí:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; testReturn2()
<span style="color:#ae81ff">1</span> no és divisible
<span style="color:#ae81ff">3</span> no és divisible
<span style="color:#ae81ff">5</span> no és divisible
Finalitzant testReturn2
</code></pre></div><p>A més, per altra banda, també podriem haver definit la nostra etiqueta:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"> intList.forEach <span style="color:#a6e22e">@tornaAci</span> {
     <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">it</span> % <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span><span style="color:#a6e22e">@tornaAci</span>
     <span style="color:#f92672">..</span>}
</code></pre></div><p>Una altra solució a aquest problema sense utilitzar les etiquetes seran les funcions anònimes.</p>
<h3 id="73-funcions-anònimes">7.3. Funcions anònimes</h3>
<p>Les funcions anònimes són altra forma de definir blocs de codi que passem a altres funcions. Les principals característiques d&rsquo;estes funciosn són:</p>
<ul>
<li>No tenen nom,</li>
<li>Es creen amb la paraula clau <code>fun</code>,</li>
<li>contenen un cos de funció</li>
</ul>
<p>Aquestes funcions, a diferència de les lambda, ens permetran indicar el tipus de retorn de la funció. Veiem-ho amb l&rsquo;exemple de <code>last()</code>, on utilitzem una funció anònima en lloc d&rsquo;una expressió lambda:</p>
<pre><code>    llista.last(fun(cadena): Boolean {
     return cadena.length == 3
})
</code></pre><p>Amb funcions anònimes, quan utilitzem un return, sí que ix de la pròpia funció anònima, no de la funció que l&rsquo;englobe, de manera que sí que podem expressar l&rsquo;exemple del <code>forEach()</code> amb:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">fun <span style="color:#a6e22e">testReturn3</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    val intList <span style="color:#f92672">=</span> listOf<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 3<span style="color:#f92672">,</span> 4<span style="color:#f92672">,</span> 5<span style="color:#f92672">)</span>
    intList<span style="color:#f92672">.</span><span style="color:#a6e22e">forEach</span> <span style="color:#f92672">(</span>fun <span style="color:#f92672">(</span>num<span style="color:#f92672">){</span>
        <span style="color:#75715e">// Aquest return farà referència
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// a la funció anònima
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>num<span style="color:#f92672">%</span>2 <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span>
        println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;$num no és divisible&#34;</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">})</span>
    println<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Finalitzant testReturn3&#34;</span><span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="74-funcions-locals-o-nidificades">7.4. Funcions locals o nidificades</h3>
<p>Per tal de modularitzar els nostres programes, a banda de la programació orientada a objectes, Kotlin ens ofereix les funcions locals (o nidificades), que són funcions declarades dins altres funcions, i que tindran sentit dins d&rsquo;aquestes, no fora:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">f1</span>(){
    println(<span style="color:#e6db74">&#34;Dins de f1&#34;</span>)
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">f2</span>(){
        println(<span style="color:#e6db74">&#34;Dins de f2&#34;</span>)
    }
    f2()
}
&gt;&gt;&gt; f1()
Dins de f1
Dins de f2
&gt;&gt;&gt; 

&gt;&gt;&gt; f2()
error: unresolved reference: f2
</code></pre></div><p>Les funcions locals tenen accés a les variables i paràmetres de la funció dins la qual es defineixen, pel que no seria necessari passar estos arguments. Veiem-ho amb un exemple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">var</span> a=<span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">f1</span>():Int{
    <span style="color:#66d9ef">var</span> b=<span style="color:#ae81ff">2</span>
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">f2</span>():Int{
        <span style="color:#66d9ef">var</span> c=<span style="color:#ae81ff">3</span>
        <span style="color:#75715e">// Des d&#39;aci tenim accés
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// a les variables definides
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// fora de la funció.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> (a+b+c)
    }
    <span style="color:#66d9ef">return</span> f2()
}

&gt;&gt;&gt; println(f1())
<span style="color:#ae81ff">6</span>
</code></pre></div><h3 id="75-funcions-dextensió">7.5. Funcions d&rsquo;extensió</h3>
<p>Les funcions d&rsquo;extensió ens permeten agregar noves funcionalitats a classes ja existents sense haver de crer una nova classe que herete de la que volem estendre. Aquestes funcions es declaren fora de les classes, pel que també són funcions de primer nivell (top-level). Kotlin, a més, també admet propietats d&rsquo;extensió.</p>
<p>Per tal de crear una funció d&rsquo;extensió ho farem com una funció comú, però afegint el nom de la classe al davant del nom de la funció. La clase sobre la que fem l&rsquo;extensió s&rsquo;anomenarà <em>tipus de receptor</em>, i anomenarem <em>objecte receptor</em> a la instància de classe o el valor concret sobre el què s&rsquo;invoca a la funció d&rsquo;extensió.</p>
<p>Veiem un exemple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">// Estenem la classe String per comptar el 
</span><span style="color:#75715e">// número de vegades que apareix en ella
</span><span style="color:#75715e">// un caràcter.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">String</span>.countChar(c: Char): Int{
    <span style="color:#66d9ef">var</span> count=<span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">this</span>)
        <span style="color:#66d9ef">if</span> (i<span style="color:#f92672">==</span>c) count<span style="color:#f92672">++</span>
    <span style="color:#66d9ef">return</span> count
}

<span style="color:#66d9ef">var</span> a=<span style="color:#e6db74">&#34;Hola&#34;</span>     <span style="color:#75715e">// Object Receptor
</span><span style="color:#75715e"></span>a.countChar(<span style="color:#e6db74">&#39;a&#39;</span>) <span style="color:#75715e">// -&gt; res189: kotlin.Int = 1
</span><span style="color:#75715e"></span>
a=<span style="color:#e6db74">&#34;babala&#34;</span>        <span style="color:#75715e">// Object Receptor
</span><span style="color:#75715e"></span>a.countChar(<span style="color:#e6db74">&#39;a&#39;</span>) <span style="color:#75715e">// -&gt; res192: kotlin.Int = 3
</span></code></pre></div><h3 id="76-funcions-dordre-superior-o-més-alt-high-order-functions">7.6. Funcions d&rsquo;ordre superior o més alt (*High Order Functions)</h3>
<p>Com hem anticipat, una funció d&rsquo;ordre superior és una aquella que:</p>
<ul>
<li>Rep altra funció (o expressió lambda) com a argument,</li>
<li>Retorna una funció, o</li>
<li>Ambdues coses.</li>
</ul>
<p>A l&rsquo;apartat <a href="###7.2.2.-pas-d'expressions-lambda-a-funcions">sobre el pas d&rsquo;expressions Lambda a funcions</a> hem vist com passar expressions lambda a funcions d&rsquo;ordre superior. Ara, el que vorem és <em><strong>com</strong></em> crear estes funcions.</p>
<p>Reprenent l&rsquo;exemple de pas d&rsquo;euros a dòlars de les expressions lambda, afegim altra funció lambda que convertisca d&rsquo;euros a <em>yens</em>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">euro2dollar</span>(euro:Double):Double = euro*<span style="color:#ae81ff">1.18</span>
<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">euro2yen</span>(euro:Double):Double = euro*<span style="color:#ae81ff">124.68</span>
</code></pre></div><p>A més, anem a definir una funció que anomenarem <code>euroChanger</code>, que rebrà com a primer paràmetre la quantitat en euros, com a segon paràmetre, l&rsquo;expressió lambda que s&rsquo;ha d&rsquo;aplicar.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">euroChanger</span>(euro: Double, op: (Double) <span style="color:#f92672">-&gt;</span> Double): Double {
    <span style="color:#66d9ef">val</span> result = op(euro)
    <span style="color:#66d9ef">return</span> result
}
</code></pre></div><p>Com veiem, aquesta funció retorna un tipus <em>Double</em>, el primer paràmetre que rep (<em>euro</em>) és també de tipus <em>Double</em>, i el segon paràmetre (<em>op</em>) es defineix com una funció que accepta un <em>Double</em> i retorna un <em>Double</em> (<code>op:(Double) -&gt; Double</code>). Solem dir que aquest segon paràmetre és una funció <em>de Double a Double</em>. Una vegada dins la funció, podrem invocar a la funció que s&rsquo;haja passat com a argument amb el nom d&rsquo;aquest (<em>op</em>) i passar-li els argument que necessite.</p>
<p>Per tal d&rsquo;invocar esta funció, cal passar-li com a segon argument una funció amb la mateixa signatura que definim per a l&rsquo;argument (és a dir, de <em>Double a Double</em>). Per tal de passar la funció com a paràmetre, cal afegir al davant <code>::</code> i no utilitzar els parèntesis:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; euroChanger(<span style="color:#ae81ff">12.0</span>, <span style="color:#f92672">::</span>euro2dollar)
res13: kotlin.Double = <span style="color:#ae81ff">14.16</span>
&gt;&gt;&gt; euroChanger(<span style="color:#ae81ff">12.0</span>, <span style="color:#f92672">::</span>euro2yen)
res14: kotlin.Double = <span style="color:#ae81ff">1496.16</span>
</code></pre></div><p>Per altra banda, també podem passar el cos de la funció en la pròpia invocació, i fer ús de l&rsquo;argument autogenerat <code>it</code> de la següent manera:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; euroChanger(<span style="color:#ae81ff">12.0</span>, {<span style="color:#66d9ef">it</span>*<span style="color:#ae81ff">0.9</span>})
res18: kotlin.Double = <span style="color:#ae81ff">10.8</span>
</code></pre></div><p><strong>Retornant funcions</strong></p>
<p>Com hem comentat, a més d&rsquo;admetre funcions com a arguments, les funcions d&rsquo;ordre més alt també poden retornar una funció. Per a això podem fer ús del nom d&rsquo;una funció definida prèviament, i precedida dels <code>::</code>, o bé definir-la com a una funció lambda:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">getFunc</span>(divisa:String): (Double) <span style="color:#f92672">-&gt;</span> Double {
    <span style="color:#66d9ef">when</span>(divisa){
    <span style="color:#e6db74">&#34;dollar&#34;</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">::</span>euro2dollar
    <span style="color:#e6db74">&#34;yen&#34;</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">::</span>euro2yen
    <span style="color:#66d9ef">else</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">return</span> { <span style="color:#66d9ef">it</span>*<span style="color:#ae81ff">0</span> }
    }
}
</code></pre></div><p>Ara ja podem utilitzar-la de la següent forma:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; euroChanger(<span style="color:#ae81ff">12.0</span>, getFunc(<span style="color:#e6db74">&#34;dollar&#34;</span>))
res33: kotlin.Double = <span style="color:#ae81ff">14.16</span>
&gt;&gt;&gt; euroChanger(<span style="color:#ae81ff">12.0</span>, getFunc(<span style="color:#e6db74">&#34;yen&#34;</span>))
res34: kotlin.Double = <span style="color:#ae81ff">1496.16</span>
&gt;&gt;&gt; euroChanger(<span style="color:#ae81ff">12.0</span>, getFunc(<span style="color:#e6db74">&#34;peseta&#34;</span>))
res35: kotlin.Double = <span style="color:#ae81ff">0.0</span>
</code></pre></div><h3 id="77-tancaments-closures">7.7. Tancaments (<em>Closures</em>)</h3>
<p>Un tancament o <em>closure</em> és una funció que pot accedir i modificar variables definides fora del seu àmbit. En altres paraules, es té accés a variables que eren locals, però que ja no estan disponibles en l&rsquo;àmbit.</p>
<p>La forma més senzilla d&rsquo;exemplificar-ho és una funció que retorna una expressió lambda. Quan la funció està executant-se, l&rsquo;expressió lambda té accés a les variables locals definides en la funció, però a més, té accés a elles quan la funció ha finalitzat, i per tant, les variables locals s&rsquo;han destruït. Podem vore-ho com que la funció lambda <em>captura</em> les variables en el tancament.</p>
<p>Veiem-ho amb un exemple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">// Definim una funció que rep un enter
</span><span style="color:#75715e">// i que retornarà una funció que no rep
</span><span style="color:#75715e">// arguments i que no retorna res: ()-&gt;Unit
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">Comptador</span>(ValorInicial:Int):()<span style="color:#f92672">-&gt;</span>Unit{
    <span style="color:#75715e">// Definim una variable local a esta funció,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// i la inicialitzem al valor que ens passen
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> a=ValorInicial
    <span style="color:#75715e">// Aquesta lambda escriu el valor de la
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// variable &#34;a&#34; i la incrementa
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> lambda= {println(a);a=a+<span style="color:#ae81ff">1</span>}
    <span style="color:#75715e">// El què es retorna és la funció lambda
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> lambda
}
</code></pre></div><p>Aquesta funció, bàsicament, ens retorna una funció lambda que no rep arguments ni retorna res, i que, quan la invoquem, escriurà el valor de la variable <code>a</code> i la incrementarà.</p>
<p>Per tal de veure&rsquo;n el funcionament, invocarem a la funció <code>Comptador</code>, i ens guardarem el resultat en una variable:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">var</span> c=Comptador(<span style="color:#ae81ff">0</span>)
<span style="color:#66d9ef">var</span> d=Comptador(<span style="color:#ae81ff">15</span>)
</code></pre></div><p>Ara podrem invocar <code>c</code> com si fos una nova funció, que executarà el contingut de la lambda:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; c() <span style="color:#75715e">// --&gt; 0
</span><span style="color:#75715e"></span>&gt;&gt;&gt; c() <span style="color:#75715e">// --&gt; 1
</span><span style="color:#75715e"></span>&gt;&gt;&gt; c() <span style="color:#75715e">// --&gt; 2
</span><span style="color:#75715e"></span>&gt;&gt;&gt; d() <span style="color:#75715e">// --&gt; 15
</span><span style="color:#75715e"></span>&gt;&gt;&gt; d() <span style="color:#75715e">// --&gt; 16
</span></code></pre></div><p>Com veiem, tot i que la funció <code>Comptador</code> ja no <em>existeix</em>, el valor inicial que li hem donat per crear <code>c</code> i <code>d</code> queda eaccessible en aquestes variables que guarden la funció lambda.</p>
<p>Per altra banda, els tancaments poden treballar tant amb funcions anònimes com amb funcions lambda amb nom. Per tal d&rsquo;utilitzar funcions amb nom, aquesta ha de ser una funció local i accedir a ella a través de l&rsquo;operador <code>::</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">Comptador2</span>(ValorInicial:Int):()<span style="color:#f92672">-&gt;</span>Unit{
    <span style="color:#66d9ef">var</span> a=ValorInicial
    <span style="color:#75715e">// Traiem el contingut de la lambda
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// a una funció amb nom
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">funcioAmbNom</span>(){
        println(a);
        a=a+<span style="color:#ae81ff">1</span>
    }
    <span style="color:#66d9ef">var</span> lambda=<span style="color:#f92672">::</span>funcioAmbNom
    <span style="color:#66d9ef">return</span> lambda
}
</code></pre></div><p>L&rsquo;ús de tancaments i funcions lambda cobra especial importància per definir funciona de <em>callback</em> als gestors d&rsquo;esdeveniments. És a dir, funcions que s&rsquo;executen en el moment en què es produeix determinat esdeveniment, com fer <em>click</em> o <em>tap</em> en un botó o rebre una resposta a una crida remota què hem fet. Aquestes funcions que s&rsquo;executaran com a resposta a determinats esdeveniments (i que reben el nom de callbacks), han d&rsquo;estar preparades per <em>respondre</em> a aquests esdeveniments, però no han de paralitzar la resta d&rsquo;execució. Pensem per exemple en una aplicació que rep una llista d&rsquo;items des d&rsquo;Internet i els mostra per pantalla. Des que es fa la petició per demanar la llista fins que es rep, pot tardar una miqueta, i aquesta espera no deuria paralitzar l&rsquo;aplicació. El que fem és definir una funció de callback que s&rsquo;encarregue de <em>pintar</em> aquests items, i que s&rsquo;executarà en el moment en què rebem la resposta.</p>
<p>Podeu trobar més informació sobre aspectes avançats de funcions en Kotlin a: <a href="https://code.tutsplus.com/es/tutorials/kotlin-from-scratch-advanced-functions--cms-29534">https://code.tutsplus.com/es/tutorials/kotlin-from-scratch-advanced-functions--cms-29534</a></p>
<h2 id="8-programació-orientada-a-objectes">8. Programació orientada a objectes</h2>
<h3 id="81-objectes">8.1. Objectes</h3>
<ul>
<li>Un objecte és una entitat amb certes propietats i determinat comportament.</li>
<li>En termes de POO, les propietats es coneixen com <strong>atributs</strong>, i el conjunt de valors d&rsquo;aquestes determinen l'<strong>estat</strong> de l&rsquo;objecte en un determinat moment.</li>
<li>El comportament, ve determinat per una sèrie de funcions i procediments que anomenem <strong>mètodes</strong>, i que modifiquen l&rsquo;estat de l&rsquo;objecte.</li>
<li>Un objecte tindrà a més un nom pel que s&rsquo;identifica.</li>
</ul>
<h3 id="82-classes">8.2. Classes</h3>
<ul>
<li>Una classe és una abstracció d&rsquo;un conjunt d&rsquo;objectes, i un objecte ha de pertànyer neccessàriament a alguna classe.</li>
<li>Les classes defineixen els atributs i mètodes que posseïran els objectes d&rsquo;aquesta classe.</li>
<li>Un objecte es diu que és una <strong>instància</strong> d&rsquo;una classe.</li>
<li><strong>Exemple</strong>
<ul>
<li>Una classe &ldquo;Persona&rdquo;, que te dos propietats: el nom complet i la data de naixement, i un mètode que calcula l&rsquo;edat en funció de la data de naixement.</li>
<li>D&rsquo;aquesta classe tenim dos instàncies: l&rsquo;objecte Josep, amb any de naixement 1978 i l&rsquo;objecte Joan amb any de naixement 1981.</li>
<li>Quan s&rsquo;utilitze el mètode per calcular l&rsquo;edat, tot i que serà el mateix per a tots els elements de la classe, el resultat serà diferent per a cada objecte, ja que els seus atributs són diferents.</li>
</ul>
</li>
</ul>
<p>Veiem la forma genèrica de definir una classe en Java:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/* Definició d&#39;una classe*/</span>

<span style="color:#f92672">[</span>modeAccés<span style="color:#f92672">]</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">nomClasse</span> <span style="color:#f92672">{</span>

    <span style="color:#75715e">/* Bloc de definició d&#39;atributs */</span>

    <span style="color:#f92672">[</span>nivellAccés<span style="color:#f92672">]</span> tipus atribut_1<span style="color:#f92672">;</span>
    <span style="color:#960050;background-color:#1e0010">…</span>
    <span style="color:#f92672">[</span>nivellAccés<span style="color:#f92672">]</span> tipus atribut_n<span style="color:#f92672">;</span>

    <span style="color:#75715e">/* Definició del Constructor    */</span>

    nomClasse <span style="color:#f92672">(</span>llista_de_paràmetres<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// Inicialització dels atributs, etc.
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/* Definició dels Mèdotes     */</span>
  
    <span style="color:#f92672">[</span>nivellAccés<span style="color:#f92672">]</span> tipus <span style="color:#a6e22e">mètode_1</span> <span style="color:#f92672">(</span>llista_de_paràmetres<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// Cos del mètode
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
    <span style="color:#960050;background-color:#1e0010">…</span>
    <span style="color:#f92672">[</span>nivellAccés<span style="color:#f92672">]</span> tipus <span style="color:#a6e22e">mètode_m</span> <span style="color:#f92672">(</span>llista_de_paràmetres<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// Cos del mètode
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="modes-daccés-de-la-classe">Modes d&rsquo;accés de la classe</h4>
<p>Es tracta de combinacions entre:</p>
<ul>
<li><strong>public / (res)</strong>:
<ul>
<li><em><strong>public</strong></em>: Classe pública, accessible des de qualsevol altra classe. Només pot haver una classe pública en cada fitxer font (ext .java), i ha de tindre el mateix nom que el fitxer.</li>
<li>Si no indiquem res, la classe només podrà ser accedida des del mateix paquet.</li>
</ul>
</li>
<li><strong>abstract / final</strong>: S&rsquo;utilitzen quan fem ús de l&rsquo;herència.
<ul>
<li><em><strong>abstract</strong></em>: La classe no permet la instanaciació d&rsquo;objectes, sinò la definició d&rsquo;altres classes que implementen mètodes que aquesta defineix com a abstractes.</li>
<li><em><strong>final</strong></em>: Classe que implementa els mètodes abstractes, i de la que no es podran crear subclasses.</li>
</ul>
</li>
</ul>
<h4 id="nivell-daccés-a-atributs-i-mètodes">Nivell d&rsquo;accés a atributs i mètodes</h4>
<p>Els atributs i mètodes tenen un tipus de dada (el tipus de dada de l&rsquo;atribut, i el tipus de dada que retorna, en cas dels mètodes), així com un nivell d&rsquo;accés, que determina qui pot o no accedir a ells. Aquest nivell d&rsquo;accés pot ser:</p>
<ul>
<li><strong>public</strong>: Pot accedir-se des de qualsevol lloc.</li>
<li><strong>protected</strong>: Permet l&rsquo;accés des del mateix paquet de la classe i des de les seues subclasses.</li>
<li><em><strong>[no indicar res]</strong></em>: Permet l&rsquo;accés des del mateix paquet de la classe.</li>
<li><strong>private</strong>: Només hi pot accedir la pròpia classe.</li>
</ul>
<p>Algunes consideracions:</p>
<ul>
<li>Per regla general, els atributs solen establir-se com a privats, i s&rsquo;utilitzen mètodes específics (getters i setters), per tal de consultar o establir els valors d&rsquo;aquells atributs als que volem donar accés de forma controlada.</li>
<li>Els mètodes serveixen per comunicar-nos amb els objectes i interactuar amb ells, a través de missatges, que no és més que la invocació als seus mètodes.</li>
<li>El mètode constructor s&rsquo;executa en crear un objecte (amb new), i s&rsquo;usa per inicialitzar l&rsquo;estat de l&rsquo;objecte. Tota classe hauria de tindre, com a mínim, un constructor.</li>
</ul>
<h4 id="nivells-daccés-o-modificadors-de-la-visibilitat-en-kotlin">Nivells d&rsquo;accés o modificadors de la visibilitat en Kotlin</h4>
<p>Kotlin presenta pràcticament els mateixos nivells d&rsquo;accés que Java, però amb les seues peculiaritats:</p>
<ul>
<li><strong>public</strong>: Qualsevol classe, funció, propietat, intefície o objecte públics poden ser accedits des de qualsevol lloc. És el modificador per defecte.</li>
<li><strong>private</strong>: Si s&rsquo;aplica a funcions de nivell superior, interfícies o classes, significa que només poden ser accessibles des del mateix fitxer. Si s&rsquo;aplica a una funció o propietat d&rsquo;una classe, objecte o interfície, aquesta només serà visible per als membres de la mateixa classe, objecte o interfície.</li>
<li><strong>protected</strong>: Només pot aplicar-se a propietats o funcions dins una classe, objecte o interfície, i només seran accessibles des de la pròpia classe i les subclasses.</li>
<li><strong>internal</strong>: Quan treballem en projectes amb mòduls (Gradle o Maven), si definim una classe, objecte, interfície o funció del mòdul con a <em>interna</em>, només serà accessible des del propi mòdul.</li>
</ul>
<h3 id="83-treballant-amb-classes-i-objectes">8.3. Treballant amb classes i objectes</h3>
<ul>
<li>
<p>Creació d&rsquo;un objecte</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">NomClasse NomObjecte <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> NomClasse<span style="color:#f92672">(</span>llista_paràmetres_inicialització<span style="color:#f92672">);</span>
</code></pre></div></li>
<li>
<p>Accés a un objecte</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// Consulta d&#39;un atribut (forma no recomanada)
</span><span style="color:#75715e"></span>Tipus variable <span style="color:#f92672">=</span> NomObjecte<span style="color:#f92672">.</span><span style="color:#a6e22e">atribut</span><span style="color:#f92672">;</span>

<span style="color:#75715e">// Assignació d&#39;un atribut (forma no recomanada)
</span><span style="color:#75715e"></span>NomObjecte<span style="color:#f92672">.</span><span style="color:#a6e22e">atribut</span><span style="color:#f92672">=</span>valor<span style="color:#f92672">;</span>

<span style="color:#75715e">// Accés a un mètode genèric
</span><span style="color:#75715e"></span>TipusRetorn variable<span style="color:#f92672">=</span>NomObjecte<span style="color:#f92672">.</span><span style="color:#a6e22e">mètode</span><span style="color:#f92672">(</span>llista_paràmetres<span style="color:#f92672">);</span>

<span style="color:#75715e">// Accés a atributs mitjançant mètodes
</span><span style="color:#75715e"></span>Tipus Variable <span style="color:#f92672">=</span> NomObjecte<span style="color:#f92672">.</span><span style="color:#a6e22e">GetAtribut</span><span style="color:#f92672">();</span>
NomObjecte<span style="color:#f92672">.</span><span style="color:#a6e22e">SetAtribut</span><span style="color:#f92672">(</span>valor<span style="color:#f92672">);</span>

</code></pre></div></li>
<li>
<p>Referències a atributs de classe.</p>
<ul>
<li><code>this</code> és una referència al propi objecte, que es pot utilitzar des de dins.</li>
<li>Si no hi ha conflicte, podem utilitzar el nom definit a la classe sense problemes.</li>
<li>En cas que, per exemple, un paràmetre d&rsquo;entrada tinga el mateix nom que un atribut de la classe, o que definim una variable local a un mètode amb el mateix nom que l&rsquo;atribut de la classe, sí que caldrà fer ús del <code>this</code> per tal de referenciar el paràmetre de la pròpia classe.</li>
</ul>
</li>
<li>
<p>Eliminació d&rsquo;objectes</p>
<ul>
<li>Tasca del <em>Garbage Collector</em> o recol·lector de fem.</li>
</ul>
</li>
<li>
<p>Encapsulació automàtica amb VS Code:</p>
<ul>
<li>VS Code, quan declarem una variable privada, ens suggereix la creació dels mètodes Getter i Setter per a la variable.</li>
</ul>
</li>
</ul>
<h3 id="84-classes-i-objectes-en-kotlin">8.4. Classes i objectes en Kotlin</h3>
<p>La forma de declarar una classe en Kotlin és semblant a Java, però amb una sintaxi més compacta i versàtil.</p>
<p>En Kotlin podem generar una classe buïda amb:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">nomClasse</span>
</code></pre></div><p>I per crear un objecte o nova instància de la classe ho faríem de forma similar a Java, però sense l&rsquo;operador <code>new</code> (en Kotlin no és una paraula reservada):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> elMeuObjecte=nomClasse()
</code></pre></div><p>Fixeu-se que utilitzem el nom de la classe com si invocàrem directament a una funció.</p>
<p>Per tal de generar una classe que ja continga propietats, mètodes, etc, ho podem fer de diverses formes, anem a vore&rsquo;n unes quantes.</p>
<h4 id="creació-duna-classe-genèrica-amb-el-constructor-secundari">Creació d&rsquo;una classe genèrica amb el <em>constructor secundari</em></h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">nomClasse</span> {
<span style="color:#a6e22e">    [nivellAccés]</span> [<span style="color:#66d9ef">var</span> <span style="color:#960050;background-color:#1e0010">| </span>val] propietat1: TipusPropietat1
    <span style="color:#f92672">..</span>
<span style="color:#a6e22e">    [nivellAccés]</span> [<span style="color:#66d9ef">var</span> <span style="color:#960050;background-color:#1e0010">| </span>val] propietatN: TipusPropietatN

    <span style="color:#66d9ef">constructor</span>(propietat1: TipusPropietat1,<span style="color:#f92672">..</span>.,propietatN: TipusPropietatN){
        <span style="color:#66d9ef">this</span>.propietat1=propietat1;
        <span style="color:#f92672">..</span>.
        <span style="color:#66d9ef">this</span>.propietatN=propietatN;
    }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">    [nivellAccés]</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">metodeX</span>(llista_de_paràmetres): TipusRetorn {
        cos_del_mètode
    }
}
</code></pre></div><p>Veiem algunes peculiaritats:</p>
<ul>
<li>Declarem la classe amb <code>class</code>, igual que amb Java.</li>
<li>La classe té diverses propietats, que poden ser <em>mutables</em> (de lectura-escriptura) si es defineixen amb <code>var</code> o immutables (només de lectura) si es defineixen amb <code>val</code>. Aquestes propietats podran ser públiques (per defecte si no es defineix res), privades o protegides.</li>
<li>El mètode <code>constructor</code> es coneix com <em><strong>constructor secundari</strong></em>, i seria l&rsquo;equivalent al constructor de Java, que s&rsquo;invoca en crear l&rsquo;objecte i realitza les tasques d&rsquo;incicialització d&rsquo;aquest.</li>
<li>Una cosa interessant, és que <strong>no hem de definir mètodes <em>getters</em> i <em>setters</em> ja que aquests són autogenerats pel compilador de Kotlin</strong> per a les propietats públiques, i ens permetran accedir com si accedirem directament a aquestes. Si la propietat és <strong>mutable</strong> (definida amb <code>var</code>), es generarà el <strong>getter</strong> i el <strong>setter</strong> corresponent, mentre que si és <strong>immutable</strong>, només es generarà el <strong>getter</strong>.</li>
<li>Finalment, els mètodes es declaren com si foren una funció local a l&rsquo;objecte, especificant de manera opcional el mètode d&rsquo;accés al davant.</li>
</ul>
<h4 id="creació-duna-classe-genèrica-amb-el-constructor-primari">Creació d&rsquo;una classe genèrica amb el <em>constructor primari</em></h4>
<p>Kotlin permet declarar un constructor en el mateix encapçalament de la classe, anomenat <em>constructor primari</em>. Com que el bloc que definim entre <code>{}</code> després és el bloc de la classe, el bloc de codi corresponent a la inicialització de paràmetres en aquest constructor es fa amb un bloc <code>init</code> que s&rsquo;executa només crear una instància de classe:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">nomClasse</span> <span style="color:#66d9ef">constructor</span>(propietat1: TipusPropietat1,<span style="color:#f92672">..</span>.,propietatN: TipusPropietatN) {
<span style="color:#a6e22e">    [nivellAccés]</span> [<span style="color:#66d9ef">var</span> <span style="color:#960050;background-color:#1e0010">| </span>val] propietat1: TipusPropietat1
    <span style="color:#f92672">..</span>
<span style="color:#a6e22e">    [nivellAccés]</span> [<span style="color:#66d9ef">var</span> <span style="color:#960050;background-color:#1e0010">| </span>val] propietatN: TipusPropietatN

    <span style="color:#66d9ef">init</span> {
        <span style="color:#66d9ef">this</span>.propietat1=propietat1;
        <span style="color:#f92672">..</span>.
        <span style="color:#66d9ef">this</span>.propietatN=propietatN;
    }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">    [nivellAccés]</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">metodeX</span>(llista_de_paràmetres): TipusRetorn {
        cos_del_mètode
    }
}
</code></pre></div><p>Una manera d&rsquo;abreviar més aquesta construcció sería la següent:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">nomClasse</span> <span style="color:#66d9ef">constructor</span>([<span style="color:#66d9ef">var</span> <span style="color:#960050;background-color:#1e0010">| </span>val ] propietat1: TipusPropietat1,<span style="color:#f92672">..</span>.,[<span style="color:#66d9ef">var</span> <span style="color:#960050;background-color:#1e0010">| </span>val ] propietatN: TipusPropietatN) {
<span style="color:#a6e22e">    [nivellAccés]</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">metodeX</span>(llista_de_paràmetres): TipusRetorn {
        cos_del_mètode
    }
}
</code></pre></div><p>En ella hem utilitzat el <em>constructor primari</em>, i hem definit les propietats directament dins d&rsquo;aquest, precedint-les de <code>var</code> o <code>val</code> en funció de que siguen mutables o immutables. En aquesta construcció també podem incloure valors per defecte amb <code>propietatX: TipusPropietatX = &quot;Valor per defecte&quot;</code>, i en cas que la classe no tinga modificador d&rsquo;accés o alguna anotació, podem, fins i tot ometre la paraula <code>constructor</code>.</p>
<h4 id="treballant-amb-objectes">Treballant amb objectes</h4>
<p>Per tal de crear instàncies de la classe ho farem amb:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#a6e22e">[ val | var ]</span> objecte=Classe(Valor_propietat_1, <span style="color:#f92672">..</span>. , Valor_propietat_n)
</code></pre></div><p>Per tal d&rsquo;accedir a les propietats, ho farem directament, a través de la sintaxi d&rsquo;accés a la propietat: <code>objecte.propietat</code>, sense necessitat d&rsquo;invocar explícitament el mètode <em>getter</em>. Per tal d&rsquo;estrablir un valor, sempre que aquest s&rsquo;haja definit com a mutable (amb <code>var</code>) no és necessari el <em>setter</em>, sinò que es pot moificar directament amb l&rsquo;operador <code>=</code>.</p>
<h4 id="personalització-dels-getters-i-setters">Personalització dels getters i setters</h4>
<p>Kotlin permet també personalitzar els mètodes accessors, de manera que puguem bé validar valors en els <em>setters</em> abans de fer l&rsquo;assignació o bé convertir o formatar els valors abans de tornar-los amb un <em>getter</em>.</p>
<p>Per tal de fer això, haurem de definir les propietats dins el cos de la classe, en lloc e fer-ho a la capçalera del constructor, i tot seguit, definir els mètodes get i set corresponents, seguint la següent sintaxi:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">nomClasse</span> (propietat1: TipusPropietat1,<span style="color:#f92672">..</span>., propietatN: TipusPropietatN) {
<span style="color:#a6e22e">    [val | var ]</span> propietat1:TipusPropietat1
    <span style="color:#66d9ef">get</span>(){
        <span style="color:#75715e">// Accedim la propietat
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// amb &#39;field&#39;, no amb el seu nom
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> valor_retorn
    }

    <span style="color:#66d9ef">var</span> propietatN:TipusPropietatN
    <span style="color:#66d9ef">set</span>(value){
        <span style="color:#75715e">// Accedim a la propietat amb &#39;field&#39;
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Per al valor a actualitzar sol usar-se value
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Aci fariem comprovacions amb value
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">field</span>=value <span style="color:#75715e">// Fem el set
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">init</span>{<span style="color:#f92672">..</span>.}
}
</code></pre></div><p>Fixem-nos que així com per a fer un <code>get</code> personalitzat la propietat pot ser mutable o immutable, per fer el <code>set</code>, aquesta ha de ser necessàriament mutable.</p>
<h4 id="interoperabilitat-amb-java-1">Interoperabilitat amb Java</h4>
<p>Com hem comentat, quan definim propietats per als objectes de Kotlin, el compilador genera automàticament els mètodes accessors, de manera que podem accedir a ells directament a través de les propietats.</p>
<p>Quan des de Java utilitzem una classe creada amb Kotlin, per a aquelles propietats que hem definit com a mutables, es generaran els <em>getters</em> i <em>setters</em> corresponents a la propietat (<code>getPropietat()</code> i <code>setPropietat(valor)</code>). Al cas que la propietat siga immutable, Kotlin només ens generarà el <em>getter</em>.</p>
<h4 id="exemple">Exemple</h4>
<p>A moded&rsquo;exemple, anem a veure el projetce Gradle <code>exemplePersones</code>. En ell veurem com crearíem la classe <em>Persona</em> amb tres propietats, el nom, l&rsquo;any de naixement i la professió. El nom i l&rsquo;any de naixement en principi seran immutables, mentre que la professió podrà variar. Les classes <em>Persona2</em>, <em>Persona3</em> i <em>Persona4</em> guarden la mateixa informació, però veiem en elles diferents formes de creació de classes.</p>
<p>Al llarg de l&rsquo;exemple trobareu diferents comentaris autoexplicatius:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">package</span> com.ieschabas.dam.exemplePersones

<span style="color:#66d9ef">import</span> java.time.LocalDateTime

<span style="color:#75715e">/********************************************************
</span><span style="color:#75715e"> * Definició d&#39;una classe amb el constructor secundari  *
</span><span style="color:#75715e"> *******************************************************/</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Persona</span> {
    <span style="color:#75715e">// Definim les propietats
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">val</span> nom: String
    <span style="color:#66d9ef">val</span> anyNaix: Int
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">var</span> professio: String

    <span style="color:#75715e">// Definim el constructor
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">constructor</span>(nom: String, anyNaix: Int, professio: String = <span style="color:#e6db74">&#34;&#34;</span>) {
        <span style="color:#66d9ef">this</span>.nom = nom
        <span style="color:#66d9ef">this</span>.anyNaix = anyNaix
        <span style="color:#66d9ef">this</span>.professio = professio
    }

    <span style="color:#75715e">// AltresMètodes
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">printMe</span>(): Boolean {
        println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">$nom</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${LocalDateTime.now().year - anyNaix}</span><span style="color:#e6db74"> - </span><span style="color:#e6db74">$professio</span><span style="color:#e6db74">&#34;</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    }
}

<span style="color:#75715e">/********************************************************
</span><span style="color:#75715e"> * Definició d&#39;una classe amb el constructor primari    *
</span><span style="color:#75715e"> *******************************************************/</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Persona2</span> <span style="color:#66d9ef">constructor</span>(nom: String, anyNaix: Int, professio: String) {
    <span style="color:#75715e">// Definim les propietats
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">val</span> nom: String
    <span style="color:#66d9ef">val</span> anyNaix: Int
    <span style="color:#66d9ef">var</span> professio: String 

    <span style="color:#75715e">// Bloc init per inicialitzar els objectes
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// El &#39;constructor&#39; està a la definició
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// de la pròpia classe
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">init</span> {
        <span style="color:#75715e">//println(nom+anyNaix+professio);
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.nom = nom
        <span style="color:#66d9ef">this</span>.anyNaix = anyNaix
        <span style="color:#66d9ef">this</span>.professio = professio
    }
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">printMe</span>(): Boolean {
        println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">$nom</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${LocalDateTime.now().year - anyNaix}</span><span style="color:#e6db74"> - </span><span style="color:#e6db74">$professio</span><span style="color:#e6db74">&#34;</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    }
}

<span style="color:#75715e">/********************************************************
</span><span style="color:#75715e"> * Definició d&#39;una classe amb el constructor primari  *
</span><span style="color:#75715e"> *******************************************************/</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Persona3</span> <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">val</span> nom: String, <span style="color:#66d9ef">val</span> anyNaix: Int, <span style="color:#66d9ef">var</span> professio: String = <span style="color:#e6db74">&#34;&#34;</span>) {
    <span style="color:#75715e">// No cal definir les propietats ni init
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// ja que aquestes es defineixen directament en el 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// constructor, predecides de var o val
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// Altres mètodes
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">printMe</span>(): Boolean {
        println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">$nom</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${LocalDateTime.now().year - anyNaix}</span><span style="color:#e6db74"> - </span><span style="color:#e6db74">$professio</span><span style="color:#e6db74">&#34;</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    }
}

<span style="color:#75715e">/********************************************************
</span><span style="color:#75715e"> * Definició d&#39;una classe amb el constructor primari i  *
</span><span style="color:#75715e"> * Accessors (getter i setters) personalitzats.         *
</span><span style="color:#75715e"> *******************************************************/</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Persona4</span> <span style="color:#66d9ef">constructor</span>(nom: String, anyNaix: Int, professio: String) {
    <span style="color:#75715e">// Cal declarar les propietats fora del `consructor`
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// (com hem fet en Persona2)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">val</span> nom: String
    <span style="color:#75715e">// I immediatament després de definir cada propietat,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// generem els mètodes get() o set() com desitgem.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">get</span>() {
        <span style="color:#75715e">// field fa referència al propi camp (atribut)
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// (en aquest cas el retorna en majúscules)
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">field</span>.toUpperCase()
    }
    <span style="color:#66d9ef">var</span> professio: String = <span style="color:#e6db74">&#34;&#34;</span>
    <span style="color:#66d9ef">var</span> anyNaix: Int = LocalDateTime.now().year

    <span style="color:#75715e">// El setter rebrà un &#39;valor&#39; al què actualitzar
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// la propietat. El tipus d&#39;aquest &#39;value&#39; s&#39;infereix
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// del tipus de la propietat que anem a modificar.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">set</span>(value) {
        <span style="color:#75715e">// En aquest cas, comprovem que l&#39;any no siga
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// superior a l&#39;any actual. En eixe cas, llaçariem
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// una excepció.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (value&gt; LocalDateTime.now().year) {
            <span style="color:#66d9ef">throw</span> IllegalArgumentException(<span style="color:#e6db74">&#34;L&#39;any de naixement no pot ser posterior a </span><span style="color:#e6db74">${LocalDateTime.now().year}</span><span style="color:#e6db74">&#34;</span>)
        }
        <span style="color:#75715e">// Accedim a la propietat amb l&#39;alias &#39;field&#39;, i al
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// valor a actualitzar amb &#39;value&#39; 
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">field</span> = value
    }
    <span style="color:#66d9ef">init</span> {
        <span style="color:#66d9ef">this</span>.nom = nom
        <span style="color:#66d9ef">this</span>.professio = professio
        <span style="color:#66d9ef">this</span>.anyNaix = anyNaix
    }
    <span style="color:#66d9ef">fun</span>
    <span style="color:#a6e22e">printMe</span>(): Boolean {
        println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">$nom</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${LocalDateTime.now().year - anyNaix}</span><span style="color:#e6db74"> - </span><span style="color:#e6db74">$professio</span><span style="color:#e6db74">&#34;</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    }
}

<span style="color:#75715e">/*
</span><span style="color:#75715e">Si utilitzàrem només aquest fitxer, de forma autònima i aquesta fora la classe
</span><span style="color:#75715e">principal, crearíem la funció main com s&#39;expressa aci baix.
</span><span style="color:#75715e">Com que anem a crear una altra classe Java per a que llance 
</span><span style="color:#75715e">l&#39;aplicació, aquesta funció està comentada.
</span><span style="color:#75715e">*/</span>

<span style="color:#75715e">/*fun main(args: Array&lt;String&gt;) {
</span><span style="color:#75715e">    val p1 = Persona(&#34;Josep&#34;, 1978, &#34;Profe&#34;)
</span><span style="color:#75715e">    p1.printMe()
</span><span style="color:#75715e">    var p2 = Persona2(&#34;Paco&#34;, 1973, &#34;Profe&#34;)
</span><span style="color:#75715e">    p2.printMe()
</span><span style="color:#75715e">    var p3 = Persona3(&#34;Maria&#34;, 2013, &#34;Estudiant&#34;)
</span><span style="color:#75715e">    p3.printMe()
</span><span style="color:#75715e">    var p4 = Persona4(&#34;Pepica&#34;, 2016, &#34;Estudiant&#34;)
</span><span style="color:#75715e">    p4.printMe()        // Fixeu-bos que el nom ens apareixerà
</span><span style="color:#75715e">                        // directament en majúscules!!
</span><span style="color:#75715e">    p4.anyNaix = 2050   // Llançarà una excepció!
</span><span style="color:#75715e">    p4.printMe()
</span><span style="color:#75715e">}*/</span>

</code></pre></div><p>Fieu-vos que a l&rsquo;exemple de dalt hem comentat la funció principal <code>main</code>, i anem a utilitzar una classe en Java com a classe principal, que utilitze la classe persona definida a dalt:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> com.ieschabas.dam.exemplePersones<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Persones</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Persona p<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Persona<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Jose&#34;</span><span style="color:#f92672">,</span> 1978<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Profe&#34;</span><span style="color:#f92672">);</span>
        p<span style="color:#f92672">.</span><span style="color:#a6e22e">printMe</span><span style="color:#f92672">();</span>

    	Persona2 p2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Persona2<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Paco&#34;</span><span style="color:#f92672">,</span> 1973<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Profe&#34;</span><span style="color:#f92672">);</span>
    	p2<span style="color:#f92672">.</span><span style="color:#a6e22e">printMe</span><span style="color:#f92672">();</span>
    	
	Persona3 p3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Persona3<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Maria&#34;</span><span style="color:#f92672">,</span> 2013<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Estudiant&#34;</span><span style="color:#f92672">);</span>
	p3<span style="color:#f92672">.</span><span style="color:#a6e22e">printMe</span><span style="color:#f92672">();</span>
	
    	Persona4 p4 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Persona4<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Pepica&#34;</span><span style="color:#f92672">,</span> 2016<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Estudiant&#34;</span><span style="color:#f92672">);</span>
	p4<span style="color:#f92672">.</span><span style="color:#a6e22e">printMe</span><span style="color:#f92672">();</span>        <span style="color:#75715e">// Fixeu-vos que el nom ens apareixerà
</span><span style="color:#75715e"></span>                     	   <span style="color:#75715e">// directament en majúscules!!
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//p4.anyNaix = 2050;   // Llançarà una excepció!
</span><span style="color:#75715e"></span>    	p4<span style="color:#f92672">.</span><span style="color:#a6e22e">printMe</span><span style="color:#f92672">();</span>

    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Podeu construïr l&rsquo;exemple i veure&rsquo;n el resultat de l&rsquo;execució.</p>
<h4 id="ús-de-múltiples-constructors">Ús de múltiples constructors</h4>
<p>En Kotlin podem combinar els constructors primaris i secundaris segons les nostres necessitats.</p>
<p>En principi, hi pot haver només un constructor primari, però tants constructors secundaris com desitgem.</p>
<p>Veiem-ho amb un exemple amb la classe <em>PersonaMC</em>. Aquesta classe es troba definida dins els mateixos fonts que l&rsquo;exemple anterior, però no forma part del projecte, pel que haurem de compilar-lo i llançar-lo directament des del mateix directori on es trobe:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#a6e22e">@file</span>:JvmName(<span style="color:#e6db74">&#34;PersonesMC&#34;</span>)

<span style="color:#66d9ef">import</span> java.time.LocalDateTime



<span style="color:#75715e">/********************************************************
</span><span style="color:#75715e"> * Definició d&#39;una classe amb diversos constructors     *
</span><span style="color:#75715e"> *******************************************************/</span>

<span style="color:#75715e">// Deinició de la classe amb constructor primari, que defineix
</span><span style="color:#75715e">// dos propietats immutables, nom i anyNaix
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PersonaMC</span> <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">val</span> nom: String, <span style="color:#66d9ef">val</span> anyNaix: Int) {
    

    <span style="color:#75715e">// Ara definim propietats mutables
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> professio=<span style="color:#e6db74">&#34;&#34;</span>;
    <span style="color:#66d9ef">var</span> poblacio=<span style="color:#e6db74">&#34;&#34;</span>;

    <span style="color:#75715e">// Ara fem ús de diversos constructors secundaris
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// Constructor secundari que rep nom, anyNaix i professio
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Ha de fer referència al constructor primari, fent ús de
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// la paraula reservada &#34;this&#34;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">constructor</span>(nom:String, anyNaix:Int, professio:String):<span style="color:#66d9ef">this</span>(nom, anyNaix){
        <span style="color:#75715e">// Al fer referència al constructor primari, ja donem valor a nom i anyNaix
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Només ens queda professio
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.professio=professio;
    }

    <span style="color:#75715e">// Veiem altre constructor on passem també la població
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">constructor</span>(nom:String, anyNaix:Int, professio:String, poblacio:String):<span style="color:#66d9ef">this</span>(nom, anyNaix){
        <span style="color:#75715e">// Al fer referència al constructor primari, ja donem valor a nom i anyNaix
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Només ens queda professio
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.professio=professio;
        <span style="color:#66d9ef">this</span>.poblacio=poblacio;
    }

   <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">printMe</span>(): Boolean {
        println(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">$nom</span><span style="color:#e6db74"> </span><span style="color:#e6db74">${LocalDateTime.now().year - anyNaix}</span><span style="color:#e6db74"> - </span><span style="color:#e6db74">$professio</span><span style="color:#e6db74"> - </span><span style="color:#e6db74">$poblacio</span><span style="color:#e6db74">&#34;</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    }
}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">val</span> p1 = PersonaMC(<span style="color:#e6db74">&#34;Josep&#34;</span>, <span style="color:#ae81ff">1978</span>)
    <span style="color:#66d9ef">var</span> p2 = PersonaMC(<span style="color:#e6db74">&#34;Paco&#34;</span>, <span style="color:#ae81ff">1973</span>, <span style="color:#e6db74">&#34;Profe&#34;</span>)
    <span style="color:#66d9ef">var</span> p3 = PersonaMC(<span style="color:#e6db74">&#34;Maria&#34;</span>, <span style="color:#ae81ff">2013</span>, <span style="color:#e6db74">&#34;Estudiant&#34;</span>, <span style="color:#e6db74">&#34;Tavernes&#34;</span>)

    p1.printMe()
    p2.printMe()
    p3.printMe()
}

</code></pre></div><p>Per fer la compilació, des del directori <code>/src/main/kotlin/com/ieschabas/dam/exemplePersones</code>, llancem:</p>
<pre><code>$ kotlinc PersonaMC.kt
</code></pre><p>I executem la classe <em>PersonesMC</em>:</p>
<pre><code>$ kotlin PersonesMC
Josep 42 -  - 
Paco 47 - Profe - 
Maria 7 - Estudiant - Tavernes
</code></pre><h4 id="objectes-en-kotlin">Objectes en Kotlin</h4>
<p>Kotlin permet definir objectes sense que hàgen de ser necessàriament instàncies d&rsquo;una classe, tal i com podem fer amb javascript.</p>
<p>Els objectes són semblants a les classes i tenen les següents caracteristiques:</p>
<ul>
<li>Poden tindre propietats, mètodes i un bloc init,</li>
<li>les propietats i mètodes poden tindre modificadors de visibilitat,</li>
<li>No tenen constructors, ja que no són instanciables,</li>
<li>Poden extendre altres classes o implementar interfícies</li>
</ul>
<p>De forma genèrica, definiriem un objecte de la següent forma:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">object</span> <span style="color:#a6e22e">nomObjecte</span> {
<span style="color:#a6e22e">    [nivellAccés]</span> [<span style="color:#66d9ef">var</span> <span style="color:#960050;background-color:#1e0010">| </span>val] propietat1: TipusPropietat1
    <span style="color:#f92672">..</span>
<span style="color:#a6e22e">    [nivellAccés]</span> [<span style="color:#66d9ef">var</span> <span style="color:#960050;background-color:#1e0010">| </span>val] propietatN: TipusPropietatN

    <span style="color:#66d9ef">init</span>{<span style="color:#f92672">..</span>.}
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">    [nivellAccés]</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">metodeX</span>(llista_de_paràmetres): TipusRetorn {
        cos_del_mètode
    }
}
</code></pre></div><p>Com veiem, és molt semblant a una classe, només reemplacem la paraula <code>class</code> per <code>object</code>, i eliminem els constructors.</p>
<p>La utilitat de definir objectes la podem trobar, en aquells casos en què només tindríem una única instància d&rsquo;una classe, com per exemple l&rsquo;objecte <em>Aplicació</em>, la seua configuració (amb definició de constants, com cadenes de connexió a BD, usuaris, etc) o qualsevol objecte que seguisca un patró <em>Singleton</em><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<p>El compilador de Kotlin converteix els objectes en <em>classes <code>final</code></em> de Java, amb un camp estàtic privat <code>INSTANCE</code> que conté una instància única (Singleton) de la classe. Si volem que les funcions o propietats de l&rsquo;objecte siguen definides en aquesta classe com a <code>static</code>, haurem d&rsquo;utilitzar l&rsquo;anotació <code>@JvmStatic</code> al davant.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">object</span> <span style="color:#a6e22e">ObjecteSingleton</span> {
    <span style="color:#a6e22e">@JvmStatic</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">funcio</span>(): Unit {
        <span style="color:#75715e">// cos de la funció
</span><span style="color:#75715e"></span>    }
}
</code></pre></div><p>Podeu ampliar tota aquesta informació sobre objectes al següent tutorial:</p>
<p>*<a href="https://code.tutsplus.com/es/tutorials/kotlin-from-scratch-classes-and-objects--cms-29590">Kotlin Desde Cero: Clases y Objetos</a></p>
<p>I conéixer més coses interessats sobre classes i objectes, com propietats <em>late-initialized</em>, <em>inline</em>, d&rsquo;extensió, etc. en:</p>
<ul>
<li><a href="https://code.tutsplus.com/tutorials/kotlin-from-scratch-advanced-properties-and-classes--cms-29613">Kotlin From Scratch: Advanced Properties and Classes</a></li>
</ul>
<h3 id="85-herència-i-polimorfisme">8.5. Herència i Polimorfisme</h3>
<p>Anem a repassar un parell de mecanismes de reutilització de codi, com són l&rsquo;herència i el polimorfisme, tant des del punt de vista de Java com de Kotlin.</p>
<h4 id="herència">Herència</h4>
<ul>
<li>Mecanisme de reutilització de codi que permet definir classes a partir d&rsquo;altres, <em>heretant</em> les seues propietats i mètodes o redefinint-los, i donant la possibilitat de definir-ne de nous.</li>
<li>Diem subclasse a la classe que hereta propietats d&rsquo;una altra (descendim en la jerarquia de classes), i superclasse a la classe de la qual s&rsquo;hereten propietats (ascendim en la jerarquia de classes).</li>
</ul>
<h5 id="definició-de-lherència-en-java">Definició de l&rsquo;herència en Java</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">nomSubclasse</span> <span style="color:#66d9ef">extends</span>  nomSuperclasse <span style="color:#f92672">{</span>

    <span style="color:#75715e">/* Bloc de definició d&#39;atributs propis de la subclasse*/</span>

    <span style="color:#f92672">[</span>nivellAccés<span style="color:#f92672">]</span> tipus atribut_1<span style="color:#f92672">;</span>
    <span style="color:#960050;background-color:#1e0010">…</span>
    <span style="color:#f92672">[</span>nivellAccés<span style="color:#f92672">]</span> tipus atribut_n<span style="color:#f92672">;</span>

    <span style="color:#75715e">/* Definició del Constructor    */</span>
    nomSubClasse <span style="color:#f92672">(</span>llista_de_paràmetres<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// invoquem el constructor de la superclasse.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Super() ha de ser la 1a ordre.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Si no la posem, invocarà per defecte el constructor
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// de la classe pare sense passar-li paràmetres.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>paràmetres<span style="color:#f92672">);</span>  
        <span style="color:#75715e">// Inicialització dels nous atributs, etc.
</span><span style="color:#75715e"></span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/* Definició de Mèdotes propis de la subclasse  
</span><span style="color:#75715e">       o redefinició de mètodes de la superclasse.
</span><span style="color:#75715e">    */</span>

    <span style="color:#f92672">[</span>nivellAccés<span style="color:#f92672">]</span> tipus <span style="color:#a6e22e">mètode_1</span> <span style="color:#f92672">(</span>llista_de_paràmetres<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// Cos del mètode
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
    <span style="color:#960050;background-color:#1e0010">…</span>
    <span style="color:#f92672">[</span>nivellAccés<span style="color:#f92672">]</span> tipus <span style="color:#a6e22e">mètode_m</span> <span style="color:#f92672">(</span>llista_de_paràmetres<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// Cos del mètode
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="polimorfisme">Polimorfisme</h4>
<p>El polimorfisme comporta <strong>diferent comportament d&rsquo;un mateix mètode segons el context</strong>.</p>
<p>Gràcies al polimorfisme, podem definir un objecte d&rsquo;una classe i instanciar-lo amb classes descendents.</p>
<p>El polimorfisme pot ser de mètodes o d&rsquo;atributs:</p>
<ul>
<li>
<p><strong>Polimorfisme de mètodes</strong>: Permet enviar el mateix missatge a objectes distings, que tractaran de forma diferent:</p>
<ul>
<li><em><strong>Sobrecàrrega basada en paràmetres:</strong></em> Diversos mètodes amb el mateix nom però diferents paràmetres d&rsquo;entrada. Un exemple molt clar és el propi constructor. Segons la invocació, es refereix a un o altre mètode.</li>
<li><em><strong>Sobrecàrrega basada en l&rsquo;àmbit</strong></em>: Diferents classes sense relació poden implementar mètodes amb el mateix nom. Segons la classe sobre la que invoquem el mètode s&rsquo;executarà un o altre.</li>
<li><em><strong>Sobreescriptura</strong></em>: Les classes descendents &ldquo;sobreescriuen&rdquo; els mètodes de les classes ascendents.</li>
</ul>
</li>
<li>
<p><strong>Polimorfisme d&rsquo;atributs</strong>: Relaxació del sistema de tipat que permet que una referència a una classe accepte adreces d&rsquo;obejctes de la mateixa classe i les seues descendents:</p>
<ul>
<li><em><strong>Variables polimòrfiques</strong></em>: Pot referenciar diferents tipus d&rsquo;objectes amb relacions d&rsquo;herència.</li>
</ul>
</li>
</ul>
<p>Algunes consideracions a tindre en compte sobre el polimorfisme <strong>en Java</strong>:</p>
<ul>
<li>Per referir-nos a un mètode o atribut de la classe ascendent fem ús de &ldquo;super&rdquo;:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mètodeClassePare</span><span style="color:#f92672">(</span>paràmetres<span style="color:#f92672">);</span>
</code></pre></div><ul>
<li>Quan sobreescrivim un mètode en una classe descendent, convé utilitzar <strong>@override</strong> davant, de manera que indiquem al programador que aquest mètode reemplaça el de la classe ascendent, i ajudem al compilador a que ens avise si hi ha canvis en la classe pare, com que eliminem el mètode o li canviem el nom.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@override</span>
<span style="color:#f92672">[</span>nivellAccés<span style="color:#f92672">]</span> tipus <span style="color:#a6e22e">mètodeSobreescrit</span> <span style="color:#f92672">(</span>llista_de_paràmetres<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
<span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<p>Per comprovar el tipus de classe d&rsquo;un objecte, podem:</p>
<ul>
<li>Fer ús del mètode getClass:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>objecte<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getSimpleName</span><span style="color:#f92672">().</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span><span style="color:#960050;background-color:#1e0010">“</span>NomClasseAComparar<span style="color:#960050;background-color:#1e0010">”</span><span style="color:#f92672">)))</span> <span style="color:#f92672">{...}</span>
</code></pre></div><ul>
<li>Fer ús de l&rsquo;operador instanceof:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>objecte <span style="color:#66d9ef">instanceof</span> NomClasseAComparar<span style="color:#f92672">){...}</span>
</code></pre></div></li>
</ul>
<h5 id="herència-en-kotlin">Herència en Kotlin</h5>
<p>El principal aspecte a tindre en compte quan pensem en herència en Kotlin, i a diferència de Java, és que les classes es defineixen com a <code>final</code> de manera predeterminada.</p>
<p>Una de les bones pràctiques recomanades per l&rsquo;enginyeria del programari és que totes les classes es definisquen com a finals, i només es deixen coma <em>obertes</em> aquelles que sí que van a tindre herència de forma explícita. Kotlin segueix al peu de la lletra esta recomanació, pel que, per defecte no podrem generar una classe a partir d&rsquo;una altra si la superclasse no es defineix com a <code>open</code>.</p>
<p>Contrastant Kotlin i Java en aquest aspecte, podriem dir que:</p>
<ul>
<li>En <strong>Java</strong> totes les classes són <strong>obertes</strong>, es a dir, <em>es pot heretar d&rsquo;elles</em>, sempre i quan no s&rsquo;indique el contrari especificant-les com a <strong><code>final</code></strong>.</li>
<li>En <strong>Kotlin</strong> totes les classes són <strong>finals</strong>, és a dir, <em><strong>no</strong></em> <em>es pot heretar d&rsquo;elles</em>, sempre i quan no s&rsquo;indique el contrari, especificant-es com a <strong><code>open</code></strong>.</li>
</ul>
<p>Per altra banda, també cal tindre en compte que els mètodes definits a la superclasse, per defecte també són <code>final</code>, pel que, per poder-los sobreescriure, cal indicar-ho també amb <code>open</code>. El mètode sobreescrit a la subclasse, ara seguirà sent <em>open</em>. Si volem evitar açò, podem definir aquest mètode sobreescrit com a <code>final</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/* Cal definir prèviament la superclasse com a open */</span>

<span style="color:#66d9ef">open</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">nomSuperclasse</span> {
    <span style="color:#75715e">// Atributs de la classe
</span><span style="color:#75715e"></span><span style="color:#a6e22e">    [ val | var ]</span> NomAtribut: Tipus;

    <span style="color:#75715e">// Constructor secundari
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">constructor</span>(Args:Tipus) {
        <span style="color:#66d9ef">this</span>.nomAtribut=Param;
        <span style="color:#f92672">..</span>.
    }
    <span style="color:#75715e">// Marquem els mètodes f1 i f2 com
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// a open, per poder-los sobreescriure
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">open</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">f1</span>(Paràmetres:Tipus):TipusRetorn{<span style="color:#f92672">..</span>.}

    <span style="color:#66d9ef">open</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">f2</span>(Paràmetres:Tipus):TipusRetorn{<span style="color:#f92672">..</span>.}

}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">nomSubclasse</span> : nomSuperclasse() {

    <span style="color:#75715e">/* Bloc de definició d&#39;atributs propis de la subclasse*/</span>
<span style="color:#a6e22e">    [ val | var ]</span> NomAtribut: Tipus;

    <span style="color:#75715e">// Constructor secundari
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">constructor</span>(Args:Tipus): <span style="color:#66d9ef">super</span>(Args) {<span style="color:#f92672">..</span>}

    <span style="color:#75715e">// Sobreescrivim el mètode f1 (serà open per defecte)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">f1</span>(Paràmetres:Tipus):TipusRetorn{<span style="color:#f92672">..</span>.}

    <span style="color:#75715e">// Sobreescrivim el mètode f2, i el declarem final
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">f2</span>(Paràmetres:Tipus):TipusRetorn{<span style="color:#f92672">..</span>.}


    <span style="color:#66d9ef">open</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">f1</span>(Paràmetres:Tipus):TipusRetorn{<span style="color:#f92672">..</span>.}

    <span style="color:#75715e">/* Definició de Mèdotes propis de la subclasse  
</span><span style="color:#75715e">       o redefinició de mètodes de la superclasse.
</span><span style="color:#75715e">    */</span>
    <span style="color:#f92672">..</span>.
}
</code></pre></div><p>A l&rsquo;exemple anterior hem vist com utilitzar un constructor secundari. El mecanisme amb constructors primaris seria exactament el mateix.</p>
<p>Algunes coses més a tindre en compte sobre herència en Kotlin:</p>
<ul>
<li>
<p>Teniu disponible l&rsquo;operador <code>is</code>, per comprovar si una variable és d&rsquo;un tipus o classe concret: <code>variable is Classe</code>; així com la seua negació <code>!is</code>: <code>variable !is Classe</code>.</p>
</li>
<li>
<p>Totes les classe en Kotlin són descendents de la classe <code>Any</code>, que equivaldria ai tipus <code>Object</code> de Java. El tipus <code>Any</code> conté tres mètodes: <code>equals</code>, <code>toString</code>, i <code>hasCode</code>. Recordeu que els tipus bàsics també es representen com a classes, pel que també hereten aquests mètodes.</p>
</li>
<li>
<p>Quan es sobreescriu un mètode que té arguments amb valors per defecte a la superclasse, aquests s&rsquo;han d&rsquo;ometre de la signatura de la funció a la subclasse. Els valors per defecte seran sempre els indicats a la superclasse, i no es poden modificar als mètodes sobreescrits.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">open</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">open</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">f1</span>(i: Int = <span style="color:#ae81ff">10</span>) { <span style="color:#f92672">..</span>. }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> : A() {
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">f1</span>(i: Int) { <span style="color:#f92672">..</span>. } 
}
</code></pre></div></li>
</ul>
<h3 id="86-atributs-i-mètodes-estàtics-o-de-classe">8.6. Atributs i mètodes estàtics o de classe</h3>
<p>Els atributs i mètodes estàtics (<code>static</code>) són aquells que s&rsquo;emmagatzemen a la pròpia classe, sent comuns a tots els objectes que s&rsquo;instancien d&rsquo;ella.</p>
<h4 id="atributs-de-classe-o-estàtics-en-java">Atributs de classe o estàtics en Java</h4>
<ul>
<li>Prenen valor en la mateixa classe, de manera que aquest valor és comú a tots els objectes de la mateixa classe.</li>
<li>Usos: Definir constants, variables amb valor comú a tots els objectes, comptadors d&rsquo;objectes de la classe&hellip;</li>
<li>Declaració:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> tipus NomAtribut<span style="color:#f92672">;</span>
<span style="color:#f92672">...</span>
<span style="color:#75715e">// Per accedir a l&#39;atribut fem ús del nom de la classe
</span><span style="color:#75715e"></span>NomClasse<span style="color:#f92672">.</span><span style="color:#a6e22e">NomAtribut</span><span style="color:#f92672">=</span>valor<span style="color:#f92672">;</span>
</code></pre></div><h4 id="mètodes-estàtics">Mètodes estàtics</h4>
<ul>
<li>Poden utilitzar-se directament des de la classe, sense necessitat de crear cap objecte.</li>
<li>Porten el modificador <em>static</em> davant.</li>
<li>No treballen amb objectes, només amb paràmetres d&rsquo;entrada i atributs estàtics.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NomClasse</span><span style="color:#f92672">(){</span>
    <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">static</span> Tipus <span style="color:#a6e22e">NomMètode</span><span style="color:#f92672">(</span>paràmetres<span style="color:#f92672">){</span>
        <span style="color:#f92672">...</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// Per accedir al mètode estàtic des de
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// dins la classe, no indiquem res davant.
</span><span style="color:#75715e"></span>    NomMètode<span style="color:#f92672">(</span>paràmetres<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
<span style="color:#75715e">// Per accedir al mètode estàtic des de
</span><span style="color:#75715e">// fora de la classe fem ús del nom d&#39;aquesta
</span><span style="color:#75715e"></span>NomClasse<span style="color:#f92672">.</span><span style="color:#a6e22e">NomMètode</span><span style="color:#f92672">(</span>paràmetres<span style="color:#f92672">);</span>
</code></pre></div><h4 id="classes-estàtiques-en-kotlin-objectes-complementaris">Classes estàtiques en Kotlin: Objectes complementaris</h4>
<p>Kotlin no suporta mètodes o propietats estàtiques, però ens proporciona una alternativa més potent: els objectes complementaris.</p>
<p>Un <strong>objecte complementari</strong> és un objecte que és membre d&rsquo;un classe (classe <em>acompanyant</em>). Podem dir que és un objecte que <em>acompanya</em> la classe. Recordeu que a Kotlin es poden definir objectes directament, sense ser instància d&rsquo;una classe, per tant, tot el què hem comentat sobre la creació d&rsquo;objectes ens val per als objectes complemetnaris.</p>
<p>El objectes complementaris, a l&rsquo;igual que els mètodes estàtics en Java, estaran associats a la classe que acompanyen, i no a les instàncies d&rsquo;aquesta.</p>
<p>Per tal de crear un objecte complementari seguirem una sintaxi semblant a la del següent exemple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">classeAcompanyant</span> {
    <span style="color:#66d9ef">companion</span> <span style="color:#66d9ef">object</span> {
        <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">f1</span>(){
            println(<span style="color:#e6db74">&#34;Este és un mètode en un objecte complementari&#34;</span>);
        }
    }
}
</code></pre></div><p>Per utilitzar aquest <em>mètode estàtic</em>, farem referència a la classe acompanyant i al mètode en qüestió, igual que fem amb els mètodes estàtics:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">classeAcompanyant.f1()
</code></pre></div><p>Al tutorial <a href="https://code.tutsplus.com/es/tutorials/kotlin-from-scratch-classes-and-objects--cms-29590">Kotlin desde cero: Clases y objetos</a>, teniu a l&rsquo;apartat <em>7. Objetos complementarios</em> una explicació més extensa sobre aquest tipus d&rsquo;objectes, i com crear amb ells classes de tipus <em>Factory</em>.</p>
<h3 id="87-interfícies">8.7. Interfícies</h3>
<ul>
<li>Java no permet l&rsquo;herència múltiple (una classe té més d&rsquo;una classe pare).</li>
<li>Les interfícies són la forma que té Java de fer que classes que no tenen una relació jeràrquica tinguen un comportament comú.</li>
</ul>
<h4 id="classes-i-mètodes-abstractes">Classes i mètodes abstractes</h4>
<ul>
<li><strong>Mètode abstracte</strong>: Aquell que es defineix en una classe, però deixa la seua implementació per a les seues classes descendents (si aquestes no defineixen el mètode també com a abstracte.)</li>
<li><strong>Classe abstracta</strong>: Aquella que conté mètodes abstractes.</li>
<li>Amb açò, el concepte d&rsquo;interfície s&rsquo;acostaria a una classe abstracta, amb la diferència que una classe sí que pot implementar diverses interfícies.</li>
</ul>
<h4 id="definició-dinterfície">Definició d&rsquo;interfície</h4>
<ul>
<li>És una mena de plantilla per a la construcció de classes.</li>
<li>Es compon d&rsquo;un conjunt de declaracions de capçaleres de mètodes sense implementar (com els mètodes abstractes).</li>
<li>Si conté atributs, aquests seran <code>static final</code>, i estaran inicialitzats, ja que funcionaran com a constants.</li>
<li>Especifica un protocol de comportament per a una o diverses classes, de manera que si coneixem que un objecte implementa determinada interfície, sabem quin és el seu comportament, sense importar com s&rsquo;ha realitzat la implementació.</li>
<li>Una classe pot implementar diverses interfícies, proporcionant la declaració i definició de tots els mètodes de cadascuna de les intefícies (o bé declarar-les com a abstractes).</li>
<li>També s&rsquo;usen per declarar constants a utilitzar per altres classes.</li>
</ul>
<h4 id="declaració-duna-interfície">Declaració d&rsquo;una interfície</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IdentificadorInterficie</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">/* Cos de la interfície */</span>

    <span style="color:#75715e">// Constants
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> tipus Identificador <span style="color:#f92672">=</span> Valor<span style="color:#f92672">;</span>
    <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> tipus Identificador_n <span style="color:#f92672">=</span> Valor_n<span style="color:#f92672">;</span>

    <span style="color:#75715e">// Mètodes abstractes
</span><span style="color:#75715e"></span>    TipusRetorn <span style="color:#a6e22e">NomMètodeAImplementar_1</span><span style="color:#f92672">(</span>paràmetres<span style="color:#f92672">);</span>
    <span style="color:#f92672">...</span>
    TipusRetorn <span style="color:#a6e22e">NomMètodeAImplementar_n</span><span style="color:#f92672">(</span>paràmetres<span style="color:#f92672">);</span>

<span style="color:#f92672">}</span>
</code></pre></div><p>Consideracions:</p>
<ul>
<li>Si declarem la interfície com a <code>public</code> ha d&rsquo;estar en un fitxer amb el mateix nom que la interfície (i extensió .java).</li>
<li>Els mètodes es declaren implícitament com a <code>public</code> i <code>abstract</code>.</li>
<li>Les constants incloses en una interfície es declaren com a <code>public</code>, <code>static</code> i <code>final</code>, i s&rsquo;han d&rsquo;inicialitzar en la mateixa declaració.</li>
<li>Quan declarem una interfície, pot utilitzar-se com a tipus de dada, de manera que aquesta es puga reemplaçar per una objecte d&rsquo;una classe que implemente la interfície.</li>
</ul>
<h4 id="implementació-duna-interfície-en-una-classe">Implementació d&rsquo;una interfície en una classe</h4>
<ul>
<li>Cal utilitzar la paraula reservada <code>implements</code> en la declaració.</li>
<li>La capçalera de la interfície ha d&rsquo;apareixer tal qual en la declaració.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NomClasse</span> <span style="color:#66d9ef">implements</span> IdentificadorInterfície<span style="color:#f92672">{</span>

    <span style="color:#75715e">// Implementació dels mètodes de la interfície
</span><span style="color:#75715e"></span>    TipusRetorn <span style="color:#a6e22e">NomMètodeAImplementar_1</span><span style="color:#f92672">(</span>paràmetres<span style="color:#f92672">){</span>
        <span style="color:#75715e">// Implementació
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
    <span style="color:#f92672">...</span>
    TipusRetorn <span style="color:#a6e22e">NomMètodeAImplementar_2</span><span style="color:#f92672">(</span>paràmetres<span style="color:#f92672">){</span>
        <span style="color:#75715e">// Implementació
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="interfícies-en-kotlin">Interfícies en Kotlin</h4>
<p>Per definir	una interfície en Kotlin ho farem de forma similar a Java:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IdentificadorInterficie</span> {
    <span style="color:#75715e">/* Cos de la interfície */</span>

    <span style="color:#75715e">// Constants
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">val</span> Identificador_1:Tipus_1=Valor_1;
    <span style="color:#f92672">..</span>.
    <span style="color:#66d9ef">val</span> Identificador_n:Tipus_n=Valor_n;

    <span style="color:#75715e">// Mètodes abstractes
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">NomMètodeAImplementar_1</span>(paràmetres_1:Tipus_1): TipusRetorn_N;
    <span style="color:#f92672">..</span>.
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">NomMètodeAImplementar_M</span>(paràmetres_N:Tipus_N): TipusRetorn_N;

}
</code></pre></div><p>Per tal de definir una classe que implemente la interfície:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NomClasse</span> : IdentificadorInterfície {

    <span style="color:#75715e">// Implementació dels mètodes de la interfície
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">NomMètodeAImplementar_1</span>(paràmetres_1:Tipus_1): TipusRetorn_N{
        <span style="color:#75715e">// Implementació
</span><span style="color:#75715e"></span>    }
    <span style="color:#f92672">..</span>.
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">NomMètodeAImplementar_M</span>(paràmetres_N:Tipus_N): TipusRetorn_N{
        <span style="color:#75715e">// Implementació
</span><span style="color:#75715e"></span>    }
}
</code></pre></div><p>Alguns aspectes a tenir en compte:</p>
<ul>
<li>No utilitzem cal paraula com <code>implements</code>, sinò que fem ús dels <code>:</code>, com quan definim una subclasse, però sense invocar el constructor <code>()</code>.</li>
<li>Una classe pot implementar tantes interfícies com es desitge, però només pot extendre d&rsquo;un classe (com en Java)</li>
<li>S&rsquo;utilitza, de forma obligada, el modificador <code>override</code> per etiquetar els mètodes i propietats que volem redefinir (en Java l&rsquo;anotació <code>@Override</code> és opcional)</li>
<li>A més dels mètodes, també podem declarar propietats.</li>
<li>Un mètode de la interfície pot tindre una implementació predeterminada, i ser sobreescrita en les classes que la implementen si es desitja, indicant-ho amb <code>override</code>. Si volem utilitzar el mètode de la interfície, podem referir-nos a ella amb <code>super</code>.</li>
<li>Una interfície pot tindre <strong>propietats</strong>, però aquestes <strong>no mantenen l&rsquo;estat</strong> (a diferència de les classes abstractes). És a dir, podem definir la propietat, però no donar-li valor inicial (com fem en Java amb els atributs amb <code>static final</code>). No obstant això, podem tindre mètodes accessors (<code>set</code> i <code>get</code>).</li>
<li>Les propietats també poden redefinir-se amb <code>override</code>.</li>
<li>Quan una classe sobreescriu un mètode amb una implementació predeterminada a la interfície, pot accedir al mètode d&rsquo;aquesta amb <code>super</code>, com si es tractara d&rsquo;una classe ascentdent.</li>
<li>En cas que una classe implemente diverses interfícies, i aquestes tinguen mètodes en comú amb una implementació predeterminada, caldrà especificar, si utilitzem <code>super</code> a quina interfície fem referència mitjançant la notació <code>super&lt;Interficie&gt;.metode()</code>.</li>
</ul>
<p>Veiem un exemple autoexplicat amb alguns d&rsquo;aquests conceptes (<code>interficies/interfaces.kt</code>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">/* Exemple interficies 
</span><span style="color:#75715e">
</span><span style="color:#75715e">    * Definirem dues interfícies, amb mètodes 
</span><span style="color:#75715e">    comuns, i veurem en una classe que implemente les dos
</span><span style="color:#75715e">    com especificar al mètode de quina classe ens referim.
</span><span style="color:#75715e">*/</span>


<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Interface1</span> {

    <span style="color:#75715e">// Mètode abstracte
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">metode1</span>()      
    
    <span style="color:#75715e">// Mètode amb implementació 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// predeterminada
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">metode2</span>(){
        println(<span style="color:#e6db74">&#34;Mètode2 de Interface1&#34;</span>);
    }
}
 
<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Interface2</span> {
    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">metode2</span>(){
        <span style="color:#75715e">// Mètode amb implementació 
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// predeterminada.
</span><span style="color:#75715e"></span>        println(<span style="color:#e6db74">&#34;Mètode3 de Interface2&#34;</span>);
    }
}

<span style="color:#75715e">// Ara definim la classe classe1, que implementa
</span><span style="color:#75715e">// les dues interfícies
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">classe1</span> : Interface1, Interface2 {

    <span style="color:#75715e">// Mètode 1 és abstracte, per tant,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// necessita sobreescriptura.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">metode1</span> () {
        println(<span style="color:#e6db74">&#34;Metode 1 classe1&#34;</span>);       
    }

    <span style="color:#75715e">// El segon mètode, realment, no necessitaria
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// sobreescriptura si no volguérem modificar-ne 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// el funcionament. 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Anem a sobreescriure&#39;l, per veure com 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// accedir als mètodes de les interfícies.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">metode2</span>(){
        println(<span style="color:#e6db74">&#34;Mètode2 de classe1&#34;</span>);
        <span style="color:#75715e">// Amb super podem accedir a la implementació
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// per defecte de la interfície.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Si només disposàrem d&#39;un mètode, no hi hauria
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// dubte, i podriem invocar-lo amb super.metode2();
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Com que hi ha dos classes que l&#39;implementen, 
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// indiquem aquesta entre &lt;&gt;:
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">super</span>&lt;Interface1&gt;.metode2();
        <span style="color:#66d9ef">super</span>&lt;Interface2&gt;.metode2();
    }
}

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">var</span> o1=classe1();
    o1.metode1();
    o1.metode2();
}

</code></pre></div><h3 id="88-paquets-packages">8.8. Paquets (Packages)</h3>
<p>Les aplicacions solen compondre&rsquo;s de diverses classes. En projectes grans o col·laboratius, convé dividir el codi font en diversos fitxers fonts.</p>
<h4 id="organització-de-fitxers-font-en-java">Organització de fitxers font en Java</h4>
<p>A l&rsquo;hora d&rsquo;organitzar els fitxers font en Java, cal tindre en compte alguns aspecte:</p>
<ul>
<li>
<p>Un <em><strong>paquet de Java</strong></em> és un conjunt de classes i interfícies interrelacionades.</p>
</li>
<li>
<p>Les classes i interfícies de la plataforma Java s&rsquo;estructuren en paquets organitzats per funcions i tasques (ex: java.lang, java.io&hellip;).</p>
</li>
<li>
<p>Quan creem una aplicació Java, és convenient agrupar les nostres classes i interfícies en paquets.</p>
</li>
<li>
<p>Per tal d&rsquo;incloure una classe en un paquet, s&rsquo;ha d&rsquo;incloure al principi del fitxer la sentència:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> identificadorDelPaquet<span style="color:#f92672">;</span>
</code></pre></div></li>
<li>
<p>La sentència <code>package</code> afecta tot el fitxer font.</p>
</li>
<li>
<p>Si hi ha diverses clsses en un únic font, només es pot declarar una classe como a pública, i aquesta ha de tindre el mateix nom que el fitxer font. A més, només els components públics hi seran accessibles des de fora del paquet.</p>
</li>
<li>
<p>Si no fem ús de <code>package</code> el que defnim al fitxer correspondrà al paquet per defecte (sense identificador), utilitzat habitualment per a aplicacions menudes.</p>
</li>
</ul>
<h4 id="identificació-dun-paquet-i-accés">Identificació d&rsquo;un paquet i accés</h4>
<p>Java permet fer ús del mateix nom per a diverses classes si aquestes pertànyen a paquets diferents L&rsquo;identificador de la classe anirà precedit per l&rsquo;identificador del paquet. Aquests identificadors compostos es diuen <strong>identificadors qualificats</strong>.</p>
<p>Les empresses i organitzacions solen usar el nom del seu domini d&rsquo;Internet invers per identificar els seus paquets. Per exemple, l&rsquo;empresa amb domini <code>dam.ieschabas.com</code>, nomenaría els seus paquest de la forma: <code>com.ieschabas.dam.*</code></p>
<p>Per tal d&rsquo;accedir als components públics d&rsquo;un paquet podem fer dues coses:</p>
<ol>
<li>Fer ús de l&rsquo;identificador qualificat:</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">com<span style="color:#f92672">.</span><span style="color:#a6e22e">ieschabas</span><span style="color:#f92672">.</span><span style="color:#a6e22e">dam</span><span style="color:#f92672">.</span><span style="color:#a6e22e">NomPaquet</span><span style="color:#f92672">.</span><span style="color:#a6e22e">NomClasse</span> Objecte<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> com<span style="color:#f92672">.</span><span style="color:#a6e22e">ieschabas</span><span style="color:#f92672">.</span><span style="color:#a6e22e">dam</span><span style="color:#f92672">.</span><span style="color:#a6e22e">NomPaquet</span><span style="color:#f92672">.</span><span style="color:#a6e22e">NomClasse</span><span style="color:#f92672">();</span>
</code></pre></div><p>Com veiem es tracta d&rsquo;un nom bastant llarg, pel que s&rsquo;usa així quan fem ús d&rsquo;ell una o molt poques vegades.</p>
<ol start="2">
<li>Importar el component del paquet abans d&rsquo;usar qualsevol classe o interfície i després de la sentència <code>package</code>, si aquesta existeix:</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> com.ieschabas.dam.NomPaquet2<span style="color:#f92672">;</span>
<span style="color:#f92672">import</span> com.ieschabas.dam.NomPaquet1.NomClasse<span style="color:#f92672">;</span>

NomClasse objecte<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> NomClasse<span style="color:#f92672">();</span>
</code></pre></div><p>En cas que hajam d&rsquo;utilitzar els components definits al paquet freqüentment, és convenient fer-ho d&rsquo;aquesta manera.</p>
<p>Si volem importar tots els components d&rsquo;un paquet, farem ús de l&rsquo;asterisc:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import</span> com.ieschabas.dam.NomPaquet1.*<span style="color:#f92672">;</span>
</code></pre></div><p>Per defecte, Java importa automàticament tres paquets:</p>
<ul>
<li>El paquet per defecte (sense identificador)</li>
<li>El paquet java.lang, amb les classes més habituals (Object, Math&hellip;)</li>
<li>El paquet actual de treball (tot allò que definim al mateix directori).</li>
</ul>
<h4 id="recomanacions-per-a-la-gestió-de-fitxers">Recomanacions per a la gestió de fitxers</h4>
<p>L&rsquo;estructura de noms d&rsquo;un paquet està relacionada per l&rsquo;estrucutra de directoris en què dividim el codi, de manera que:</p>
<ul>
<li>El codi font d&rsquo;una classe o interfície es guarda en un fitxer de text amb el mateix identificador que la classe o interfície i extensió <code>.java</code>.</li>
<li>Els fitxers els guardem a una carpeta amb el mateix nom que el paquet al que es correspon la classe o interfície.</li>
</ul>
<p><strong>Exemple</strong></p>
<ul>
<li>La implementació de dues classes (Classe1 i Classe2) i una interfície (Interficie1) del paquet anomentat NomPaquet1, tindría una estructura de carpetes com aquesta:</li>
</ul>
<pre><code>com
`-- ieschabas
    `-- dam
        `-- NomPaquet1
            |-- Classe1.java
            +-- Classe2.java
            `-- Interficie1.java
</code></pre><ul>
<li>Dins de cada fitxer font .java, inclourem el nom del paquet, i el nom de la classe o interfície:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> com.ieschabas.dam.Nompaquet1<span style="color:#f92672">;</span>
<span style="color:#f92672">...</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Classe1</span><span style="color:#f92672">{</span>
    <span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="packages-en-kotlin">Packages en Kotlin</h4>
<p>La declaració de paquets en Kotlin es fa de la mateixa manera que amb Java, indicant el nom al principi del fitxer, de manera que afecte a tot el que definim al fitxer font:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">package</span> com.ieschabas.dam.nomPaquetKotlin
</code></pre></div><p>Com en Java, fem ús de la paraula <code>import</code> per habilitar el compilador per localitzar classes i interfícies, però a més, en Kotlin, també podem importar funcions i objectes.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">import</span> com.ieschabas.dam.nomPaquet.*
</code></pre></div><p>També podem fer el que es coneix com <em>import aliasing</em>, que no és més que donar-li un <em>alias</em> a una classe importada. Açò pot ser d&rsquo;utilitat quan tenim llibreríes amb noms de classe o funcions en conflicte (amb el mateix nom):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">import</span> com.ieschabas.dam.nomPaquet.funcio <span style="color:#66d9ef">as</span> laMeuaFuncio

<span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>(args: Array&lt;String&gt;) {
    laMeuaFuncio()
}
</code></pre></div><h2 id="9-tipus-complexos-de-dades">9. Tipus complexos de dades</h2>
<h3 id="91-vectors-i-matrius">9.1. Vectors i matrius</h3>
<p>Un vector és una col·lecció de dades del mateix tipus, agrupades sota una mateixa variable i que es distingeixen mitjançant la posició (índex) que ocupen. Per la seua banda, una matriu és un vector amb vàries dimensions.</p>
<h4 id="vectors-i-matrius-en-java">Vectors i matrius en Java</h4>
<p>Per tal de definir un vector o matriu en Java fem ús de la notació <code>[]</code>, i podem fer-ho de diverses formes:</p>
<ul>
<li>
<p>Realitzant la declaració primer i després la reserva de memòria:</p>
<ul>
<li>
<p>Declaració:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> v<span style="color:#f92672">[];</span>    ó     <span style="color:#66d9ef">int</span> <span style="color:#f92672">[]</span> v<span style="color:#f92672">;</span>
<span style="color:#66d9ef">int</span> matriu<span style="color:#f92672">[][]</span>   ó   <span style="color:#66d9ef">int</span> <span style="color:#f92672">[][]</span> matriu<span style="color:#f92672">;</span>
</code></pre></div></li>
<li>
<p>Reserva de memòria:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">v<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>num<span style="color:#f92672">];</span>
matriu<span style="color:#f92672">=</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>numX<span style="color:#f92672">][</span>numY<span style="color:#f92672">];</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>Realitzant la declaració i reservant la memòria al mateix temps:</p>
<pre><code>```java
int [] v = new int [num];
int [][] matriu = new int [numX][numY];
```
</code></pre>
</li>
<li>
<p>Realitzant la declaració i assignació de valor (la reserva es fa automàticament):</p>
<pre><code>  ```java
  int [] v = {1, 2, 3}
  int [][] matriu={{1, 2, 3}{4, 5, 6}}
  ```
</code></pre>
</li>
</ul>
<p>Algunes de les operacions que podem realitzar amb vectors són les següents:</p>
<ul>
<li>Còpia</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">System<span style="color:#f92672">.</span><span style="color:#a6e22e">arraycopy</span><span style="color:#f92672">(</span>origen<span style="color:#f92672">,</span> posIniOrigen<span style="color:#f92672">,</span> desti<span style="color:#f92672">,</span> posIniDesti<span style="color:#f92672">,</span>longitud<span style="color:#f92672">);</span>
</code></pre></div><ul>
<li>Comparació</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">java<span style="color:#f92672">.</span><span style="color:#a6e22e">util</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Arrays</span><span style="color:#f92672">.</span><span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>v<span style="color:#f92672">,</span> v2<span style="color:#f92672">)</span>
</code></pre></div><ul>
<li>Recorregut amb <code>for</code></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> item<span style="color:#f92672">:</span>MyArray<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>item<span style="color:#f92672">);}</span>
</code></pre></div><h4 id="vectors-i-matrius-en-kotlin">Vectors i matrius en Kotlin</h4>
<p>Els vectors en Kotlin es representen també amb la classe <code>Array</code>, que ja incorpora els mètodes accessors sobrecarregats per tal d&rsquo;accedir amb <code>[]</code>, i d&rsquo;altre components, com l&rsquo;atribut <code>size</code> que ens indica la longitud.</p>
<p>Per tal de crear un vector, podem utilitzar la funció de llibrería <code>arrayOf</code> de la següent manera:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> barallaTruc = arrayOf(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#e6db74">&#34;Manilla&#34;</span>, <span style="color:#e6db74">&#34;Espasa&#34;</span>, <span style="color:#e6db74">&#34;Bastot&#34;</span>)
</code></pre></div><p>Si ens fixem, a diferència de Java, <strong>els tipus de dades que conté el vector no és necessari que siguen del mateix tipus</strong>. Recordem que Kotlin infereix el tipus de dades. En aquest cas, si detecta que el vector que definim té tipus diferents, defineix aquest com un conjunt d&rsquo;elements ordenats del tipus <code>Any</code>(recordeu que aquest és el tipus base del què descendeixen totes les classes a Kotlin). En canvi, si assignem un tipus concret a tots els elements del vector, Kotlin inferirà que són d&rsquo;aquest tipus.</p>
<p>Per tal d&rsquo;accedir a les diferents posicions del vector, podem fer-ho amb l&rsquo;operador <code>[]</code>, o bé amb <code>get</code> i <code>set</code>. Veiem, alguns exemples de tot açò:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; <span style="color:#66d9ef">val</span> v=arrayOf(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;2&#34;</span>, <span style="color:#ae81ff">3</span>)        <span style="color:#75715e">// Definim un vector
</span><span style="color:#75715e"></span>&gt;&gt;&gt; v[<span style="color:#ae81ff">0</span>]=<span style="color:#e6db74">&#34;element1&#34;</span>                 <span style="color:#75715e">// Modificació de la posició 0 amb []
</span><span style="color:#75715e"></span>&gt;&gt;&gt; v[<span style="color:#ae81ff">0</span>]                            <span style="color:#75715e">// Accés a la posició 0 amb []
</span><span style="color:#75715e"></span>res12: kotlin.Any = element1
&gt;&gt;&gt; v.<span style="color:#66d9ef">set</span>(<span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#34;element1modificat&#34;</span>)   <span style="color:#75715e">// Modificació de la posició 0 amb set
</span><span style="color:#75715e"></span>&gt;&gt;&gt; v.<span style="color:#66d9ef">get</span>(<span style="color:#ae81ff">0</span>)                        <span style="color:#75715e">// Accés a la posició 0 amb get
</span><span style="color:#75715e"></span>res14: kotlin.Any = element1modificat

&gt;&gt;&gt; <span style="color:#66d9ef">val</span> v=arrayOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)          <span style="color:#75715e">// Vector d&#39;enters
</span><span style="color:#75715e"></span>&gt;&gt;&gt; v[<span style="color:#ae81ff">0</span>]=<span style="color:#e6db74">&#34;1&#34;</span>                        <span style="color:#75715e">// Error, el tipus s&#39;ha inferit com a Int
</span><span style="color:#75715e"></span>error: type mismatch: inferred type <span style="color:#66d9ef">is</span> String but Int was expected
v[<span style="color:#ae81ff">0</span>]=<span style="color:#e6db74">&#34;1&#34;</span>
     ^

&gt;&gt;&gt; v[<span style="color:#ae81ff">0</span>]
res18: kotlin.Int = <span style="color:#ae81ff">1</span>               <span style="color:#75715e">// El tipus és Int, no Any
</span></code></pre></div><p>Per altra banda, si volem generar un vector d&rsquo;una longitud determinada, sense assignar valors inicialment, podem utilitzar la funció <code>arrayOfNulls()</code>, que ens generarà un vector de la longitud i el tipus que indiquem amb elements nuls:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> nomVector = arrayOfNulls&lt;Tipus&gt;(longitud)
</code></pre></div><p>Per exemple, per generar un vector de 5 elements de qualsevol tipus (<code>Any</code>), podem fer:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; <span style="color:#66d9ef">val</span> arr = arrayOfNulls&lt;Any&gt;(<span style="color:#ae81ff">5</span>)
</code></pre></div><p>Per altra banda, si volem obtenir una representació del contingut del vector com a cadena de caràcters, podem utilitzar el mètode <code>contentToStrint()</code>:</p>
<pre><code>&gt;&gt;&gt; barallaTruc.contentToString()
res30: kotlin.String = [3, 4, 5, 6, Manilla, Espasa, Bastot]
</code></pre><p>La bliblioteca estàndard de Kotlin ens ofereix també funcions per tal de crear vectors de tipus primitius: <code>intArrayOf()</code>, <code>charArrayOf()</code>, <code>longArrayOf()</code>, etc. que ens retornen una instància de les classes <code>IntArray</code>, <code>CharArray</code>, <code>LongArray</code>&hellip; Amb aquestes classes aconseguim optimitzar el rendiment, ja que evitem costos associats a les operacions de <em>boxing</em> i <em>unboxing</em> (conversió de tipus primitius a classes i viceversa).</p>
<p><strong>Recorrecut de vectors</strong></p>
<p>La classe <em>Array</em> en Kotlin ens ofereix diverses funcions per accedir als elements i als índex d&rsquo;un vector que ens faciliten el seu recorregut.</p>
<p>La forma més senzilla de recórrer un vector és fent ús de l&rsquo;operador <code>in</code> directament sobre el vector, per tal d&rsquo;accedir al seu contingut:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; <span style="color:#66d9ef">val</span> v=arrayOf(<span style="color:#e6db74">&#34;1&#34;</span>, <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;hola&#34;</span>, <span style="color:#66d9ef">false</span>)
&gt;&gt;&gt; <span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> v) println (i)
<span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">2</span>
hola
<span style="color:#66d9ef">false</span>
</code></pre></div><p>També podem accedir als seus índex amb la propietat <code>.indices</code> que ens retorna un rang amb el índex del vector:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; <span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> v.indices) println (i)
<span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">3</span>
</code></pre></div><p>Pel que podríem accedir al contingut també amb:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; <span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> v.indices) println (v[i])
<span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">2</span>
hola
<span style="color:#66d9ef">false</span>
</code></pre></div><p>I si volem accedir al mateix temps als índex i al valor, fem ús del mètode <code>withIndex()</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">&gt;&gt;&gt; <span style="color:#66d9ef">for</span> ((index, valor) <span style="color:#66d9ef">in</span> v.withIndex()) println (<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">$index</span><span style="color:#e6db74"> - </span><span style="color:#e6db74">$valor</span><span style="color:#e6db74">&#34;</span>)
<span style="color:#ae81ff">0</span> - <span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">1</span> - <span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">2</span> - hola
<span style="color:#ae81ff">3</span> - <span style="color:#66d9ef">false</span>
</code></pre></div><h3 id="92-colleccions">9.2. Col·leccions</h3>
<p>Les col·leccions, tant en Java com en Kotlin ens permeten gestionar conjunts d&rsquo;objectes. Anem a fer un repàs sobre el framework de col·leccions en Java, i una introducció a les col·leccions en Kotlin.</p>
<h4 id="colleccions-en-java">Col·leccions en Java</h4>
<p>El framework de col·leccions en Java està composat per diverses interfícies, classes abstractes i classes, que ens ajuden a treballar de diferent forma amb conjunts d&rsquo;objectes.</p>
<p>Al següent diagrama podem vore la relació entre totes aquestes classes i interfícies que componen el framework:</p>
<p><img src="../img/coleccionsJava.png" alt="Jerarquia del framework de col·leccions en Java"></p>
<p>Com veiem, tenim dues interfícies principals: <em>Iterable</em> i <em>Map</em>. La primera ens permet recórrer els elemens mitjançant un <em>iterador</em>, mentre que als <em>Maps</em> ho fem mitjançant claus.</p>
<p>Centrant-nos en la interfície <em>Iterable</em>, d&rsquo;aquesta es deriva la interfície <em>Collecion</em>, que proporciona els mètodes <code>add</code>per afegir elements, <code>remove</code> per eliminar-ne, i <code>clear</code> per eliminar tots els elements. D&rsquo;aquesta interfície <em>Collection</em>, es deriven tres interfícies més, però ens centrarem en dos: <em>Set</em> i <em>List</em>:</p>
<ul>
<li>La interfície <em>Set</em> (conjunt) ens proporciona un conjunt d&rsquo;elements sense duplicats, i els seus elements en principi no tindran cap ordre. Si volem un conjunt ordenat, tenim la interfície <em>SortedSet</em> que deriva d&rsquo;aquesta. El que més ens interessa d&rsquo;aci és la seua classe filla abstracta <em>AbstractSet</em>, i la classe *<strong>HashSet</strong>, que implementa un <strong>conjunt d&rsquo;elements no ordenats i sense duplicats basant-se en hash</strong>, la qual cosa agilitza els accessos.</li>
<li>La interfície <em>List</em>, que ens proporciona una llista d&rsquo;elements ordenats i accessibles a través de la seua posició. D&rsquo;aquesta interfície es deriva la classe abstracta <em>AbstractList</em>, i d&rsquo;aquesta, la classe *<strong>ArrayList</strong> que serà altra de les més utilitzades també.</li>
</ul>
<p>Com veiem, la jerarquia de classes i interfícies per a col·leccions és bastant extensa, però ens centrarem en dues d&rsquo;aquestes classes pel seu interès: <em>HashSet</em> i <em>ArrayList</em>. Anem a veure un parell d&rsquo;exemples d&rsquo;ús comú per recordar com utilitzaríem llistes i conjunts en Java.</p>
<p><strong>Exemple amb ArrayList</strong></p>
<ul>
<li>Definim un objecte de tipus List (classe abstracta) i el creem com a ArrayList que és una implementació d&rsquo;aquesta.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> noms <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
</code></pre></div><ul>
<li>Per tal de poblar la llista, podem utilitzar el mètode add</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">noms<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Pep&#34;</span><span style="color:#f92672">)</span>
noms<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Joan&#34;</span><span style="color:#f92672">)</span>
noms<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Anna&#34;</span><span style="color:#f92672">)</span>
noms<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Maria&#34;</span><span style="color:#f92672">)</span>
noms<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Anna&#34;</span><span style="color:#f92672">)</span>    <span style="color:#75715e">// Podem repetir elements
</span><span style="color:#75715e"></span>noms<span style="color:#f92672">.</span><span style="color:#a6e22e">delete</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Anna&#34;</span><span style="color:#f92672">)</span> <span style="color:#75715e">// Elimina totes les ocurrències
</span><span style="color:#75715e"></span>noms<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Anna&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><ul>
<li>Alternativament, per inicialitzar la llista a partir d&rsquo;un vector, podem utilitzar el mètode Arrays.AsList, que ens torna una llista a partir d&rsquo;un vector, i ens simplifica afegir elements un a un.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">noms <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">[]</span> <span style="color:#f92672">{</span><span style="color:#e6db74">&#34;Pep&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Joan&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Maria&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Anna&#34;</span><span style="color:#f92672">});</span>
</code></pre></div><ul>
<li>Anem a recórrer aquest <code>ArrayList</code> fent ús de l&rsquo;iterador:
<ul>
<li>Inicialitzem un iterator que recorrerà una col·lecció d&rsquo;strings a partir de la llista noms.</li>
<li>La condifió del bucle serà &ldquo;mentre queden elements&rdquo;, cosa que aconseguim amb el mètode <code>.hasnext()</code>.</li>
<li>No posem cap increment al bucle, sinò que utilitzem dins el bucle el mètode <code>next()</code> per obtenir el pròxim element de la col·lecció i mostrar-lo.</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Iterator<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> noms<span style="color:#f92672">.</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span> iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">();</span> <span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    String next <span style="color:#f92672">=</span> iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>next<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Una altra manera de realitzar l&rsquo;exemple anterior més senzilla, sería fer ús de l&rsquo;operador <code>List.of</code> de Java 9, i fer ús de <code>ForEach</code>:</p>
<ul>
<li>Definim amb <code>List.of</code> una llista d&rsquo;elements de tipus String:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> noms<span style="color:#f92672">=</span>List<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Pep&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Joan&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Maria&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Anna&#34;</span><span style="color:#960050;background-color:#1e0010">&#34;</span><span style="color:#f92672">);</span>
</code></pre></div><ul>
<li>I la recorrem amb forEach, fent ús de funcions Lambda.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">noms<span style="color:#f92672">.</span><span style="color:#a6e22e">forEach</span><span style="color:#f92672">((</span>p<span style="color:#f92672">)-&gt;</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>p<span style="color:#f92672">);</span>
    <span style="color:#f92672">});</span>
</code></pre></div><ul>
<li>Aquesta última funció es podría haver abreviat com a:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">noms<span style="color:#f92672">.</span><span style="color:#a6e22e">forEach</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">::</span>println<span style="color:#f92672">);</span>
</code></pre></div><p><strong>Exemple amb HashSet</strong></p>
<ul>
<li>Definim objecte de tipus Set (classe abstracta) i el creem com a HashSet que és una implementació d&rsquo;aquesta.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Set<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> conjuntNoms <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;();</span>
</code></pre></div><ul>
<li>Podem afegir i eliminar elements amb els mètodes que proporciona la interfície <code>Collection</code>:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">conjuntNoms<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Pep&#34;</span><span style="color:#f92672">);</span>
conjuntNoms<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Joan&#34;</span><span style="color:#f92672">);</span>
conjuntNoms<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Maria&#34;</span><span style="color:#f92672">);</span>
conjuntNoms<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Anna&#34;</span><span style="color:#f92672">);</span>
conjuntNoms<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Anna&#34;</span><span style="color:#f92672">);</span> <span style="color:#75715e">// Tornaria false, ja que no es poden repetir elements
</span></code></pre></div><ul>
<li>A més, també podríem haver fet la inicialització amb <code>set.Of</code>:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">conjuntNoms<span style="color:#f92672">=</span>Set<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Pep&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Joan&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Maria&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Anna&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><ul>
<li>Per tal de recórrer-lo, podem optar per un <em>for millorat</em>:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>String nom <span style="color:#f92672">:</span> conjuntNoms<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
       System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>nom<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>O bé a partir de Java 8, podem utilitzar <code>forEach</code>:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">conjuntNoms<span style="color:#f92672">.</span><span style="color:#a6e22e">forEach</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">::</span>println<span style="color:#f92672">);</span>
</code></pre></div><h4 id="colleccions-en-kotlin">Col·leccions en Kotlin</h4>
<p>L&rsquo;API de col·leccions de Kotlin és construeix sobre l&rsquo;API de col·leccions de Java, tal com els ArrayLists, Maps, HasSet, etc. pel que conéixer les col·leccions de Java ens serà de gran utilitat. De tota manera, amb les col·leccions en Kotlin podrem fer més coses amb menys codi.</p>
<p>Anem a donar una ullada a les col·lecions més comunes: <code>List</code>, <code>Set</code> i <code>Map</code>.</p>
<p>De la mateixa manera que les variables, les col·leccions en Kotlin poden ser <em>mutables</em> (podem modificar-la) o impputable (no es pot modificar).</p>
<p>La jerarquía de classes i interfícies de les col·leccions en Kotlin està basada en la de Java:</p>
<p><img src="../img/coleccionsKotlin.png" alt="Col·leccions en Kotlin"></p>
<ul>
<li>
<p>La <strong>interfície <code>Iterable</code></strong> està sobre tota la jerarquia de col·leccions, i permet que els elements puguen ser representats com una seqüència d&rsquo;elements i per tant aquesta puga ser recorreguda amb un <code>Iterator</code>.</p>
</li>
<li>
<p>La <strong>interfície  <code>Collection</code></strong> extén la interfície <code>Iterable</code>, i és <strong>immutable</strong>. Aquesta interfície ens ofereix, entre d&rsquo;altres les següent funcions i propietats:</p>
<ul>
<li><code>size</code>: Amb la longitud de la col·lecció,</li>
<li><code>isEmpty()</code>: Tornant cert si la col·lecció no conté elements,</li>
<li><code>contains(element:E)</code>: Ens torna cert si l&rsquo;element especificat (de tipus E) es troba a la col·lecció.</li>
<li><code>containsAll(element: Collection&lt;E&gt;)</code>: Ens torna cert si la la col·lecció conte <strong>tots</strong> els elements de la col·lecció especificada com a argument.</li>
</ul>
</li>
<li>
<p>Les <strong>interfícies <code>Set</code> i <code>List</code></strong> extenen la interfície <code>Collection</code>.</p>
</li>
<li>
<p>La <strong>interfície <code>MutableIterable</code></strong> extén directament també d'<code>Iterable</code>, i ofereix un iterador mutable especialitzat d&rsquo;aquesta interfície pare.</p>
</li>
<li>
<p>La <strong>interfície <code>MutableCollection</code></strong> habilita les col·leccions per tal que puguen ser mutables, i per tant, puguem modificar, afegir o eliminar valors. Aquesta interfície estén tant de la interfície <code>Collection</code> com de la interfície <code>MutableIterable</code>. Aquesta interfície ofereix els mètodes:</p>
<ul>
<li><code>add(element: E)</code>: Afig l&rsquo;element i torna cert si s&rsquo;ha afegit correctament o fals si no s&rsquo;ha afegit (per exemple si no s&rsquo;admeten duplicats i ja existeix l&rsquo;element),</li>
<li><code>remove(element: E)</code>: Elimina l&rsquo;element que passem com a argument. Torna cert si s&rsquo;elimina i fals si no estava a la col·lecció.</li>
<li><code>addAll(elements: Collection&lt;E&gt;)</code>: Afig tots els elements elements de la col·lecció que passem com a argument a la col·lecció en qüestió. Tornarà fals si no s&rsquo;ha afegit cap element.</li>
<li><code>removeAll(elements: Collection&lt;E&gt;)</code>: Elimina tots els elements de la col·lecció que estan a la col·lecció que passem com a argument. Tornarà fals si no s&rsquo;elimina res.</li>
<li><code>retainAll(elements: Collection&lt;E&gt;)</code>: Reté només els elements presents en les col·leccions, eliminant la resta d&rsquo;elements si aquests existien. Tornarà fals si no reté res.</li>
<li><code>clear()</code>: Elimina tots els elements de la col·lecció.</li>
</ul>
</li>
<li>
<p>Les <strong>interfícies <code>MutableSet</code> i <code>MutableList</code></strong> extenen la interfície <code>MutableCollection</code>.</p>
</li>
</ul>
<h5 id="llistes-en-kotlin">Llistes en Kotlin</h5>
<p>Per crear una llista en Kotlin podem fer ús de la funció <code>listOf()</code>, que torna una <strong>llista immutable</strong> d&rsquo;un tipus que implemente la interfície <code>List</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">var</span> noms: List&lt;String&gt; = listOf(<span style="color:#e6db74">&#34;Pep&#34;</span>, <span style="color:#e6db74">&#34;Joan&#34;</span>, <span style="color:#e6db74">&#34;Anna&#34;</span>, <span style="color:#e6db74">&#34;Maria&#34;</span>)
</code></pre></div><p>Per recórrer la llista i imprimir els elements fariem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">for</span> (name <span style="color:#66d9ef">in</span> names) {
    println(name)
}
</code></pre></div><p>Amb la funció <code>listOf</code> també podem generar una llista d&rsquo;elements de diversos tipus, sense especificar el tipus base de la llista:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> llistaMixta = listOf(<span style="color:#e6db74">&#34;cadena1&#34;</span>, <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#ae81ff">1</span>)
</code></pre></div><p>Recordeu que aquestes llistes són immutables, i per tant no es poden modificar.</p>
<p>Algunes altres funcions que generen llistes immutables són:</p>
<ul>
<li><code>emptyList()</code>: Crea una llista immutable buïda.</li>
<li><code>listOfNotNull()</code>: Crea una llista immutable amb només els elements no nuls. És a dir, elimina els nuls de la llista que li passem (Ex.: <code>val nonNullsList: List&lt;String&gt; = listOfNotNull(2, 45, 2, null, 5, null)</code>)</li>
</ul>
<p>Per altra banda, la interfície també ofereix els mètodes:</p>
<ul>
<li><code>Lista.contains(element:E)</code>: Torna cert si la llista conté l&rsquo;element indicat.</li>
<li><code>Llista.get(index: Int)</code>: Torna l&rsquo;element en l&rsquo;índex especificat,</li>
<li><code>Llista.indexOf(element:E)</code>: Retorna l&rsquo;índex de la primer aparició de l&rsquo;element a la llista, o -1 si no es troba.</li>
<li><code>Llista.lastIndexOf(element:E)</code>: Retorna l&rsquo;índex de la última aparició de l&rsquo;element en la llista, o -1 si no es troba.</li>
<li><code>Llista.listIterator()</code>: Retorna un <code>Iterator</code> sobre els elements de la llista.</li>
<li><code>Llista.sublist(fromIndex: Int, toIndex: Int)</code>: Retorna una llista que conté una part de la llista original, compresa entre els índex indicats.</li>
</ul>
<p>Veiem alguns exemples:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">// noms =  [Pep, Joan, Anna, Maria]
</span><span style="color:#75715e"></span>noms.<span style="color:#66d9ef">get</span>(<span style="color:#ae81ff">1</span>) <span style="color:#75715e">// Joan
</span><span style="color:#75715e"></span>noms.indexOf(<span style="color:#e6db74">&#34;Pep&#34;</span>) <span style="color:#75715e">//  0
</span><span style="color:#75715e"></span>noms.size <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span>noms.contains(<span style="color:#e6db74">&#34;Anna&#34;</span>) <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>noms.subList(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>) <span style="color:#75715e">// [Joan, Anna]
</span></code></pre></div><p>Una altra funció interessant en les llistes immutables és la que ens permet obtenir una llista mutable a partir d&rsquo;una llista immutable: <code>toMutableList</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> nomsMutable = noms.toMutableList()
</code></pre></div><h5 id="llistes-mutables">Llistes mutables</h5>
<p>Per tal de crear llistes <em><strong>mutables</strong></em>, és a dir, que es puguen modificar, eliminar i afegir elements, podem fer ús de les funció <code>arrayListOf()</code>, que ens <strong>retornara un tipus Java ArrayList</strong> i la funció <code>mutableListOf()</code>, que ens retornarà un tipus d&rsquo;interfície <em>MutableList</em>. Aquest tipus, recordem que és una extensió de les interfícies <em>MutableCollection</em> i <em>List</em>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">// arrayListOf
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> noms: ArrayList&lt;String&gt; = arrayListOf&lt;String&gt;(<span style="color:#e6db74">&#34;Pep&#34;</span>, <span style="color:#e6db74">&#34;Joan&#34;</span>, <span style="color:#e6db74">&#34;Anna&#34;</span>, <span style="color:#e6db74">&#34;Maria&#34;</span>)

 <span style="color:#75715e">// arrayListOf sense especificar-ne el tipus en la funció
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> noms: ArrayList&lt;String&gt; = arrayListOf(<span style="color:#e6db74">&#34;Pep&#34;</span>, <span style="color:#e6db74">&#34;Joan&#34;</span>, <span style="color:#e6db74">&#34;Anna&#34;</span>, <span style="color:#e6db74">&#34;Maria&#34;</span>)

<span style="color:#75715e">//  arrayListOf inferint un tipus mixte
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> items = arrayListOf(<span style="color:#e6db74">&#34;Pep&#34;</span>, <span style="color:#e6db74">&#34;Joan&#34;</span>, <span style="color:#e6db74">&#34;Anna&#34;</span>, <span style="color:#e6db74">&#34;Maria&#34;</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)

<span style="color:#75715e">// mutableListOf
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> noms: MutableList&lt;String&gt; = mutableListOf&lt;String&gt;(<span style="color:#e6db74">&#34;Pep&#34;</span>, <span style="color:#e6db74">&#34;Joan&#34;</span>, <span style="color:#e6db74">&#34;Anna&#34;</span>, <span style="color:#e6db74">&#34;Maria&#34;</span>)

<span style="color:#75715e">// mutableListOf sense especificar-ne el tipus en la funció
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> noms: MutableList&lt;String&gt; = mutableListOf&lt;String&gt;(<span style="color:#e6db74">&#34;Pep&#34;</span>, <span style="color:#e6db74">&#34;Joan&#34;</span>, <span style="color:#e6db74">&#34;Anna&#34;</span>, <span style="color:#e6db74">&#34;Maria&#34;</span>)

<span style="color:#75715e">//  mutableListOf inferint un tipus mixte
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> noms = mutableListOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;Pep&#34;</span>, <span style="color:#e6db74">&#34;Joan&#34;</span>, <span style="color:#e6db74">&#34;Anna&#34;</span>, <span style="color:#e6db74">&#34;Maria&#34;</span>)
</code></pre></div><p>A efectes pràctics, tant <code>arrayListOf</code> com <code>mutableListOf</code> són equivalents. Ambdues ens creen una llista mutable i implementada per un <code>ArrayList</code> de Java. La diferència entre elles és més la intecionalitat. Així com en <code>arrayListOf</code> demanem explícitament volem una llista implementada com un <code>ArrayList</code>, en <code>mutableListOf</code>, el que demanem és una llista mutable, sense importar-nos amb què s&rsquo;implemente. Actualment, Kotlin fa ús del tipus <code>ArrayList</code> per tal d&rsquo;implementar aquestes llistes mutables, però en futures versions, podria modificar aquesta implementació.</p>
<p>Les llistes mutables (interfície <em>mutableList</em>) ens ofereixen els següents mètodes:</p>
<ul>
<li>Per afegir elements:  <code>llistaMuable.add(element)</code></li>
<li>Per eliminar l&rsquo;element en certa posició: <code>llistaMutable.removeAt(index)</code> (la primera posició és la 0)</li>
<li>Per eliminar un element amb determinat valor: <code>llistaMutable.remove(valor)</code></li>
<li>Per reemplaçar el valor d&rsquo;un element, farem ús de la notació de vectors: <code>llistaMutable[index]=valor</code></li>
</ul>
<h5 id="sets-o-conjunts">Sets o conjunts</h5>
<p>Un conjunt és una col·lecció d&rsquo;elements sense cap ordre establert entre ells i sense duplicats. Kotlin ofereix diverses maneres de crear conjunts, cadascuna emmagatzemada en un tipus d&rsquo;estructura de dades diferent, optimitzades per a segons quines tasques.</p>
<ul>
<li><strong>La funció <code>setOf()</code></strong></li>
</ul>
<p>Crea un conjunt <strong>immutable</strong> que retorna una interfície Kotlin de tipus <code>Set</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#75715e">// Conjunt de tipus mixtes
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> conjunt = setOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;Pep&#34;</span>, <span style="color:#e6db74">&#34;Paco&#34;</span>, <span style="color:#e6db74">&#34;Amma&#34;</span>)

<span style="color:#75715e">// Conjunt d&#39;enters
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> cojuntEnters:Set&lt;Int&gt; = setOf(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>)
</code></pre></div><ul>
<li><strong>La funció <code>hashSetOf()</code></strong></li>
</ul>
<p>Crea un conjunt <strong>mutable</strong> implementat com un <em>HashSet</em> de Java, que emmagatzema els elements en una taula hash, i ens permet afegir, eliminar o aïllar elements en el conjunt.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> conjuntEnters: java.util.HashSet&lt;Int&gt; = hashSetOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
conjuntEnters.add(<span style="color:#ae81ff">5</span>) <span style="color:#75715e">//  [1, 2, 3, 4, 5]
</span><span style="color:#75715e"></span>conjuntEnters.remove(<span style="color:#ae81ff">2</span>) <span style="color:#75715e">//  [1, 3, 4, 5]
</span></code></pre></div><ul>
<li><strong>La funció <code>sortedSetOf()</code></strong></li>
</ul>
<p>Crea un conjunt <strong>mutable</strong> implementat amb un <em>TreeSet</em> de Java, que ordena els elements en funció de la seua ordenació natural o per un comparador.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> conjuntEnters: java.util.TreeSet&lt;Int&gt;  = sortedSetOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
intsSortedSet.add(<span style="color:#ae81ff">5</span>) <span style="color:#75715e">//  [1, 2, 3, 4, 5]
</span><span style="color:#75715e"></span>intsSortedSet.remove(<span style="color:#ae81ff">2</span>) <span style="color:#75715e">//  [1, 3, 4, 5]
</span><span style="color:#75715e"></span>intsSortedSet.clear() <span style="color:#75715e">// []
</span></code></pre></div><ul>
<li><strong>La funció <code>linkedSetOf()</code></strong></li>
</ul>
<p>Crea un conjunt <strong>mutable</strong> implementat amb un <em>LinkedHashSet</em> de Java, que manté una llista enllaçada d&rsquo;entrades en el conjunt en l&rsquo;ordre en què van ser insertades.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> conjuntEnters: java.util.LinkedHashSet&lt;Int&gt; = linkedSetOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</code></pre></div><ul>
<li><strong>La funció <code>mutableSetOf()</code></strong></li>
</ul>
<p>Crea un conjunt <strong>mutable</strong>, i torna una interfície de tipus <code>MutableSet</code>, implementada amb un <em>LinkedHashSet</em> de Java.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> ConjuntEnters: MutableSet&lt;Int&gt; = mutableSetOf(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</code></pre></div><h5 id="maps">Maps</h5>
<p>Els mapes són conjunts de parells de la forma <em>clau:valor</em>. Les claus han de ser úniques (per tant no hi ha duplicats), però els valors associats poden repetir-se. La implementació es realitza a través d&rsquo;una col·lecció <code>Map</code> de Java.</p>
<ul>
<li><strong>La funció <code>mapOf()</code></strong></li>
</ul>
<p>Crea una col·lecció de tipus <em>Map</em> <strong>immutable</strong>. Per crear-la li donem una llista de parells clau:valor, i ens retornarà una interfície de tipus Kotlin <em>Map</em>. Per indicar els parells farem ús de la funció infixa <code>to</code>:</p>
<p>Per fer la declaració:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> codisPostals: Map&lt;Int, String&gt; = mapOf(<span style="color:#ae81ff">46760</span> to <span style="color:#e6db74">&#34;Tavernes de la Valldigna&#34;</span>, <span style="color:#ae81ff">46410</span> to <span style="color:#e6db74">&#34;Sueca&#34;</span>, <span style="color:#ae81ff">46400</span> to <span style="color:#e6db74">&#34;Cullera&#34;</span>)
</code></pre></div><p>Per recórrer aquest mapa, farem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">for</span> ((clau, valor) <span style="color:#66d9ef">in</span> codisPostals) {
    println(<span style="color:#e6db74">&#34;El codi postal de </span><span style="color:#e6db74">$valor</span><span style="color:#e6db74"> és </span><span style="color:#e6db74">$clau</span><span style="color:#e6db74">&#34;</span>)
}
</code></pre></div><p>I també podem accedir als diferents valors fent ús de la notació <code>[]</code> i utilitzant la clau:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">println(codisPostals[<span style="color:#ae81ff">46760</span>]) <span style="color:#75715e">// Tavernes de la Valldigna
</span></code></pre></div><p>Cal tindre en compte que els mapes <strong>no es corresponen a la jerarquia de <em>Collection</em></strong>, de fet, la interfície <em>Map</em> no estén res.</p>
<p>Les principals propietats i funcions d&rsquo;aquesta interfície són:</p>
<ul>
<li><code>size</code> que ens indica el nombre de parells que té,</li>
<li><code>isEmpty()</code> que ens diu si el mapa està buït,</li>
<li><code>containsKey(clau):</code> Torna cert si la clau existeix al mapa,</li>
<li><code>containsValue(valor)</code>: Ens torna cert si el alguna clau del mapa conté el valor indicat com a argument.</li>
<li><code>get(clau)</code>: Ens retorna el valor associat a la clau indicada. Seria com u tilitzar l&rsquo;operador <code>[]</code>. Si no es troba l&rsquo;element retorna <code>null</code>.</li>
<li><code>keys</code>: Propietat que ens ofereix un <code>Set</code> immutable amb totes les claus del mapa.</li>
<li><code>values</code>: Propietat que ens ofereix una <code>Collection</code> immutable amb tots els valors del mapa.</li>
</ul>
<p><strong>La funció mutableMapOf()</strong>:</p>
<p>Ens crea un mapa <strong>mutable</strong>, al que podrem afegir, modificar i eliminar elements. Ens retornarà una interfície Kotlin de tipus <em>MutableMap</em>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> codisPostals: MutableMap&lt;Int, String&gt; = mutableMapOf(<span style="color:#ae81ff">46760</span> to <span style="color:#e6db74">&#34;Tavernes de la Valldigna&#34;</span>, <span style="color:#ae81ff">46410</span> to <span style="color:#e6db74">&#34;Sueca&#34;</span>, <span style="color:#ae81ff">46400</span> to <span style="color:#e6db74">&#34;Cullera&#34;</span>)
</code></pre></div><p>Podem afegir o eliminar elements al mapa amb els mètodes <code>put</code> i <code>remove</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">codisPostals.put(<span style="color:#ae81ff">46614</span>, <span style="color:#e6db74">&#34;Favara&#34;</span>) <span style="color:#75715e">// {46760=Tavernes de la Valldigna, 46410=Sueca, 46400=Cullera, 46614=Favara}
</span><span style="color:#75715e"></span>codisPostals.remove(<span style="color:#ae81ff">46614</span>, <span style="color:#e6db74">&#34;Favara&#34;</span>) <span style="color:#75715e">//  {46760=Tavernes de la Valldigna, 46410=Sueca, 46400=Cullera}
</span><span style="color:#75715e"></span>codisPostals.remove(<span style="color:#ae81ff">46400</span>) <span style="color:#75715e">//  {46760=Tavernes de la Valldigna, 46410=Sueca}
</span><span style="color:#75715e"></span>codisPostals.clear() <span style="color:#75715e">// {}
</span></code></pre></div><p>I utilitzar les propietats i funcions pròpies de consulta dels mapes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">codisPostals.keys 
codisPostals.values 
codisPostals.<span style="color:#66d9ef">get</span>(clau) <span style="color:#75715e">// o bé utilitzar la notació []
</span></code></pre></div><ul>
<li><strong>la funció HashMapOf()</strong></li>
</ul>
<p>Ens proporicona un mapa <strong>mutable</strong> implementat amb un tipus Java <em>HashMap</em>, que utilitza una taula hash per implementar la interfície Java <em>Map</em>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> codisPostals: java.util.HashMap&lt;Int, String&gt; = hashMapOf(<span style="color:#ae81ff">46760</span> to <span style="color:#e6db74">&#34;Tavernes de la Valldigna&#34;</span>, <span style="color:#ae81ff">46410</span> to <span style="color:#e6db74">&#34;Sueca&#34;</span>, <span style="color:#ae81ff">46400</span> to <span style="color:#e6db74">&#34;Cullera&#34;</span>)
</code></pre></div><p>Aquest mapa admetrà totes les funcions de consulta i modificació pròpies de la interfície.</p>
<ul>
<li><strong>la funció linkedHashMap()</strong></li>
</ul>
<p>Ens proporicona un mapa <strong>mutable</strong> implementat amb un tipus Java <em>LinkedHashMap</em>, que utilitza una llista enllaçada de les entradesal mapa en l&rsquo;ordre en que han estat inserides.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> codisPostals: java.util.LinkedHashMap&lt;Int, String&gt; = linkedMapOf(<span style="color:#ae81ff">46760</span> to <span style="color:#e6db74">&#34;Tavernes de la Valldigna&#34;</span>, <span style="color:#ae81ff">46410</span> to <span style="color:#e6db74">&#34;Sueca&#34;</span>, <span style="color:#ae81ff">46400</span> to <span style="color:#e6db74">&#34;Cullera&#34;</span>)
</code></pre></div><p>Aquest mapa admetrà totes les funcions de consulta i modificació pròpies de la interfície.</p>
<ul>
<li><strong>la funció sortedMapOf()</strong></li>
</ul>
<p>Ens proporicona un mapa <strong>mutable</strong> implementat amb un tipus Java <em>SortedMap</em>, que manté totes les entrades al mapa ordenades de manera ascendent per la clau.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> codisPostals: java.util.SortedMap&lt;Int, String&gt; = sortedMapOf(<span style="color:#ae81ff">46760</span> to <span style="color:#e6db74">&#34;Tavernes de la Valldigna&#34;</span>, <span style="color:#ae81ff">46410</span> to <span style="color:#e6db74">&#34;Sueca&#34;</span>, <span style="color:#ae81ff">46400</span> to <span style="color:#e6db74">&#34;Cullera&#34;</span>)
<span style="color:#75715e">//  S&#39;emmagatzema: {46400=Cullera, 46410=Sueca, 46760=Tavernes de la Valldigna}
</span></code></pre></div><p>Aquest mapa admetrà totes les funcions de consulta i modificació pròpies de la interfície.</p>
<h5 id="funcions-dextesió-sobre-operadors">Funcions d&rsquo;extesió sobre operadors</h5>
<p>Kotlin ens ofereix diverses funcions <em>operador</em> o funcions d&rsquo;extensió, que poden ser invocades sobre les col·leccions. Donem una ullada a les més útils:</p>
<ul>
<li>La <strong>funció  <code>last()</code></strong> retorna l&rsquo;últim element d&rsquo;una col·lecció com una llista o un conjunt. Aquesta funció admet un predicat que restringeix l&rsquo;operació a un subconjunt d&rsquo;elements.</li>
<li>De la mateixa manera, la <strong>funció <code>first()</code></strong> ens retorna el primer element d&rsquo;una col·lecció com una llista o un conjunt. Aquesta funció admet un predicat que restringeix l&rsquo;operació a un subconjunt d&rsquo;elements.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> llista: List&lt;String&gt; = listOf(<span style="color:#e6db74">&#34;un&#34;</span>, <span style="color:#e6db74">&#34;dos&#34;</span>, <span style="color:#e6db74">&#34;tres&#34;</span>, <span style="color:#e6db74">&#34;quatre&#34;</span>, <span style="color:#e6db74">&#34;cinc&#34;</span>)

llista.last() <span style="color:#75715e">// cinc
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Últim element de la col·lecció, que compleix la condició indicada
</span><span style="color:#75715e">// Utiitzem l&#39;operador `it` per fer referència a cada element en qüestió:
</span><span style="color:#75715e"></span>llista.last({<span style="color:#66d9ef">it</span>.length<span style="color:#f92672">==</span><span style="color:#ae81ff">3</span>})  <span style="color:#75715e">// dos (restringim l&#39;operació als items de longitud 3)
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// També es pot expressar sense els parèntesis
</span><span style="color:#75715e"></span>llista.last{<span style="color:#66d9ef">it</span>.length<span style="color:#f92672">==</span><span style="color:#ae81ff">3</span>}

llista.first()  <span style="color:#75715e">// un
</span><span style="color:#75715e"></span>llista.first({<span style="color:#66d9ef">it</span>.length<span style="color:#f92672">==</span><span style="color:#ae81ff">4</span>}) <span style="color:#75715e">//Tres
</span></code></pre></div><p>Per als conjunts, recordem que aquests no admeten duplicats, però que sí que mantenen l&rsquo;ordre d&rsquo;inseció. Veiem alguns exemples:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">val</span> conjunt: Set&lt;Int&gt; = setOf(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">2</span>)

conjunt.last() <span style="color:#75715e">// 6
</span><span style="color:#75715e">// El resultat és 6 no perquè siga el major, sinò perquè és 
</span><span style="color:#75715e">// l&#39;últim element que s&#39;ha afegit al conjut, ja que l&#39;últim 
</span><span style="color:#75715e">// element que s&#39;ha passat com a argument a setOf és un 2
</span><span style="color:#75715e">// que ja estava al conjunt (i per tant no s&#39;ha inserit)
</span><span style="color:#75715e"></span>
conjunt.first() <span style="color:#75715e">// 2
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Veiem incorporant alguns predicats:
</span><span style="color:#75715e"></span>
conjunt.first({<span style="color:#66d9ef">it</span>&gt;<span style="color:#ae81ff">3</span>}) <span style="color:#75715e">// 6: Primer element afegit major que 3
</span><span style="color:#75715e"></span>conjunt.last({<span style="color:#66d9ef">it</span>&lt;<span style="color:#ae81ff">5</span>}); <span style="color:#75715e">// 1: Últim element afegit menor que 5
</span></code></pre></div><ul>
<li>La <strong>funció  <code>max()</code></strong> retorna l&rsquo;element més gran o <em>nul</em> si no existeix.</li>
<li>La <strong>funció <code>min()</code></strong> ens retorna l&rsquo;element més menut o <em>nul</em> si no existeix.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">llista.max() <span style="color:#75715e">//  un: Element de menor longitud
</span><span style="color:#75715e"></span>llista.min() <span style="color:#75715e">// cinc: Element més llarg
</span><span style="color:#75715e"></span>conjunt.max() <span style="color:#75715e">// 6
</span><span style="color:#75715e"></span>&gt;&gt;&gt; conjunt.min() <span style="color:#75715e">// 1
</span></code></pre></div><ul>
<li>La <strong>funció <code>drop(n)</code></strong> ens retorna una nova llista o conjunt sense els primers <em>n</em> elements:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin">llista.drop(<span style="color:#ae81ff">2</span>) <span style="color:#75715e">// [tres, quatre, cinc]
</span><span style="color:#75715e"></span>conjunt.drop(<span style="color:#ae81ff">3</span>) <span style="color:#75715e">// [6]
</span></code></pre></div><ul>
<li>La <strong>funció <code>plus(element)</code></strong> ens retorna una nova llista resultat d&rsquo;afegir l&rsquo;element indicat a la llista o conjunt. Si es tracta d&rsquo;un conjunt i l&rsquo;element ja està, no l&rsquo;afegirà.</li>
<li>La <strong>funció <code>minus(element)</code></strong> ens retorna una nova llista resultat d&rsquo;eliminar l&rsquo;element indicat a la llista o conjunt. Si l&rsquo;element ja no estava, tornarà la matixa llista o conjunt.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">var</span> llista2=llista.plus(<span style="color:#e6db74">&#34;hola&#34;</span>) <span style="color:#75715e">// llista2=[un, dos, tres, quatre, cinc, hola]
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> conjunt2=conjunt.plus(<span style="color:#ae81ff">6</span>) <span style="color:#75715e">//  conjunt2=[2, 3, 1, 6] (No s&#39;ha afegit res)
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">var</span> llista3=llista.minus(<span style="color:#e6db74">&#34;tres&#34;</span>) <span style="color:#75715e">// llista3= [un, dos, quatre, cinc]
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> conjunt3=conjunt.minus(<span style="color:#ae81ff">10</span>) <span style="color:#75715e">//  conjunt3=[2, 3, 1, 6] (no es modifica, el 10 no estava al conjunt)
</span></code></pre></div><p>Podem trobar molta més informació sobre col·leccions en Kotlin a la documentació:</p>
<ul>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/</a></li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><a href="https://apiumhub.com/es/tech-blog-barcelona/por-que-kotlin">https://apiumhub.com/es/tech-blog-barcelona/por-que-kotlin</a>) i <a href="https://www.xatakandroid.com/programacion-android/no-hara-falta-aprender-java-para-programar-android-kotlin-pasa-a-ser-preferido-google">https://www.xatakandroid.com/programacion-android/no-hara-falta-aprender-java-para-programar-android-kotlin-pasa-a-ser-preferido-google</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Un Singleton és un patró de disseny de programari que garanteix que una classe només tinga una instància i que aquesta proporcione un únic punt d&rsquo;accés global. Quan es sol·licita la classe singleton, sempre s&rsquo;obté la mateixa instància de la classe. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

        </article>
<aside class="table-of-contents">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-introducció-a-kotlin">1. Introducció a Kotlin</a>
      <ul>
        <li><a href="#11-installació-de-kotlin">1.1. Instal·lació de Kotlin</a></li>
        <li><a href="#12-extensions-per-a-vscode">1.2. Extensions per a VSCode</a></li>
      </ul>
    </li>
    <li><a href="#2-estructura-i-execució-dun-programa-hello-world">2. Estructura i execució d&rsquo;un programa: Hello World</a>
      <ul>
        <li><a href="#21-compilació-i-execució">2.1. Compilació i execució</a></li>
        <li><a href="#22-ús-darguments">2.2. Ús d&rsquo;arguments</a></li>
        <li><a href="#23-gradle-java-i-kotlin">2.3. Gradle, Java i Kotlin</a></li>
      </ul>
    </li>
    <li><a href="#3-variables-i-tipus-de-dades">3. Variables i tipus de dades</a>
      <ul>
        <li><a href="#31-variables-i-tipus-bàsics-en-java">3.1. Variables i tipus bàsics en Java</a></li>
        <li><a href="#32-variables-i-tipus-bàsics-en-kotlin">3.2. Variables i tipus bàsics en Kotlin</a></li>
        <li><a href="#33-cadenes-de-caràcters">3.3. Cadenes de caràcters</a></li>
        <li><a href="#34-valors-nuls-o-nullable-types">3.4. Valors nuls o <em>Nullable Types</em></a></li>
        <li><a href="#35-detalls-sobre-lemmagatzemament-de-variables">3.5. Detalls sobre l&rsquo;emmagatzemament de variables</a></li>
      </ul>
    </li>
    <li><a href="#4-operadors">4. Operadors</a></li>
    <li><a href="#5-estructures-de-control">5. Estructures de control</a>
      <ul>
        <li><a href="#51-estructures-condicionals">5.1. Estructures condicionals</a></li>
        <li><a href="#52-estructures-repetitives">5.2. Estructures repetitives</a></li>
      </ul>
    </li>
    <li><a href="#53-tractament-dexcepcions">5.3. Tractament d&rsquo;excepcions</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#6-entrada-i-eixida-des-de-consola">6. Entrada i eixida des de consola</a>
      <ul>
        <li><a href="#61-exemples-dús-de-readline-i-scanner">6.1. Exemples d&rsquo;ús de readLine i Scanner</a></li>
        <li><a href="#62-entrada-i-eixida-des-de-consola-en-kotlin">6.2. Entrada i eixida des de consola en Kotlin</a></li>
      </ul>
    </li>
    <li><a href="#7-funcions-en-kotlin">7. Funcions en Kotlin</a>
      <ul>
        <li><a href="#71-definició-i-invocació">7.1. Definició i invocació</a></li>
        <li><a href="#72-expressions-lambda">7.2. Expressions Lambda</a></li>
        <li><a href="#73-funcions-anònimes">7.3. Funcions anònimes</a></li>
        <li><a href="#74-funcions-locals-o-nidificades">7.4. Funcions locals o nidificades</a></li>
        <li><a href="#75-funcions-dextensió">7.5. Funcions d&rsquo;extensió</a></li>
        <li><a href="#76-funcions-dordre-superior-o-més-alt-high-order-functions">7.6. Funcions d&rsquo;ordre superior o més alt (*High Order Functions)</a></li>
        <li><a href="#77-tancaments-closures">7.7. Tancaments (<em>Closures</em>)</a></li>
      </ul>
    </li>
    <li><a href="#8-programació-orientada-a-objectes">8. Programació orientada a objectes</a>
      <ul>
        <li><a href="#81-objectes">8.1. Objectes</a></li>
        <li><a href="#82-classes">8.2. Classes</a></li>
        <li><a href="#83-treballant-amb-classes-i-objectes">8.3. Treballant amb classes i objectes</a></li>
        <li><a href="#84-classes-i-objectes-en-kotlin">8.4. Classes i objectes en Kotlin</a></li>
        <li><a href="#85-herència-i-polimorfisme">8.5. Herència i Polimorfisme</a></li>
        <li><a href="#86-atributs-i-mètodes-estàtics-o-de-classe">8.6. Atributs i mètodes estàtics o de classe</a></li>
        <li><a href="#87-interfícies">8.7. Interfícies</a></li>
        <li><a href="#88-paquets-packages">8.8. Paquets (Packages)</a></li>
      </ul>
    </li>
    <li><a href="#9-tipus-complexos-de-dades">9. Tipus complexos de dades</a>
      <ul>
        <li><a href="#91-vectors-i-matrius">9.1. Vectors i matrius</a></li>
        <li><a href="#92-colleccions">9.2. Col·leccions</a></li>
      </ul>
    </li>
  </ul>
</nav>

</aside>

<script>

    (function () {
        let entries = document.querySelectorAll(".table-of-contents li");

        for (entry of entries) {
            entry.addEventListener("click", function (e) {
                
                e.stopPropagation();
                for (sel of document.querySelectorAll(".selected"))
                    sel.classList.remove("selected");
                e.currentTarget.classList.add("selected");
                
                for (item of e.currentTarget.children)
                    if (item == "[object HTMLUListElement]")
                        if (item.style.display == "none")
                            item.style.display = "block";
                        else item.style.display = "none"

            });
        }

    
    let entriesh2 = document.querySelectorAll(".table-of-contents li > ul");

        for (entry of entriesh2) {
            entry.style.display = "none";
        }


    })();

</script>        

</div> 

<div class="footer-container">
    <a href="https://socquique.github.io/2dam/"><h3>Docencia</h3></a>
</div>
</body>



</html>