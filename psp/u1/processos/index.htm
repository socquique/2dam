<!DOCTYPE html>
<html lang="ca">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../../../../css?family=Noto+Sans+JP">
    <link rel="stylesheet" href="../../../css/main.css">

    
    <title>1. Processos i eines del SO</title>
</head>

<body>
    
    <div class="header-container">
        
        
        
        
        
    </div>

    
    <div class="main-container">
<nav>
    <h3>
        <a href="../index.htm">
        Unitat 1. Programació Concurrent</a>
    </h3>
    
        
        
        <div class="unitat">
            <a href="index.htm">1. Processos i eines del SO</a>
        </div>
        
        <div class="unitat">
            <a href="../programacioconcurrent/index.htm">2. Programació concurrent.</a>
        </div>
        
    
</nav>
    <article>
        <header> 
            <h1>1. Processos i eines del SO</h1>
        </header>
        <p>En aquest document, anem a veure la visió del sistema operatiu sobre els processos, tant pesats com lleugers (threads), i la relació que tenen amb els serveis del sistema, així com alguns mecanismes de comunicació entre ells. Veurem els diferents conceptes, i les ordres del sistema operatiu que ens ajuden a gestionar i obtenir informació sobre processos i serveis.</p>
<h2 id="1-processos-i-estats-dun-procés">1. Processos i estats d&rsquo;un procés</h2>
<p>Els programari d&rsquo;un ordinador es troba emmagatzemat al disc, en forma de fitxers executables. Quan llancem un fitxer executable, el sistema crea un procés amb un identificador, i ha d&rsquo;assignar-li certs recursos per possibilitar l&rsquo;execució, com memòria, temps de processament (CPU), i accés a fitxers i dispositius d&rsquo;entrada i eixida.</p>
<p>Així doncs, podem dir que <em>un procés no és més que una instància d&rsquo;un programa en execució, al que s&rsquo;han assignat determinats recursos del sistema.</em></p>
<p>Els sistemes basats en Unix, com és del cas de Linux segueixen un model d&rsquo;estats sobre el que es defineixen transicions, i es representa en forma de graf. Les transicions d&rsquo;un a altre estat es produeixen com a conseqüència d&rsquo;una crid al sistema o d&rsquo;un event.</p>
<p><img src="../img/estats.png" alt="Estats d&rsquo;un procés"></p>
<p>A la <strong>figura anterior</strong> veiem els tres estats següents:</p>
<ul>
<li><strong>R:</strong> <em>Running or Runnable (on run queue)</em>: Procés en execució o a la cua d’execució.</li>
<li><strong>S:</strong> <em>Interruptible sleep (waiting for an event to complete)</em>: Aturat a l’espera d’algun event.</li>
<li><strong>Z:</strong> <em>defunct (&ldquo;zombie&rdquo; process, terminated but not reaped by its parent)</em>: Procés finalitzat a l’espera d’informar al procés pare.</li>
</ul>
<p>Aquests estats passen d’un a altre a través de certes <em>transicions</em>:</p>
<ul>
<li><strong>Inici del procés</strong>: S’inicia un procés (crida al sistema fork()), i aquest passa a estar llest per executar-se (preparat). De la cúa de processos preparats passarà a executar-se quan ho decidisca el planificador.</li>
<li><strong>Transició R→S</strong>: El procés passa d’estar en execució a estar bloquejat, a l’espera (wait()) que finalitze un procés fill.</li>
<li><strong>Transició S→R</strong>: El procés passa de bloquejat a execució. Quan finalitza un procés fill, informa al procés pare (SIGCHILD) per indicar que ha finalitzat.</li>
<li><strong>Transició R→Z</strong>: Quan finalitza el procés, passa a estat Z (Zombie) o Finalitzat. Aquest procés, no s’elimina de memòria fins que el procés pare recull amb el wait() el codi que el fill retorna en finalitzat amb exit().</li>
</ul>
<p>Encara que al gràfic s’ha mostrat l’estat S, poden haver diverses situacions de bloqueig:</p>
<ul>
<li>Pendent que finalitze una operació d’entrada i eixida. (Estat <strong>D:</strong> <em>Uninterrumpible Sleep – Usually IO</em>)</li>
<li>Aturat per una senyal del propi treball (un sleep, per exemple): (Estat <strong>T:</strong> <em>Time</em>).
Aturar degut a algun procés de depuració. (Estat <strong>t</strong>: <em>tracing</em>)</li>
</ul>
<p>Podem veure els estas ampiats a la <strong>figura \ref{estats2}</strong></p>
<p><img src="../img/estats2.png" alt="Estats d&rsquo;un procés ampliat\label{estats2}"></p>
<h3 id="11-utilitats-relacionades-amb-els-processos">1.1. Utilitats relacionades amb els processos</h3>
<h4 id="top-htop-i-atop">Top, htop i atop</h4>
<p><strong>top</strong></p>
<p>L&rsquo;ordre <code>top</code> mostra en temps real l’activitat del processador, amb una llista de les tasques que més estan consumint aquest recurs, permetent manipular també processos. <code>Top</code> pot classificar les diferents tasques per ús de CPU, de memòria o temps d’execució. Les característiques que mostra es poden configurar bé per ordres interactives o per fitxers de configuració.
Entre la informació que mostra, podem trobar valors generals, com el nombre de processos del sistema, en cadascun dels estats, i diversos consums tant de CPU com de memòria.
Per a cada procés, mostra, per defecte la següent informació:</p>
<ul>
<li>PID del procés</li>
<li>Usuari que l’ha llançat (USER)</li>
<li>Prioritat (PR)</li>
<li>Nice (NI)</li>
<li>Consum de memòria Virtual (VIRT) en Kb.</li>
<li>Memòria Resident (RES) o física.</li>
<li>Memòria compartida (SHR) disponible per a la tasca (que podria compartir-se amb altres processos).</li>
<li>Estat (S) del procés.</li>
<li>Percentatge de CPU utilitzat des de la última actualització. (%CPU)</li>
<li>Percentatge de memòria fśica utilitzat. (%MEM)</li>
<li>Temps total de CPU utilitzat per l’aplicació des que va començar.  (TIME+)</li>
<li>Ordre (COMMAND) que va llançar el procés.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ top
top - 14:51:53 up  8:21,  <span style="color:#ae81ff">1</span> user,  load average: 0,04, 0,05, 0,04
Tasks: <span style="color:#ae81ff">268</span> total,   <span style="color:#ae81ff">1</span> running, <span style="color:#ae81ff">266</span> sleeping,   <span style="color:#ae81ff">0</span> stopped,   <span style="color:#ae81ff">1</span> zombie
%Cpu<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span>:  1,9 us,  0,9 sy,  0,1 ni, 96,2 id,  0,9 wa,  0,0 hi,  0,0 si,  0,0 st
KiB Mem :  <span style="color:#ae81ff">8084828</span> total,   <span style="color:#ae81ff">477512</span> free,  <span style="color:#ae81ff">5270308</span> used,  <span style="color:#ae81ff">2337008</span> buff/cache
KiB Swap:  <span style="color:#ae81ff">9762812</span> total,  <span style="color:#ae81ff">9594072</span> free,   <span style="color:#ae81ff">168740</span> used.  <span style="color:#ae81ff">1730572</span> avail Mem 

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 <span style="color:#ae81ff">1477</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">857036</span> <span style="color:#ae81ff">319012</span> <span style="color:#ae81ff">288424</span> S   6,7  3,9   5:46.83 Xorg
<span style="color:#ae81ff">13175</span> jose      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">4740712</span> <span style="color:#ae81ff">795016</span> <span style="color:#ae81ff">733624</span> S   6,7  9,8  13:30.75 VirtualBox
    <span style="color:#ae81ff">1</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">119916</span>   <span style="color:#ae81ff">5568</span>   <span style="color:#ae81ff">3704</span> S   0,0  0,1   0:01.97 systemd
    <span style="color:#ae81ff">2</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0,0  0,0   0:00.00 kthreadd
    <span style="color:#ae81ff">3</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0,0  0,0   0:00.10 ksoftirqd/0
    <span style="color:#ae81ff">5</span> root       <span style="color:#ae81ff">0</span> -20       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0,0  0,0   0:00.00 kworker/0:0H
    <span style="color:#ae81ff">7</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0,0  0,0   0:07.16 rcu_sched
    <span style="color:#ae81ff">8</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0,0  0,0   0:00.00 rcu_bh
</code></pre></div><p>Sintaxi de top:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">top -hv|-bcHiOSs -d secs -n max -u|U user -p pid -o fld -w <span style="color:#f92672">[</span>cols<span style="color:#f92672">]</span>
</code></pre></div><p>Algunes opcions d’interès:</p>
<ul>
<li><strong>secs</strong>: Interval entre actualitzacions (es canvia amb l’ordre interactiva s)</li>
<li><strong>n max</strong>: Indica el nombre d’iteracions/refrescos abans de finalitzar. Si no s’indica, es repeteix contínuament.</li>
<li><em>c</em>*: Mostra tota la línia d’ordres que ha llançat cada procés.</li>
<li><strong>b</strong>: Batch mode, en lloc del mode interactiu. Va mostrant per pantalla els resultats, sense possibilitat d’interacció. Pot usar-se en combinació amb l’opció n, per tal de limitar el nombre d’iteracions (si no, hauriem de finalitzar el procés manualment).</li>
<li><strong>H</strong>: Mostra informació relativa també als processos lleugers (threads).</li>
<li><strong>o camp</strong>: Permet ordenar l’eixida pel camp especificat.</li>
<li><strong>O</strong>: Ens mostra els camps d’ordenació possibles per a l’opció «o camp». Cal tindre en compte que aquest camp s’especifica en l’idioma indicat en $LANGUAGE.</li>
<li><strong>p</strong>: Especificat en forma -p1 -p2 -p3&hellip; mostra els processos amb els PIDs espeficificats.</li>
<li><strong>U | u</strong>: Filtra els processos per usuari propietari. Aquesta opció és incompatible amb l’opció «p», indicada anteriorment.</li>
</ul>
<p><strong>htop</strong></p>
<p>L’ordre htop és una versió millorada de top, més fàcil d’interpretar, i que permet realitzar certes funcions sobre els processos, com modificar-los la prioritat o aturar processos.</p>
<p><img src="../img/htop.png" alt="htop"></p>
<p>Per defecte no ve instal·lada en Ubuntu, pel que caldrà instal·lar-la amb <code>sudo apt-get install htop</code>.</p>
<p><strong>atop</strong></p>
<p>L’ordre atop, a l&rsquo;igual que htop, no es troba instal·lada per defecte en molts sistemes, pel que caldria instal·lar-la. Es tracta d’un monitor de processos en temps real que mostra també informació sobre la CPU, la memòria, la xarxa, l’usuari, la prioritat de processos, etc. Podem trobar més informació de l’eina a la seua web: <a href="https://www.atoptool.nl">https://www.atoptool.nl</a>.</p>
<p><strong>Pidof i pgrep</strong></p>
<p>Ambdues ordres serveixen per preguntar per l’identificador de procés (PID) que concorde amb un nom de programa. La principal diferència és que pgrep admet patrons de recerca, tal com fa l’ordre grep.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ pidof bash
<span style="color:#ae81ff">27197</span> <span style="color:#ae81ff">20138</span> <span style="color:#ae81ff">16768</span> <span style="color:#ae81ff">16620</span> <span style="color:#ae81ff">16364</span> <span style="color:#ae81ff">16290</span> <span style="color:#ae81ff">9389</span> <span style="color:#ae81ff">9133</span> <span style="color:#ae81ff">9117</span> <span style="color:#ae81ff">8995</span> <span style="color:#ae81ff">8338</span> <span style="color:#ae81ff">2050</span>
</code></pre></div><pre><code>$ pidof ash
$ pgrep bash
2050
8338
8995
9133
9389
16290
16364
16620
16768
20138
27197

$ pgrep ash
2050
8338
8995
9133
9134
9389
13357
16290
16364
16620
16768
20138
27197
</code></pre><h4 id="ps-process-status">ps (Process Status)</h4>
<p>Es tracta d’una de les eines més utilitzades, i ens mostra una instantània dels processos actuals. L’ordre admet opcions de diferent tipus: les opcions UNIX, precedides per un guió (-), les opcions BSD que no utilitzen cap guió, i les opcions GNU, que van precedides per dos guions (&ndash;).</p>
<p>Podem consultat totes les opcions disponibles al manual de <code>ps</code>. A continuació anem a veure a mode d&rsquo;exemple els usos més comununs d&rsquo;aquesta ordre, tot i que s&rsquo;admeten moltes més opcions:</p>
<p><strong>ps</strong></p>
<p>Si no afegim cap paràmetre, mostra els processos de l&rsquo;usuari actual:</p>
<pre><code>$ ps
  PID TTY          TIME CMD
 4154 pts/0    00:00:00 bash
 4851 pts/0    00:00:00 ps
</code></pre><p>L&rsquo;eixida que ens dóna conté:</p>
<ul>
<li><strong>PID</strong>: L&rsquo;id del procés.</li>
<li><strong>TTY</strong>: La terminal des d&rsquo;on s&rsquo;ha iniciat el procés o procés principal. Si apareix un interrogant indica que no hi ha terminal de control.</li>
<li><strong>TIME</strong>: Temps de CPU utilitzat pel procés des que va començar.</li>
<li><strong>CMD</strong>: Ordre que va llençar el procés.
Com podem comprovar al manual de ps (man ps), aquesta ordre té moltes opcions, i moltes possibles combinacions entre la sintaxi BSD, UNIX i GNU.</li>
</ul>
<p><strong>ps -e</strong></p>
<p>Mostra de tots els processos el PID, la TTY, el temps i l’ordre que s’ha llançat.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">  PID TTY          TIME CMD
    <span style="color:#ae81ff">1</span> ?        00:00:02 systemd
    <span style="color:#ae81ff">2</span> ?        00:00:00 kthreadd
    <span style="color:#ae81ff">3</span> ?        00:00:00 ksoftirqd/0
   ...
<span style="color:#ae81ff">27831</span> pts/13   00:00:00 bash
<span style="color:#ae81ff">31280</span> pts/16   00:00:00 bash
</code></pre></div><p><strong>ps -ef</strong></p>
<p>Mostra tots els processos amb un format d’eixida més complet, indicant l’usuari que l’ha llançat, el PID del procés pare, el percentatge de CPU (C) i l’hora d’inici del procés:</p>
<pre><code>UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 06:30 ?        00:00:02 /sbin/init splash
root         2     0  0 06:30 ?        00:00:00 [kthreadd]
root         3     2  0 06:30 ?        00:00:00 [ksoftirqd/0]
root         5     2  0 06:30 ?        00:00:00 [kworker/0:0H]
...
jose     27831  9629  0 11:43 pts/13   00:00:00 /bin/bash
root     30805     2  0 12:09 ?        00:00:00 [kworker/3:0]
jose     31280  9629  0 12:44 pts/16   00:00:00 /bin/bash
</code></pre><p><strong>ps &ndash;pid pid, i ps &ndash;ppid pid</strong></p>
<p>Les opcions en format GNU pid i ppid permeten especificar un identificador de procés concret per a ps.</p>
<pre><code>$ pgrep firefox
11805

$ ps --pid 11805

  PID TTY          TIME CMD
11805 ?        00:08:48 firefox
</code></pre><p><strong>ps aux</strong></p>
<p>Es tracta del cas d’ús més estés, utilitzant una sintaxi tipus BSD. Mostra tots els processos de tots els usuaris (a), en format orientat a l&rsquo;usuari (u), i eliminant la restricció de que el procés tinga una tty associada (x). Bàsicament, el que ve a dir és que mostra tots els processos que s&rsquo;estan executant al sistema, siga de l&rsquo;usuari que siga.</p>
<p>Veiem un exemple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ ps aux 

USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         <span style="color:#ae81ff">1</span>  0.0  0.0 <span style="color:#ae81ff">120364</span>  <span style="color:#ae81ff">6584</span> ?        Ss   20:14   0:01 /sbin/init splash
root         <span style="color:#ae81ff">2</span>  0.0  0.0      <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> ?        S    20:14   0:00 <span style="color:#f92672">[</span>kthreadd<span style="color:#f92672">]</span>
...
root        <span style="color:#ae81ff">31</span>  0.0  0.0      <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> ?        SN   20:14   0:00 <span style="color:#f92672">[</span>ksmd<span style="color:#f92672">]</span>
joamuran  <span style="color:#ae81ff">4150</span>  0.3  0.9 <span style="color:#ae81ff">961412</span> <span style="color:#ae81ff">81388</span> ?        Sl   20:42   0:06 tilix
joamuran  <span style="color:#ae81ff">4154</span>  0.0  0.0  <span style="color:#ae81ff">25552</span>  <span style="color:#ae81ff">5628</span> pts/0    Ss   20:42   0:00 /bin/bash
...
joamuran  <span style="color:#ae81ff">5328</span>  0.0  0.0  <span style="color:#ae81ff">40096</span>  <span style="color:#ae81ff">3376</span> pts/0    R+   21:17   0:00 ps aux
joamuran  <span style="color:#ae81ff">5329</span>  0.0  0.0  <span style="color:#ae81ff">12316</span>   <span style="color:#ae81ff">848</span> pts/0    S+   21:17   0:00 more
</code></pre></div><p>Una variant de <code>ps aux</code> es <code>ps auxe</code>, que a més de la informació anterior, mostra també l&rsquo;entorn en què s&rsquo;ha invocat el procés.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ ps auxe 
USER       PID  %CPU %MEM  VSZ   RSS TTY      STAT START   TIME COMMAND
jose     <span style="color:#ae81ff">31280</span>  0.0  0.0  <span style="color:#ae81ff">27772</span>  <span style="color:#ae81ff">6408</span> pts/16   Ss+  12:44   0:00 /bin/bash <span style="color:#f92672">[]</span> ... LANGUAGE<span style="color:#f92672">=</span>ca_ES@valencia:ca_ES:en ... LC_NAME<span style="color:#f92672">=</span>es_ES.UTF-8 XDG_VTNR<span style="color:#f92672">=</span><span style="color:#ae81ff">7</span> ...
</code></pre></div><p>Veiem ara com interpretem estes eixides. Del PID, TTY, TIME i CMD ja hem parlat. La resta de camps tenen el següent significat:</p>
<ul>
<li><strong>USER</strong>:  Usuari que ha iniciat el procés.</li>
<li><strong>%CPU</strong>: Percentatge de CPU utilitzat.</li>
<li><strong>%MEM</strong>: Percentatge de memòria</li>
<li><strong>VSZ</strong>: Memòria Virtual utilitzada en Kb.</li>
<li><strong>RSS</strong>: &ldquo;Resident Set Size&rdquo;: Memòria física (no de SWAP) que utilitza una tasca (en Kb).</li>
<li><strong>STAT</strong>: Estat en què es troba el procés.</li>
<li><strong>START</strong>: Hora d&rsquo;inici del procés.</li>
</ul>
<p>Parem-nos ara en el camp STAT, que indica l&rsquo;estat en que es troba el procés. Segons la pàgina del manual de ps, els estats que un procés pot presentar són:</p>
<ul>
<li><strong>D</strong>: Interromput. Es tracta d&rsquo;un procés bloquejat o dormit a l&rsquo;espera d&rsquo;una senyal, generalment relacionat amb l&rsquo;Entrada/Eixida.</li>
<li><strong>R</strong>: En execució o preparat per executar-se.</li>
<li><strong>S</strong>: Suspès. Procés bloquejat a l&rsquo;espera que es produisca un event.</li>
<li><strong>T</strong>: Aturat per una senyal de control.</li>
<li><strong>t</strong> : Procés aturat per a la depuració.</li>
<li><strong>X</strong>: Procés mort (no hauria d&rsquo;aparéixer mai)</li>
<li><strong>Z</strong>: Procés difunt o  &ldquo;zombie&rdquo;. Indica que el procés ha finalitzat, però encar ano li ha tornat el valor amb exit al seu pare.</li>
</ul>
<p>A banda d&rsquo;estos estats, poden aparéixer alguns caràcters acompanyant l&rsquo;estat en qüestió:</p>
<ul>
<li><strong>&lt;</strong>: Té una prioritat major que la normal.</li>
<li><strong>N</strong>: Té una prioritat menor que la normal.</li>
<li><strong>L</strong>: Té pàgines bloquejades en memòria.</li>
<li><strong>s</strong>: És un procés líder d’una sessió (és ell qui ha iniciat una sessió)</li>
<li><strong>l</strong>: és un procés multifil.</li>
<li><strong>+</strong>: Està en el grup de processos en primer pla.</li>
</ul>
<p>Una forma molt comuna d&rsquo;utilitzat ps és en combinació amb tuberíes i filtrant pel nom d&rsquo;un procés concret, per tal d&rsquo;obtenir informació relativa a aquest:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"> ps aux | grep tilix
joamuran  <span style="color:#ae81ff">4150</span>  0.2  1.0 <span style="color:#ae81ff">992600</span> <span style="color:#ae81ff">88164</span> ?        Sl   20:42   0:10 tilix
joamuran  <span style="color:#ae81ff">5989</span>  0.0  0.0  <span style="color:#ae81ff">16976</span>  <span style="color:#ae81ff">1020</span> pts/0    S+   22:01   0:00 grep --color<span style="color:#f92672">=</span>auto tilix
</code></pre></div><h4 id="pstree">pstree</h4>
<p>L’ordre pstree permet visualitzar tots els processos en forma d’arbre, de manera que indica la relació entre ells. D’entre les opcions més comunes, podem descatar:</p>
<ul>
<li><strong>-p:</strong> per indicar el PID dels processos,</li>
<li><strong>-a</strong>: per indicar l’ordre completa executada.</li>
<li><strong>-n</strong>: Ordena els processos pel PID en lloc del nom, que és l’opció per defecte.</li>
</ul>
<pre><code>$ pstree

systemd-+-ModemManager-+-{gdbus}
        |              `-{gmain}
        |-NetworkManager-+-dhclient
        |                |-dnsmasq
        |                |-{gdbus}
        |                `-{gmain}
        |-Telegram-+-{MTP::internal::}
        |          |-{QDBusConnection}
        |          |-8*[{QThread}]
        |          |-{QXcbEventReader}
        |          |-2*[{Qt HTTP thread}]
        |          `-{Qt bearer threa}
        |-VBoxSVC-+-VirtualBox-+-{ACPI Poller}
        |         |            |-{ATA-0}
                       ....
</code></pre><p>L’ordre pstree també admet indicar un PID de procés (pstree PID), per tal de mostrar només l’arbre de processos corresponent a ell.<br>
Aturem-nos ara en la primera línia, per veure el procés pare causant de tot: Systemd.</p>
<h2 id="2-threads">2. Threads</h2>
<p>Els threads o processos lleugers són processos que comparteixen determinats recursos, com l&rsquo;espai de direccions, variables, fitxers oberts, alarmes, senyals, etc.</p>
<p>L&rsquo;opció -L de l&rsquo;ordre ps ens permet veure els threads del sistema:</p>
<pre><code>UID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD
root         1     0     1  0    1 19:08 ?        00:00:04 /sbin/init splash
root         2     0     2  0    1 19:08 ?        00:00:00 [kthreadd]
root         3     2     3  0    1 19:08 ?        00:00:00 [ksoftirqd/0]
root         5     2     5  0    1 19:08 ?        00:00:00 [kworker/0:0H]
root         7     2     7  0    1 19:08 ?        00:00:02 [rcu_sched]
...
root      1020     1  1020  0    3 19:08 ?        00:00:02 /usr/sbin/NetworkManager --no-daemon
root      1020     1  1147  0    3 19:08 ?        00:00:00 /usr/sbin/NetworkManager --no-daemon
root      1020     1  1155  0    3 19:08 ?        00:00:00 /usr/sbin/NetworkManager --no-daemon
</code></pre><p>En aquesta eixida ens interessen les columnes LWP (Light Weight Process), que indica l&rsquo;identificador del thread, i NLWP (Number of LightWeight Processes), que indica el número de processos lleugers o threads del procés.
En l&rsquo;exemple, si ens fixem amb el procés del Network Manager, traiem les següents conclussions:</p>
<ul>
<li>La columna NLWP indica que existeixen 3 threads del Network Manager.</li>
<li>Aqests threads tenen LWP 1020, 1147 i 1155.</li>
<li>Els tres threads es corresponen al mateix procés, el 1020, que és invocat directament per systemd (PID 1).</li>
</ul>
<h2 id="3-dimonis-i-serveis">3. Dimonis i serveis</h2>
<p>Els dimonis (<em>daemon</em>) són processos que s&rsquo;executen en segon pla, sense terminal (tty), ni interfície gràfica, esperant que ocórrega algun event al sistema o li arribe alguna petició de servei.</p>
<p>Un bon exemple de dimoni és un servidor web, que espera una sol·licitud per enviar una pàgina web, o un servidor ssh que espera que s&rsquo;inicie alguna sessió.</p>
<p>També hi existeixen dimonis que no són tan visibles com els qui ofereixen serveis, i que realitzen tasques com escriure al log del sistema (rsyslog) o mantindre la precisió del rellotge del sistema (ntpd).</p>
<p>En la majoría de sistemes Linux a les versions més recents (Debian&gt;=8 Jessie, Fedora&gt;=15, Mandriva&gt;=2011, Arch&gt;=2012, CenOS&gt;=7, Ubuntu&gt;=15.04) els serveis són administrats per <strong>Systemd</strong>.</p>
<p>Systemd (system daemon) és un dimoni dissenyat per al nucli de Linux, i que s&rsquo;executa en l&rsquo;espai d&rsquo;usuari, convertint-se en el procés pare de tots els processos en aquest espai. El disseny proveeix a priori un millor entorn de treball per tal d&rsquo;expressar les dependències de servei, millorant el paral·lelisme en l&rsquo;arrencada del sistema i reduint la sobrecàrrega de la shell. Fins fa relativament poc temps, el sistema encarregat de la posada en marxa del sistema era Init, heretat de System V i BSD. Els sistemes actuals, han reemplaçat aquest sistema per Systemd.</p>
<p>Les tres principals funcionalitats de Systemd són:</p>
<ul>
<li>Proporcionar un mecanisme d&rsquo;administració del sistema i els serveis,</li>
<li>Oferir un framework de desenvolupament de programari,</li>
<li>Oferir un mecanisme de connexió entre les aplicacions i el nucli de Linux.</li>
</ul>
<p>Systemd reemplaça a la seqüència d&rsquo;arrencada de Linux, així com els diferents nivells d&rsquo;execució controlats per l&rsquo;init tradicional, així com l&rsquo;execució dels scripts sota el seu control (/etc/init.d/*, /etc/rc0.d/, /etc/rc1.d, &hellip; ,/etc/rc6.d, /etc/rcS.d). A més, integra altres servies com la gestió del login, la connexió en calent de dispositius (udev), la programació de tasques periòdiques (reemplaç del cron), etc.
Systemd es presuposa doncs més ràpid en l&rsquo;arrencada i l&rsquo;apagat, degut a que els processos d&rsquo;arrencada es realitzen de forma paral·lela, i els serveis s&rsquo;inicien per esdeveniments. Per exemple, quan s&rsquo;inicia el servei de xarxa, es llança un esdeveniment que indica que el servei (de xarxa) ja està disponible, i per tant, tots els serveis que depenen del servei de xarxa, poden iniciar-se (és a dir, es llancen paral·lelament tots els serveis que depenen de la xarxa, mentre que als sistemes anteriors ho feien de forma seqüencial).</p>
<h4 id="systemctl">Systemctl</h4>
<p>La interfície que proporcions Systemd per interactuar amb els serveis és <code>systemctl</code>, i ens permet realitzar múltiples operacions:</p>
<ul>
<li>Aturada, arrencada, reinici i recàrrega d&rsquo;un servei (de forma immediata):
<ul>
<li>systemctl stop servei.service</li>
<li>systemctl start servei.service</li>
<li>systemctl restart servei.service</li>
<li>systemctl reload servei.service</li>
<li>systemctl reload-or-restart servei.service (si no estem segurs que el servei implemente reload)</li>
</ul>
</li>
</ul>
<p>Fixem-nos que el nom del servei acaba amb <code>.service</code>. Systemd, a banda de serveis, i durant l&rsquo;arrencada al sistema també controla altres recursos, com els punts de muntatge, els dispositius, etc. Aquests recursos, en nomenclatura de Systemd s&rsquo;anomenen &ldquo;unitats&rdquo;, i es representen en fitxers l&rsquo;extensió dels quals indica el tipus de recurs (<code>.service</code>, <code>.target</code>, <code>.device</code>, <code>.socket</code>&hellip; ). Com que estem referint-nos a serveis, ens centrarem en les unitats de tipus <code>.service</code>.</p>
<ul>
<li>
<p>Activant o desactivant serveis en l&rsquo;arrencada del sistema:</p>
<ul>
<li>systemctl enable servei.service: Crea un enllaç al fitxer de servei del sistema al lloc on systemd busca els fitxers de configuració dels serveis d&rsquo;arrencada. Si no es tracta d&rsquo;un servei natiu de systemd, fa ús de l&rsquo;eina systemd-sysv-install, per fer-ho retrocompatible.</li>
<li>systemctl disable servei.service: Elimina l&rsquo;enllaç creat amb enable.</li>
</ul>
</li>
<li>
<p>Consultar l&rsquo;estat d&rsquo;un servei:</p>
<ul>
<li>systemctl status servei.service</li>
</ul>
</li>
</ul>
<p>Veiem-ne un exemple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ systemctl status apache2.service 
● apache2.service - The Apache HTTP Server
   Loaded: loaded <span style="color:#f92672">(</span>/lib/systemd/system/apache2.service; enabled; vendor preset: enabled<span style="color:#f92672">)</span>
  Drop-In: /lib/systemd/system/apache2.service.d
           └─apache2-systemd.conf
   Active: active <span style="color:#f92672">(</span>running<span style="color:#f92672">)</span> since Mon 2018-09-10 21:39:12 CEST; 3h 17min ago
  Process: <span style="color:#ae81ff">7727</span> ExecReload<span style="color:#f92672">=</span>/usr/sbin/apachectl graceful <span style="color:#f92672">(</span>code<span style="color:#f92672">=</span>exited, status<span style="color:#f92672">=</span>0/SUCCESS<span style="color:#f92672">)</span>
  Process: <span style="color:#ae81ff">1201</span> ExecStart<span style="color:#f92672">=</span>/usr/sbin/apachectl start <span style="color:#f92672">(</span>code<span style="color:#f92672">=</span>exited, status<span style="color:#f92672">=</span>0/SUCCESS<span style="color:#f92672">)</span>
 Main PID: <span style="color:#ae81ff">1274</span> <span style="color:#f92672">(</span>apache2<span style="color:#f92672">)</span>
    Tasks: <span style="color:#ae81ff">6</span> <span style="color:#f92672">(</span>limit: 4915<span style="color:#f92672">)</span>
   CGroup: /system.slice/apache2.service
           ├─1274 /usr/sbin/apache2 -k start
           ├─7738 /usr/sbin/apache2 -k start
           ├─7739 /usr/sbin/apache2 -k start
           ├─7740 /usr/sbin/apache2 -k start
           ├─7741 /usr/sbin/apache2 -k start
           └─7742 /usr/sbin/apache2 -k start
</code></pre></div><p>Com veiem, ens dóna una descripció del servei, i informació diversa sobre la seua configuració i els processos relacionats. Com veiem, el servei té 6 processos (Tasks) associats, cadascun amb un PID diferent, però tots associats al mateix CGroup. Els CGroups (contorl groups) és una caracterísica del kernel de linux que limita els recursos d&rsquo;un conjunt de processos, per temes se seguretat.</p>
<p>Altres opcions que admet systemctl són:</p>
<ul>
<li><code>systemctl is-active servei.service</code>: retorna active o inactive, en funció de si és o no actiu.</li>
<li><code>systemctl is-enabled servei.service</code>: retorna enabled o error, segons si es troba o no activat en l&rsquo;inici, és a dir, que té un enllaç a la carpeta de configuració d&rsquo;arrancada.</li>
<li><code>systemctl is-failed servei.service</code>: retorna active, si es troba actiu, inactive si s&rsquo;ha aturat de forma intencionada, o failed si ha hagut algun error)</li>
</ul>
<h2 id="4-comunicació-entre-processos">4. Comunicació entre processos</h2>
<p>En aquest apartat veurem alguns mecanismes de comunicació entre processos a nivell de sistema operatiu.</p>
<h3 id="41-comunicació-mitjançant-entrada-i-eixida">4.1. Comunicació mitjançant entrada i eixida</h3>
<p>Una de les formes més senzilles que ofereix el sistema operatiu per comunicar processos és a través de l&rsquo;entrada i l&rsquo;eixida. Anem a fer un repàs a aquests mecanismes, així com diferents formes d&rsquo;execució de processos en la shell.</p>
<h4 id="redireccions">Redireccions</h4>
<p>Com sabem, cada procés té associats tres fitxers per possibilitar la seua cominicació:</p>
<ul>
<li><strong>stdin</strong>, amb descriptor de fitxer 0, que representa per on rep dades el procés (generalment associat a l&rsquo;entrada de teclat de la terminal)</li>
<li><strong>stdout</strong>, amb descriptor de fitxer 1, que representa on bolca la seua eixida el procés (generalment associat a la pantalla de la terminal)</li>
<li><strong>stderr</strong>, amb descriptor de fitxer 2, i que representa l&rsquo;eixida estàndard per als errors (generalment associat a la pantalla del terminal)</li>
</ul>
<p>Estos descriptors, poden ser redirigits per tal d&rsquo;aconseguir que la informació s&rsquo;envie o s&rsquo;agafe de fitxers en lloc de fer-ho de l&rsquo;entrada o eixida estàndard.</p>
<ul>
<li><strong>Redirecció de l&rsquo;entrada estàndard (&lt;)</strong>: Redirigeix l&rsquo;entrada de dades d&rsquo;un procés des d&rsquo;un fitxer en lloc de fer-ho des de teclat. Quan utilitzem &laquo;, agafem l&rsquo;entrada per a l&rsquo;ordre línia per línia, fins trobar l&rsquo;etiqueta indicada.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">  cat <span style="color:#e6db74">&lt;&lt; END (END</span><span style="color:#f92672">=</span>Ctrl+D<span style="color:#f92672">)</span>
</code></pre></div><ul>
<li><strong>Redirecció de l&rsquo;eixida estàndard (&gt; i &raquo;)</strong>: permet redirigir l&rsquo;eixida del procés a un fitxer, eliminant el seu contingut (operador &gt;), o afegint el resultat al final (&raquo;).</li>
</ul>
<pre><code>banner Salut! &gt; hola.txt
</code></pre><p><em>(Possiblement, l&rsquo;ordre banner no la tingueu instal·lada al sistema. El paquet que la incorpora és sysvbanner)</em></p>
<p>Altre exemple. Amb dos terminals obertes, en la primera esbrinem quin és l&rsquo;identificador de terminal amb <code>tty</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ tty
/dev/pts/2
</code></pre></div><p>I <strong>des d&rsquo;altra terminal</strong>, li enviem, per exemple l&rsquo;eixida d&rsquo;un ls:</p>
<pre><code>$ ls &gt; /dev/pts/2
</code></pre><ul>
<li><strong>Redirecció de l&rsquo;eixida d&rsquo;error estàndard: (2&gt;, 2&raquo;):</strong> Funciona de la mateixa manera que la redirecció de l&rsquo;eixida estàndard, però amb l&rsquo;eixida d&rsquo;error.</li>
</ul>
<pre><code>$ find -name &quot;*.txt&quot; 2&gt; /dev/null
</code></pre><p>Per altra banda, també podem fer combinacions d&rsquo;entrada i eixida:</p>
<pre><code>cat &lt;&lt; END &gt; fitxer.txt 
</code></pre><p>Aquest fitxer, llegirà de l&rsquo;entrada estàndard fins que introd introduim Ctrl+D i ho bolcarà sobre el fitxer fitxer.txt.</p>
<h4 id="execució-en-segon-plan-">Execució en segon plan (&amp;)</h4>
<p>Com sabem, quan llancem una ordre, aquesta s&rsquo;executa en primer pla, i no torna el control a l&rsquo;usuari fins que finalitza. Per tal de deixar el procés en execució sense que lleve el control a l&rsquo;usuari, podem llançar el procés en segon pla, amb:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ordre &amp;
</code></pre></div><p>Aquesta ordre, com podem comprovar retorna el PID del procés en segon pla entre corxetes.</p>
<p>Exemple:</p>
<pre><code>$ sleep 10 &amp;
[1] 8498
$ ps
  PID TTY          TIME CMD
 8138 pts/2    00:00:00 bash
 8498 pts/2    00:00:00 sleep
 8502 pts/2    00:00:00 ps
</code></pre><h5 id="seqüències-dordres-">Seqüències d&rsquo;ordres (;)</h5>
<p>Amb l&rsquo;operador ; podem construir llistes d&rsquo;ordres que s&rsquo;executen seqüencialment:</p>
<pre><code>sleep 3; echo &quot;fi&quot;
</code></pre><p><em>Exercici</em>: Comproveu la diferència entre les dues instruccions següents i intenteu entendre&rsquo;n el funcionament. Quina és la diferència d&rsquo;utilitzar els parèntesi o no?</p>
<pre><code>$ sleep 3; echo &quot;fi&quot; &amp;
</code></pre><pre><code>$ (sleep 3; echo &quot;fi&quot;) &amp;
</code></pre><h4 id="canonades-">Canonades (|)</h4>
<p>Les canonades (pipes) permeten connectar l&rsquo;eixida estàndard d&rsquo;un procés amb l&rsquo;entrada estàndard d&rsquo;altre, establint així una relació de productor-consumidor.</p>
<ul>
<li>Ús:
** productor | consumidor</li>
</ul>
<p>Veiem un exemple. Suposem que tenim un usuari (anomenat <em>usuari</em>) connectat per ssh a la nostra màquina, podem enviar-li un missatge amb write. Amb la següent ordre, el que farem serà enviar-li en resultat de l&rsquo;execució de l&rsquo;ordre &ldquo;banner Hola!&quot;:</p>
<pre><code> $ banner Hola! | write usuari
</code></pre><p>Amb açò, l&rsquo;eixida de l&rsquo;ordre banner és enviada a l&rsquo;usuari <em>usuari</em> (connectat a una altra terminal de la mateixa màquina).</p>
<h3 id="42-comunicació-amb-variables-dentorn-i-de-la-shell">4.2. Comunicació amb variables d&rsquo;entorn i de la shell</h3>
<p>Existeixen dos tipus de variables quan parlem de Bash: variables locals a la shell, i variables d&rsquo;entorn. Les variables d&rsquo;entorn  (definides amb EXPORT), poden ser utilitzades com a mecanisme de comunicació entre processos.</p>
<p>Veiem-ho amb un exemple:</p>
<ul>
<li>Fitxer p1.sh</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>MYVAR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Variable&#34;</span>;
echo <span style="color:#e6db74">&#34;Hola, soc el procés 1, i tinc definida la variable </span>$MYVAR<span style="color:#e6db74">&#34;</span>
echo <span style="color:#e6db74">&#34;Invoque a p2.sh i m&#39;espere que acabe:&#34;</span>
./p2.sh
echo <span style="color:#e6db74">&#34;p2.sh ha finalitzat amb eixida </span>$?<span style="color:#e6db74">&#34;</span>
echo <span style="color:#e6db74">&#34;Estat dels processos:&#34;</span>
ps -o pid,ppid,cmd,state
</code></pre></div><ul>
<li>Fitxer p2.sh</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>echo <span style="color:#e6db74">&#34;Hola, soc el procés 2, i puc accedir a </span>$MYVAR<span style="color:#e6db74">&#34;</span>
echo <span style="color:#e6db74">&#34;Estat dels processos:&#34;</span>
ps -o pid,ppid,cmd,state
sleep <span style="color:#ae81ff">5</span>
exit <span style="color:#ae81ff">3</span>
</code></pre></div><p>Quan llancem l&rsquo;script p1.sh, l&rsquo;eixida que obtenim és la següent:</p>
<pre><code>Hola, soc el procés 1, i tinc definida la variable Variable
Invoque a p2.sh i m'espere que acabe:
Hola, soc el procés 2, i puc accedir a 
Estat dels processos:
  PID  PPID CMD                         S
 6268  6264 /bin/bash                   S
16864  6268 /bin/bash ./p1.sh           S
16865 16864 /bin/bash ./p2.sh           S
16866 16865 ps -o pid,ppid,cmd,state    R
p2.sh ha finalitzat amb eixida 3
Estat dels processos:
  PID  PPID CMD                         S
 6268  6264 /bin/bash                   S
16864  6268 /bin/bash ./p1.sh           S
16868 16864 ps -o pid,ppid,cmd,state    R
</code></pre><p>Com podem vore, quan s&rsquo;invoca a p2.sh des de p1.sh no es té accés a la variable $MYVAR, definida en l&rsquo;script p1.sh, però en canvi, des del procés p1 sí que es pot accedir al valor que retorna l&rsquo;script p2.sh.</p>
<p>Per tal de poder transmetre el valor d&rsquo;aquesta variable, podem definir-la com a una variable d&rsquo;entorn amb export:</p>
<pre><code>export MYVAR=&quot;Variable&quot;;
</code></pre><h3 id="43-comunicació-mitjançat-senyals">4.3. Comunicació mitjançat senyals</h3>
<p>Les senyals són interrupcions de programari que avisen a un procés, durant el seu temps d&rsquo;execució, que s&rsquo;ha produit un esdeveniment. Aquestes senyals són enviades pel kernel al procés tot i que pot ser altre procés qui les genere. Algunes d&rsquo;aquestes senyals, podran ser també interpretades com a ordres que rep el procés.</p>
<h4 id="lordre-kill">L&rsquo;ordre Kill</h4>
<p>Per tal d&rsquo;enviar senyals a un procés fem ús de l&rsquo;ordre kill, amb la següent sintaxi:</p>
<pre><code>kill -número de senyal PID
</code></pre><p>Si no especifiquem res, la senyal que s&rsquo;envia és la número 15.
Els números de senyal més comuns són:</p>
<ul>
<li><strong>1</strong>: Permet aturar i reiniciar un servei (<strong>SIGHUP</strong>).</li>
<li><strong>2</strong>: Interrupció (Ctrl +c: <strong>SIGINT</strong>)</li>
<li><strong>9</strong>: Terminació abrupta del procés. (<strong>SIGKILL</strong>)</li>
<li><strong>15</strong>: Terminació controlada del procés (<strong>SIGTERM</strong>)</li>
</ul>
<p>Amb kill -l podem obtindre una llista de totes les senyals que podem enviar amb kill.
Veiem alguns exemples senzills:</p>
<ul>
<li><code>kill 1234 4321</code>:  Sense especificar senyal, envia SIGTERM als processos especificats, de manera que sol·licita la finalització de l&rsquo;execució dels processos indicats amb els PIDs.</li>
<li><code>kill -9 1234</code>: Fará que el procés amb PID 1234 isca de forma immediata (sense fer cap pregunta), enviant-li la senyal SIGKILL. Cal anar amb compte amb esta ordre perquè fa que el procés no acabe d&rsquo;una manera neta, podent deixar fitxers oberts o peticions pendents.</li>
<li><code>kill -19 1234</code>: Suspèn el procés amb PID 1234, enviant-lo la senyal SIGSTOP.</li>
<li><code>Kill -18 1234</code>: Reanudaria l&rsquo;execució del procés 1234, enviant-lo la senyal SIGCONT.</li>
</ul>
<h4 id="lordre-killall">L&rsquo;ordre killall</h4>
<p>Amb killall podem enviar-li una senyal concreta a tots els processos amb el mateix nom.</p>
<p>Per exemple:</p>
<ul>
<li><code>killall -HUP apache2</code>: Envia la senyal SIGHUP (1) a tots els processos apache2 del sistema, amb el que provoca que, si es tracta d&rsquo;un daemon, aquest es reinicie.</li>
</ul>
<h4 id="captura-de-senyals-lorde-trap">Captura de senyals: L&rsquo;orde trap</h4>
<p>Amb l&rsquo;ordre trap podem capturar senyals i realitzar certes accions en resposta a aquesta senyal. La sintaxi de trap és:</p>
<pre><code>trap 'Ordres' [llista_de_senyals]
</code></pre><p>El següent exemple ilustra un xicotet exemple d&rsquo;ús:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>
<span style="color:#75715e"># Definim una funció que compta d&#39;1 a 5,</span>
<span style="color:#75715e"># amb pauses d&#39;un segon</span>

compta<span style="color:#f92672">(){</span>
    <span style="color:#66d9ef">for</span> i in <span style="color:#f92672">{</span>0..5<span style="color:#f92672">}</span>; <span style="color:#66d9ef">do</span>
        echo $i
        sleep <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">done</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e"># Escrivim els següents missatges quan es reben les senyals 5 i 9</span>
trap <span style="color:#e6db74">&#39;echo capturant SIGKILL?&#39;</span> <span style="color:#ae81ff">9</span>      <span style="color:#75715e"># Compte, podem fer el</span>
                                      <span style="color:#75715e"># procés &#34;indestructible&#34;!</span>
trap <span style="color:#e6db74">&#39;echo capturant SIGTERM&#39;</span> <span style="color:#ae81ff">15</span>

<span style="color:#75715e"># Ignorem la interrupció 2 (SIGINT), mentre </span>
<span style="color:#75715e"># executem la funció compta.</span>

trap <span style="color:#e6db74">&#39;&#39;</span> <span style="color:#ae81ff">2</span> <span style="color:#75715e"># Si no posem cap ordre, simplement ignorem la senyal</span>
echo <span style="color:#e6db74">&#34;Ignorant SIGINT&#34;</span>
compta

<span style="color:#75715e"># Ara la capturem i executem una funció quan es rep SIGINT</span>
trap <span style="color:#e6db74">&#39;capturadora&#39;</span> <span style="color:#ae81ff">2</span>
echo <span style="color:#e6db74">&#34;Capturant SIGINT&#34;</span>

capturadora<span style="color:#f92672">(){</span>
   echo <span style="color:#e6db74">&#34;Has polsat Ctrl+C. Espera un moment.&#34;</span>
<span style="color:#f92672">}</span>

compta

<span style="color:#75715e"># Ara deixem de capturar la senyal</span>
trap - <span style="color:#ae81ff">2</span>
echo <span style="color:#e6db74">&#34;Ara podeu interromple l&#39;execució&#34;</span>
compta
</code></pre></div><p>Veiem un exemple de l&rsquo;execució, en el que llancem vàries interrupcions (Ctrl+C) a l&rsquo;script.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./test.sh 

Ignorant SIGINT
<span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">1</span>
^C^C2
<span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">4</span>
<span style="color:#ae81ff">5</span>
Capturant SIGINT
<span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">1</span>
^CHas polsat Ctrl+C. Espera un moment.
<span style="color:#ae81ff">2</span>
^CHas polsat Ctrl+C. Espera un moment.
<span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">4</span>
<span style="color:#ae81ff">5</span>
Ara podeu interromple l<span style="color:#960050;background-color:#1e0010">&#39;</span>execució
<span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">1</span>
^C
</code></pre></div><h3 id="44-mecanismes-ipc-inter-process-communication">4.4. Mecanismes IPC (Inter-Process Communication)</h3>
<p>Podriem dir que els mecanismes vistos fins ara possibiliten una comunicació entre processos de manera indirecta, aprofitant característiques del sistema, com l&rsquo;entrada i l&rsquo;eixida.</p>
<p>A continuació veurem alguns mecanismes ideats específicament per a la comunicació entre processos, bé en la mateixa màquina o en màquines remotes.</p>
<h4 id="canonades-amb-nom-cúes-de-missatges">Canonades amb nom (cúes de missatges)</h4>
<p>Bash ens permet la creació de canonaes amb nom (named pipes) que actúen com una cúa FIFO. Una canonada amb nom no és més que un tipus de fitxer especial sobre el que els processos poden llegir i escriure:</p>
<ul>
<li>Des de la terminal 1: Creem la canonada i ens quedem llegint fins que s&rsquo;escriu alguna cosa.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">mkfifo cola
cat cola
</code></pre></div><p>Veurem com el procés no finalitza, sinò que queda a l&rsquo;espera que entre informació en la cúa.</p>
<ul>
<li>Ara, des d&rsquo;una altra terminal (terminal 2), comprovem si el fitxer &ldquo;cola&rdquo; és una canonada amb nom i escrivim &ldquo;hola&rdquo; en ella, de manera que el missatge serà rebut a la terminal 1.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span> -p cola <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> echo <span style="color:#e6db74">&#34;hola&#34;</span> &gt; col
</code></pre></div><p>Cal tenir en compte que es tracta d&rsquo;un mecanisme bloquejant: Quan un productor escriu alguna cosa a la canonada, es queda a l&rsquo;espera que el consumidor la llisca, i si la canonada està buida, quan un consumidor intenta llegir, queda bloquejat fins que algun productor escriu. Per altra banda, cal considerar també que diversos productors poden escriure en la canonada, i quan el consumidor llisca la canonada, obtindrà tots els missatges que s&rsquo;han deixat.</p>
<h4 id="comunicació-amb-sockets">Comunicació amb sockets</h4>
<p>Els sockets permeten la comunicació entre processos situats en diferents màquines, i s&rsquo;especifiquen mitjançant una adreça IP i un número de port (bé TCP o UDP).</p>
<p>Bash permet establir connexions amb sockets TCP/UDP mitjançant els seudo-camins /dev/tcp i /dev/udp. Cal tindre en compte que no es tracta de fitxers reals, sinò d&rsquo;un mecanisme del sistema operatiu, que tracta, entre d&rsquo;altres coses, els sockets com si foren fitxers, de manera que sobre ells es poden realitzar les mateixes operacions.</p>
<p>La sintaxi per establir una connexió a un socket en bash és:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ exec <span style="color:#f92672">{</span>descriptor_de_fitxer<span style="color:#f92672">}</span>&lt;&gt;/dev/<span style="color:#f92672">{</span>protocol<span style="color:#f92672">}</span>/<span style="color:#f92672">{</span>host<span style="color:#f92672">}</span>/<span style="color:#f92672">{</span>port<span style="color:#f92672">}</span>
</code></pre></div><p>Sent el descriptor de fitxer un número positiu diferent de 0, 1 i 2 (ja que estos són utilitzats per a stdin, stdout i stderr).</p>
<p>Podem indicar que el socket siga bidireccional (&lt;&gt;) o unidireccional (&lt; ó &gt;).</p>
<p>Veiem-ho amb un exemple: per connectar-nos a Google, fariem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ exec 3&lt;&gt;/dev/tcp/www.google.com/80
</code></pre></div><p>Per veure que tenim la connexió creada, podem consultar al directori proc els descriptors de fitxers en ús pel procés actual (referit amb $$):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ file /proc/$$/fd/*
/proc/14942/fd/0:   symbolic link to /dev/pts/1
/proc/14942/fd/1:   symbolic link to /dev/pts/1
/proc/14942/fd/2:   symbolic link to /dev/pts/1
/proc/14942/fd/3:   broken symbolic link to socket:<span style="color:#f92672">[</span>90052<span style="color:#f92672">]</span>
</code></pre></div><p>Com veiem, els descriptor 0, 1 i 2 estàn enllaçats a la terminal 1, i el descriptor 3, està enllaçat a un socket.</p>
<p>Per altra banda, amb lsof (ordre que llista els fitxers utilitats per un procés), podem veure les connexions establertes pel procés actual ($$, que és el 14942 en este cas):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsof -p $$
COMMAND   PID     USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME
...
bash    <span style="color:#ae81ff">14942</span> joamuran    3u  IPv4  <span style="color:#ae81ff">90052</span>      0t0     TCP toki:45022-&gt;any-in-2678.1e100.net:http <span style="color:#f92672">(</span>ESTABLISHED<span style="color:#f92672">)</span>
...
</code></pre></div><p>Ara, a través d&rsquo;aquesta connexió podem enviar una petició GET al descriptor de fitxer amb un echo:</p>
<pre><code>$ echo &quot;GET /&quot; &gt;&amp;3
$  cat &lt;&amp;3
&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;
&lt;H1&gt;301 Moved&lt;/H1&gt;
The document has moved
&lt;A HREF=&quot;http://www.google.com/&quot;&gt;here&lt;/A&gt;.
&lt;/BODY&gt;&lt;/HTML&gt;
</code></pre><p>&hellip;</p>
<h5 id="leina-socat">L&rsquo;eina socat</h5>
<p>Amb l&rsquo;eina socat podem establir una comunicació bidireccional de flux de btyes entre dos canals, bé siguen tuberies, sockets, etc.</p>
<p>La sintaxi bàsica és:</p>
<pre><code>socat [opcions] [adeça0] [adreça1]
</code></pre><p>Amb açò, estableix un canal de comunicació entre les adreces indicades. Aquestes adreces poden contindre paraules clau, i aquestes poden tindre valors, especificats de la forma CLAU:valor. Per exemple:</p>
<p>En una terminal escrivim:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ socat -u TCP-LISTEN:5555 STDOUT
</code></pre></div><p>Veurem que es queda a l&rsquo;espera, ense fer res. Amb açò, hem establert un canal unidireccional (opció -u) entre un socket TCP que escoltarà en el port 5000 (TCP-LISTEN:5555), i escriurà el que rep per pantalla (STDOUT).</p>
<p>Si des d&rsquo;una altra terminal escrivim:</p>
<pre><code>socat -u STDIN TCP:127.0.0.1:5555
</code></pre><p>El que farem és redirigir l&rsquo;eixida estàndard (STDIN) al port TCP 55555 de la màquina local (127.0.0.1:5555).</p>
<p>Amb açò, el que haurem creat és un procés que llegeix la informació del socket 127.0.0.1:5555 i altre que escriu informació en aquest. A efectes pràctics, el que escrivim per la terminal 2, li arribarà doncs a la terminal 1.</p>
<p><img src="img/ExempleSocat.gif" alt="Exemple d&rsquo;ús de socat">
<em>Aquesta imatge és un gif animat. Podeu vore-la completa a la versió online.</em></p>

        </article>
<aside class="table-of-contents">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-processos-i-estats-dun-procés">1. Processos i estats d&rsquo;un procés</a>
      <ul>
        <li><a href="#11-utilitats-relacionades-amb-els-processos">1.1. Utilitats relacionades amb els processos</a></li>
      </ul>
    </li>
    <li><a href="#2-threads">2. Threads</a></li>
    <li><a href="#3-dimonis-i-serveis">3. Dimonis i serveis</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#4-comunicació-entre-processos">4. Comunicació entre processos</a>
      <ul>
        <li><a href="#41-comunicació-mitjançant-entrada-i-eixida">4.1. Comunicació mitjançant entrada i eixida</a></li>
        <li><a href="#42-comunicació-amb-variables-dentorn-i-de-la-shell">4.2. Comunicació amb variables d&rsquo;entorn i de la shell</a></li>
        <li><a href="#43-comunicació-mitjançat-senyals">4.3. Comunicació mitjançat senyals</a></li>
        <li><a href="#44-mecanismes-ipc-inter-process-communication">4.4. Mecanismes IPC (Inter-Process Communication)</a></li>
      </ul>
    </li>
  </ul>
</nav>

</aside>

<script>

    (function () {
        let entries = document.querySelectorAll(".table-of-contents li");

        for (entry of entries) {
            entry.addEventListener("click", function (e) {
                
                e.stopPropagation();
                for (sel of document.querySelectorAll(".selected"))
                    sel.classList.remove("selected");
                e.currentTarget.classList.add("selected");
                
                for (item of e.currentTarget.children)
                    if (item == "[object HTMLUListElement]")
                        if (item.style.display == "none")
                            item.style.display = "block";
                        else item.style.display = "none"

            });
        }

    
    let entriesh2 = document.querySelectorAll(".table-of-contents li > ul");

        for (entry of entriesh2) {
            entry.style.display = "none";
        }


    })();

</script>        

</div> 

<div class="footer-container">
    
</div>
</body>

</html>